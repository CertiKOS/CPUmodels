open Big_int


type __ = Obj.t
let __ = let rec f _ = Obj.repr f in Obj.repr f

(** val xorb : bool -> bool -> bool **)

let xorb b1 b2 =
  if b1 then if b2 then false else true else b2

(** val negb : bool -> bool **)

let negb = function
| true -> false
| false -> true

type ('a, 'b) sum =
| Inl of 'a
| Inr of 'b

(** val fst : ('a1 * 'a2) -> 'a1 **)

let fst = function
| (x, y) -> x

(** val snd : ('a1 * 'a2) -> 'a2 **)

let snd = function
| (x, y) -> y

(** val length : 'a1 list -> Big.big_int **)

let rec length = function
| [] -> Big.zero
| y :: l' -> Big.succ (length l')

(** val app : 'a1 list -> 'a1 list -> 'a1 list **)

let rec app l m =
  match l with
  | [] -> m
  | a :: l1 -> a :: (app l1 m)

type comparison =
| Eq
| Lt
| Gt

type compareSpecT =
| CompEqT
| CompLtT
| CompGtT

(** val compareSpec2Type : comparison -> compareSpecT **)

let compareSpec2Type = function
| Eq -> CompEqT
| Lt -> CompLtT
| Gt -> CompGtT

type 'a compSpecT = compareSpecT

(** val compSpec2Type : 'a1 -> 'a1 -> comparison -> 'a1 compSpecT **)

let compSpec2Type x y c =
  compareSpec2Type c

type 'a sig0 =
  'a
  (* singleton inductive, whose constructor was exist *)

type ('a, 'p) sigT =
| ExistT of 'a * 'p

type 'a exc = 'a option

(** val value : 'a1 -> 'a1 option **)

let value x =
  Some x

(** val error : 'a1 option **)

let error =
  None

(** val plus : Big.big_int -> Big.big_int -> Big.big_int **)

let rec plus = Big.add

(** val mult : Big.big_int -> Big.big_int -> Big.big_int **)

let rec mult = Big.mult

(** val minus : Big.big_int -> Big.big_int -> Big.big_int **)

let rec minus = fun n m -> Big.max Big.zero (Big.sub n m)

(** val nat_iter : Big.big_int -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)

let rec nat_iter n f x =
  Big.nat_case
    (fun _ ->
    x)
    (fun n' ->
    f (nat_iter n' f x))
    n

(** val bool_dec : bool -> bool -> bool **)

let bool_dec b1 b2 =
  if b1 then if b2 then true else false else if b2 then false else true

(** val eqb : bool -> bool -> bool **)

let eqb b1 b2 =
  if b1 then b2 else if b2 then false else true

type reflect =
| ReflectT
| ReflectF

(** val iff_reflect : bool -> reflect **)

let iff_reflect = function
| true -> ReflectT
| false -> ReflectF

module Pos = 
 struct 
  type t = Big.big_int
  
  (** val succ : Big.big_int -> Big.big_int **)
  
  let rec succ x =
    Big.positive_case
      (fun p -> Big.double
      (succ p))
      (fun p -> Big.doubleplusone
      p)
      (fun _ -> Big.double
      Big.one)
      x
  
  (** val add : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec add x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q -> Big.double
        (add_carry p q))
        (fun q -> Big.doubleplusone
        (add p q))
        (fun _ -> Big.double
        (succ p))
        y)
      (fun p ->
      Big.positive_case
        (fun q -> Big.doubleplusone
        (add p q))
        (fun q -> Big.double
        (add p q))
        (fun _ -> Big.doubleplusone
        p)
        y)
      (fun _ ->
      Big.positive_case
        (fun q -> Big.double
        (succ q))
        (fun q -> Big.doubleplusone
        q)
        (fun _ -> Big.double
        Big.one)
        y)
      x
  
  (** val add_carry : Big.big_int -> Big.big_int -> Big.big_int **)
  
  and add_carry x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q -> Big.doubleplusone
        (add_carry p q))
        (fun q -> Big.double
        (add_carry p q))
        (fun _ -> Big.doubleplusone
        (succ p))
        y)
      (fun p ->
      Big.positive_case
        (fun q -> Big.double
        (add_carry p q))
        (fun q -> Big.doubleplusone
        (add p q))
        (fun _ -> Big.double
        (succ p))
        y)
      (fun _ ->
      Big.positive_case
        (fun q -> Big.doubleplusone
        (succ q))
        (fun q -> Big.double
        (succ q))
        (fun _ -> Big.doubleplusone
        Big.one)
        y)
      x
  
  (** val pred_double : Big.big_int -> Big.big_int **)
  
  let rec pred_double x =
    Big.positive_case
      (fun p -> Big.doubleplusone (Big.double
      p))
      (fun p -> Big.doubleplusone
      (pred_double p))
      (fun _ ->
      Big.one)
      x
  
  (** val pred : Big.big_int -> Big.big_int **)
  
  let pred x =
    Big.positive_case
      (fun p -> Big.double
      p)
      (fun p ->
      pred_double p)
      (fun _ ->
      Big.one)
      x
  
  (** val pred_N : Big.big_int -> Big.big_int **)
  
  let pred_N x =
    Big.positive_case
      (fun p -> (Big.double
      p))
      (fun p ->
      (pred_double p))
      (fun _ ->
      Big.zero)
      x
  
  type mask =
  | IsNul
  | IsPos of Big.big_int
  | IsNeg
  
  (** val mask_rect : 'a1 -> (Big.big_int -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rect f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val mask_rec : 'a1 -> (Big.big_int -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rec f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val succ_double_mask : mask -> mask **)
  
  let succ_double_mask = function
  | IsNul -> IsPos Big.one
  | IsPos p -> IsPos (Big.doubleplusone p)
  | IsNeg -> IsNeg
  
  (** val double_mask : mask -> mask **)
  
  let double_mask = function
  | IsPos p -> IsPos (Big.double p)
  | x0 -> x0
  
  (** val double_pred_mask : Big.big_int -> mask **)
  
  let double_pred_mask x =
    Big.positive_case
      (fun p -> IsPos (Big.double (Big.double
      p)))
      (fun p -> IsPos (Big.double
      (pred_double p)))
      (fun _ ->
      IsNul)
      x
  
  (** val pred_mask : mask -> mask **)
  
  let pred_mask = function
  | IsPos q ->
    (Big.positive_case
       (fun p0 -> IsPos
       (pred q))
       (fun p0 -> IsPos
       (pred q))
       (fun _ ->
       IsNul)
       q)
  | _ -> IsNeg
  
  (** val sub_mask : Big.big_int -> Big.big_int -> mask **)
  
  let rec sub_mask x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        double_mask (sub_mask p q))
        (fun q ->
        succ_double_mask (sub_mask p q))
        (fun _ -> IsPos (Big.double
        p))
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun q ->
        double_mask (sub_mask p q))
        (fun _ -> IsPos
        (pred_double p))
        y)
      (fun _ ->
      Big.positive_case
        (fun p ->
        IsNeg)
        (fun p ->
        IsNeg)
        (fun _ ->
        IsNul)
        y)
      x
  
  (** val sub_mask_carry : Big.big_int -> Big.big_int -> mask **)
  
  and sub_mask_carry x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun q ->
        double_mask (sub_mask p q))
        (fun _ -> IsPos
        (pred_double p))
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        double_mask (sub_mask_carry p q))
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun _ ->
        double_pred_mask p)
        y)
      (fun _ ->
      IsNeg)
      x
  
  (** val sub : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let sub x y =
    match sub_mask x y with
    | IsPos z -> z
    | _ -> Big.one
  
  (** val mul : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec mul x y =
    Big.positive_case
      (fun p ->
      add y (Big.double (mul p y)))
      (fun p -> Big.double
      (mul p y))
      (fun _ ->
      y)
      x
  
  (** val iter : Big.big_int -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)
  
  let rec iter n f x =
    Big.positive_case
      (fun n' ->
      f (iter n' f (iter n' f x)))
      (fun n' ->
      iter n' f (iter n' f x))
      (fun _ ->
      f x)
      n
  
  (** val pow : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let pow x y =
    iter y (mul x) Big.one
  
  (** val square : Big.big_int -> Big.big_int **)
  
  let rec square p =
    Big.positive_case
      (fun p0 -> Big.doubleplusone (Big.double
      (add (square p0) p0)))
      (fun p0 -> Big.double (Big.double
      (square p0)))
      (fun _ ->
      Big.one)
      p
  
  (** val div2 : Big.big_int -> Big.big_int **)
  
  let div2 p =
    Big.positive_case
      (fun p0 ->
      p0)
      (fun p0 ->
      p0)
      (fun _ ->
      Big.one)
      p
  
  (** val div2_up : Big.big_int -> Big.big_int **)
  
  let div2_up p =
    Big.positive_case
      (fun p0 ->
      succ p0)
      (fun p0 ->
      p0)
      (fun _ ->
      Big.one)
      p
  
  (** val size_nat : Big.big_int -> Big.big_int **)
  
  let rec size_nat p =
    Big.positive_case
      (fun p0 -> Big.succ
      (size_nat p0))
      (fun p0 -> Big.succ
      (size_nat p0))
      (fun _ -> Big.succ
      Big.zero)
      p
  
  (** val size : Big.big_int -> Big.big_int **)
  
  let rec size p =
    Big.positive_case
      (fun p0 ->
      succ (size p0))
      (fun p0 ->
      succ (size p0))
      (fun _ ->
      Big.one)
      p
  
  (** val compare_cont :
      Big.big_int -> Big.big_int -> comparison -> comparison **)
  
  let rec compare_cont x y r2 =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        compare_cont p q r2)
        (fun q ->
        compare_cont p q Gt)
        (fun _ ->
        Gt)
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        compare_cont p q Lt)
        (fun q ->
        compare_cont p q r2)
        (fun _ ->
        Gt)
        y)
      (fun _ ->
      Big.positive_case
        (fun q ->
        Lt)
        (fun q ->
        Lt)
        (fun _ ->
        r2)
        y)
      x
  
  (** val compare : Big.big_int -> Big.big_int -> comparison **)
  
  let compare x y =
    compare_cont x y Eq
  
  (** val min : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let min p p' =
    match compare p p' with
    | Gt -> p'
    | _ -> p
  
  (** val max : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let max p p' =
    match compare p p' with
    | Gt -> p
    | _ -> p'
  
  (** val eqb : Big.big_int -> Big.big_int -> bool **)
  
  let rec eqb p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        eqb p0 q0)
        (fun p1 ->
        false)
        (fun _ ->
        false)
        q)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        false)
        (fun q0 ->
        eqb p0 q0)
        (fun _ ->
        false)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        false)
        (fun _ ->
        true)
        q)
      p
  
  (** val leb : Big.big_int -> Big.big_int -> bool **)
  
  let leb x y =
    match compare x y with
    | Gt -> false
    | _ -> true
  
  (** val ltb : Big.big_int -> Big.big_int -> bool **)
  
  let ltb x y =
    match compare x y with
    | Lt -> true
    | _ -> false
  
  (** val sqrtrem_step :
      (Big.big_int -> Big.big_int) -> (Big.big_int -> Big.big_int) ->
      (Big.big_int * mask) -> Big.big_int * mask **)
  
  let sqrtrem_step f g = function
  | (s, y) ->
    (match y with
     | IsPos r2 ->
       let s' = Big.doubleplusone (Big.double s) in
       let r' = g (f r2) in
       if leb s' r'
       then ((Big.doubleplusone s), (sub_mask r' s'))
       else ((Big.double s), (IsPos r'))
     | _ ->
       ((Big.double s),
         (sub_mask (g (f Big.one)) (Big.double (Big.double Big.one)))))
  
  (** val sqrtrem : Big.big_int -> Big.big_int * mask **)
  
  let rec sqrtrem p =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        sqrtrem_step (fun x -> Big.doubleplusone x) (fun x ->
          Big.doubleplusone x) (sqrtrem p1))
        (fun p1 ->
        sqrtrem_step (fun x -> Big.double x) (fun x -> Big.doubleplusone x)
          (sqrtrem p1))
        (fun _ -> (Big.one, (IsPos (Big.double
        Big.one))))
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        sqrtrem_step (fun x -> Big.doubleplusone x) (fun x -> Big.double x)
          (sqrtrem p1))
        (fun p1 ->
        sqrtrem_step (fun x -> Big.double x) (fun x -> Big.double x)
          (sqrtrem p1))
        (fun _ -> (Big.one, (IsPos
        Big.one)))
        p0)
      (fun _ -> (Big.one,
      IsNul))
      p
  
  (** val sqrt : Big.big_int -> Big.big_int **)
  
  let sqrt p =
    fst (sqrtrem p)
  
  (** val gcdn : Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec gcdn n a b =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun n0 ->
      Big.positive_case
        (fun a' ->
        Big.positive_case
          (fun b' ->
          match compare a' b' with
          | Eq -> a
          | Lt -> gcdn n0 (sub b' a') a
          | Gt -> gcdn n0 (sub a' b') b)
          (fun b0 ->
          gcdn n0 a b0)
          (fun _ ->
          Big.one)
          b)
        (fun a0 ->
        Big.positive_case
          (fun p ->
          gcdn n0 a0 b)
          (fun b0 -> Big.double
          (gcdn n0 a0 b0))
          (fun _ ->
          Big.one)
          b)
        (fun _ ->
        Big.one)
        a)
      n
  
  (** val gcd : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  
  (** val ggcdn :
      Big.big_int -> Big.big_int -> Big.big_int ->
      Big.big_int * (Big.big_int * Big.big_int) **)
  
  let rec ggcdn n a b =
    Big.nat_case
      (fun _ -> (Big.one, (a,
      b)))
      (fun n0 ->
      Big.positive_case
        (fun a' ->
        Big.positive_case
          (fun b' ->
          match compare a' b' with
          | Eq -> (a, (Big.one, Big.one))
          | Lt ->
            let (g, p) = ggcdn n0 (sub b' a') a in
            let (ba, aa) = p in (g, (aa, (add aa (Big.double ba))))
          | Gt ->
            let (g, p) = ggcdn n0 (sub a' b') b in
            let (ab, bb) = p in (g, ((add bb (Big.double ab)), bb)))
          (fun b0 ->
          let (g, p) = ggcdn n0 a b0 in
          let (aa, bb) = p in (g, (aa, (Big.double bb))))
          (fun _ -> (Big.one, (a,
          Big.one)))
          b)
        (fun a0 ->
        Big.positive_case
          (fun p ->
          let (g, p0) = ggcdn n0 a0 b in
          let (aa, bb) = p0 in (g, ((Big.double aa), bb)))
          (fun b0 ->
          let (g, p) = ggcdn n0 a0 b0 in ((Big.double g), p))
          (fun _ -> (Big.one, (a,
          Big.one)))
          b)
        (fun _ -> (Big.one, (Big.one,
        b)))
        a)
      n
  
  (** val ggcd :
      Big.big_int -> Big.big_int -> Big.big_int * (Big.big_int * Big.big_int) **)
  
  let ggcd a b =
    ggcdn (plus (size_nat a) (size_nat b)) a b
  
  (** val coq_Nsucc_double : Big.big_int -> Big.big_int **)
  
  let coq_Nsucc_double x =
    Big.n_case
      (fun _ ->
      Big.one)
      (fun p -> (Big.doubleplusone
      p))
      x
  
  (** val coq_Ndouble : Big.big_int -> Big.big_int **)
  
  let coq_Ndouble n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p -> (Big.double
      p))
      n
  
  (** val coq_lor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec coq_lor p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 -> Big.doubleplusone
        (coq_lor p0 q0))
        (fun q0 -> Big.doubleplusone
        (coq_lor p0 q0))
        (fun _ ->
        p)
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 -> Big.doubleplusone
        (coq_lor p0 q0))
        (fun q0 -> Big.double
        (coq_lor p0 q0))
        (fun _ -> Big.doubleplusone
        p0)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        q)
        (fun q0 -> Big.doubleplusone
        q0)
        (fun _ ->
        q)
        q)
      p
  
  (** val coq_land : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec coq_land p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Nsucc_double (coq_land p0 q0))
        (fun q0 ->
        coq_Ndouble (coq_land p0 q0))
        (fun _ ->
        Big.one)
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (coq_land p0 q0))
        (fun q0 ->
        coq_Ndouble (coq_land p0 q0))
        (fun _ ->
        Big.zero)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        Big.one)
        (fun q0 ->
        Big.zero)
        (fun _ ->
        Big.one)
        q)
      p
  
  (** val ldiff : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec ldiff p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (ldiff p0 q0))
        (fun q0 ->
        coq_Nsucc_double (ldiff p0 q0))
        (fun _ -> (Big.double
        p0))
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (ldiff p0 q0))
        (fun q0 ->
        coq_Ndouble (ldiff p0 q0))
        (fun _ ->
        p)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        Big.zero)
        (fun q0 ->
        Big.one)
        (fun _ ->
        Big.zero)
        q)
      p
  
  (** val coq_lxor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec coq_lxor p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (coq_lxor p0 q0))
        (fun q0 ->
        coq_Nsucc_double (coq_lxor p0 q0))
        (fun _ -> (Big.double
        p0))
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Nsucc_double (coq_lxor p0 q0))
        (fun q0 ->
        coq_Ndouble (coq_lxor p0 q0))
        (fun _ -> (Big.doubleplusone
        p0))
        q)
      (fun _ ->
      Big.positive_case
        (fun q0 -> (Big.double
        q0))
        (fun q0 -> (Big.doubleplusone
        q0))
        (fun _ ->
        Big.zero)
        q)
      p
  
  (** val shiftl_nat : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftl_nat p n =
    nat_iter n (fun x -> Big.double x) p
  
  (** val shiftr_nat : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftr_nat p n =
    nat_iter n div2 p
  
  (** val shiftl : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftl p n =
    Big.n_case
      (fun _ ->
      p)
      (fun n0 ->
      iter n0 (fun x -> Big.double x) p)
      n
  
  (** val shiftr : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftr p n =
    Big.n_case
      (fun _ ->
      p)
      (fun n0 ->
      iter n0 div2 p)
      n
  
  (** val testbit_nat : Big.big_int -> Big.big_int -> bool **)
  
  let rec testbit_nat p n =
    Big.positive_case
      (fun p0 ->
      Big.nat_case
        (fun _ ->
        true)
        (fun n' ->
        testbit_nat p0 n')
        n)
      (fun p0 ->
      Big.nat_case
        (fun _ ->
        false)
        (fun n' ->
        testbit_nat p0 n')
        n)
      (fun _ ->
      Big.nat_case
        (fun _ ->
        true)
        (fun n0 ->
        false)
        n)
      p
  
  (** val testbit : Big.big_int -> Big.big_int -> bool **)
  
  let rec testbit p n =
    Big.positive_case
      (fun p0 ->
      Big.n_case
        (fun _ ->
        true)
        (fun n0 ->
        testbit p0 (pred_N n0))
        n)
      (fun p0 ->
      Big.n_case
        (fun _ ->
        false)
        (fun n0 ->
        testbit p0 (pred_N n0))
        n)
      (fun _ ->
      Big.n_case
        (fun _ ->
        true)
        (fun p0 ->
        false)
        n)
      p
  
  (** val iter_op : ('a1 -> 'a1 -> 'a1) -> Big.big_int -> 'a1 -> 'a1 **)
  
  let rec iter_op op p a =
    Big.positive_case
      (fun p0 ->
      op a (iter_op op p0 (op a a)))
      (fun p0 ->
      iter_op op p0 (op a a))
      (fun _ ->
      a)
      p
  
  (** val to_nat : Big.big_int -> Big.big_int **)
  
  let to_nat x =
    iter_op plus x (Big.succ Big.zero)
  
  (** val of_nat : Big.big_int -> Big.big_int **)
  
  let rec of_nat n =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun x ->
      Big.nat_case
        (fun _ ->
        Big.one)
        (fun n0 ->
        succ (of_nat x))
        x)
      n
  
  (** val of_succ_nat : Big.big_int -> Big.big_int **)
  
  let rec of_succ_nat n =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun x ->
      succ (of_succ_nat x))
      n
 end

module Coq_Pos = 
 struct 
  type t = Big.big_int
  
  (** val succ : Big.big_int -> Big.big_int **)
  
  let rec succ = Big.succ
  
  (** val add : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec add = Big.add
  
  (** val add_carry : Big.big_int -> Big.big_int -> Big.big_int **)
  
  and add_carry x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q -> Big.doubleplusone
        (add_carry p q))
        (fun q -> Big.double
        (add_carry p q))
        (fun _ -> Big.doubleplusone
        (succ p))
        y)
      (fun p ->
      Big.positive_case
        (fun q -> Big.double
        (add_carry p q))
        (fun q -> Big.doubleplusone
        (add p q))
        (fun _ -> Big.double
        (succ p))
        y)
      (fun _ ->
      Big.positive_case
        (fun q -> Big.doubleplusone
        (succ q))
        (fun q -> Big.double
        (succ q))
        (fun _ -> Big.doubleplusone
        Big.one)
        y)
      x
  
  (** val pred_double : Big.big_int -> Big.big_int **)
  
  let rec pred_double x =
    Big.positive_case
      (fun p -> Big.doubleplusone (Big.double
      p))
      (fun p -> Big.doubleplusone
      (pred_double p))
      (fun _ ->
      Big.one)
      x
  
  (** val pred : Big.big_int -> Big.big_int **)
  
  let pred = fun n -> Big.max Big.one (Big.pred n)
  
  (** val pred_N : Big.big_int -> Big.big_int **)
  
  let pred_N x =
    Big.positive_case
      (fun p -> (Big.double
      p))
      (fun p ->
      (pred_double p))
      (fun _ ->
      Big.zero)
      x
  
  type mask = Pos.mask =
  | IsNul
  | IsPos of Big.big_int
  | IsNeg
  
  (** val mask_rect : 'a1 -> (Big.big_int -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rect f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val mask_rec : 'a1 -> (Big.big_int -> 'a1) -> 'a1 -> mask -> 'a1 **)
  
  let mask_rec f f0 f1 = function
  | IsNul -> f
  | IsPos x -> f0 x
  | IsNeg -> f1
  
  (** val succ_double_mask : mask -> mask **)
  
  let succ_double_mask = function
  | IsNul -> IsPos Big.one
  | IsPos p -> IsPos (Big.doubleplusone p)
  | IsNeg -> IsNeg
  
  (** val double_mask : mask -> mask **)
  
  let double_mask = function
  | IsPos p -> IsPos (Big.double p)
  | x0 -> x0
  
  (** val double_pred_mask : Big.big_int -> mask **)
  
  let double_pred_mask x =
    Big.positive_case
      (fun p -> IsPos (Big.double (Big.double
      p)))
      (fun p -> IsPos (Big.double
      (pred_double p)))
      (fun _ ->
      IsNul)
      x
  
  (** val pred_mask : mask -> mask **)
  
  let pred_mask = function
  | IsPos q ->
    (Big.positive_case
       (fun p0 -> IsPos
       (pred q))
       (fun p0 -> IsPos
       (pred q))
       (fun _ ->
       IsNul)
       q)
  | _ -> IsNeg
  
  (** val sub_mask : Big.big_int -> Big.big_int -> mask **)
  
  let rec sub_mask x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        double_mask (sub_mask p q))
        (fun q ->
        succ_double_mask (sub_mask p q))
        (fun _ -> IsPos (Big.double
        p))
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun q ->
        double_mask (sub_mask p q))
        (fun _ -> IsPos
        (pred_double p))
        y)
      (fun _ ->
      Big.positive_case
        (fun p ->
        IsNeg)
        (fun p ->
        IsNeg)
        (fun _ ->
        IsNul)
        y)
      x
  
  (** val sub_mask_carry : Big.big_int -> Big.big_int -> mask **)
  
  and sub_mask_carry x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun q ->
        double_mask (sub_mask p q))
        (fun _ -> IsPos
        (pred_double p))
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        double_mask (sub_mask_carry p q))
        (fun q ->
        succ_double_mask (sub_mask_carry p q))
        (fun _ ->
        double_pred_mask p)
        y)
      (fun _ ->
      IsNeg)
      x
  
  (** val sub : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let sub = fun n m -> Big.max Big.one (Big.sub n m)
  
  (** val mul : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec mul = Big.mult
  
  (** val iter : Big.big_int -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)
  
  let rec iter n f x =
    Big.positive_case
      (fun n' ->
      f (iter n' f (iter n' f x)))
      (fun n' ->
      iter n' f (iter n' f x))
      (fun _ ->
      f x)
      n
  
  (** val pow : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let pow x y =
    iter y (mul x) Big.one
  
  (** val square : Big.big_int -> Big.big_int **)
  
  let rec square p =
    Big.positive_case
      (fun p0 -> Big.doubleplusone (Big.double
      (add (square p0) p0)))
      (fun p0 -> Big.double (Big.double
      (square p0)))
      (fun _ ->
      Big.one)
      p
  
  (** val div2 : Big.big_int -> Big.big_int **)
  
  let div2 p =
    Big.positive_case
      (fun p0 ->
      p0)
      (fun p0 ->
      p0)
      (fun _ ->
      Big.one)
      p
  
  (** val div2_up : Big.big_int -> Big.big_int **)
  
  let div2_up p =
    Big.positive_case
      (fun p0 ->
      succ p0)
      (fun p0 ->
      p0)
      (fun _ ->
      Big.one)
      p
  
  (** val size_nat : Big.big_int -> Big.big_int **)
  
  let rec size_nat p =
    Big.positive_case
      (fun p0 -> Big.succ
      (size_nat p0))
      (fun p0 -> Big.succ
      (size_nat p0))
      (fun _ -> Big.succ
      Big.zero)
      p
  
  (** val size : Big.big_int -> Big.big_int **)
  
  let rec size p =
    Big.positive_case
      (fun p0 ->
      succ (size p0))
      (fun p0 ->
      succ (size p0))
      (fun _ ->
      Big.one)
      p
  
  (** val compare_cont :
      Big.big_int -> Big.big_int -> comparison -> comparison **)
  
  let rec compare_cont = fun x y c -> Big.compare_case c Lt Gt x y
  
  (** val compare : Big.big_int -> Big.big_int -> comparison **)
  
  let compare = fun x y -> Big.compare_case Eq Lt Gt x y
  
  (** val min : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let min = Big.min
  
  (** val max : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let max = Big.max
  
  (** val eqb : Big.big_int -> Big.big_int -> bool **)
  
  let rec eqb p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        eqb p0 q0)
        (fun p1 ->
        false)
        (fun _ ->
        false)
        q)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        false)
        (fun q0 ->
        eqb p0 q0)
        (fun _ ->
        false)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        false)
        (fun _ ->
        true)
        q)
      p
  
  (** val leb : Big.big_int -> Big.big_int -> bool **)
  
  let leb x y =
    match compare x y with
    | Gt -> false
    | _ -> true
  
  (** val ltb : Big.big_int -> Big.big_int -> bool **)
  
  let ltb x y =
    match compare x y with
    | Lt -> true
    | _ -> false
  
  (** val sqrtrem_step :
      (Big.big_int -> Big.big_int) -> (Big.big_int -> Big.big_int) ->
      (Big.big_int * mask) -> Big.big_int * mask **)
  
  let sqrtrem_step f g = function
  | (s, y) ->
    (match y with
     | IsPos r2 ->
       let s' = Big.doubleplusone (Big.double s) in
       let r' = g (f r2) in
       if leb s' r'
       then ((Big.doubleplusone s), (sub_mask r' s'))
       else ((Big.double s), (IsPos r'))
     | _ ->
       ((Big.double s),
         (sub_mask (g (f Big.one)) (Big.double (Big.double Big.one)))))
  
  (** val sqrtrem : Big.big_int -> Big.big_int * mask **)
  
  let rec sqrtrem p =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        sqrtrem_step (fun x -> Big.doubleplusone x) (fun x ->
          Big.doubleplusone x) (sqrtrem p1))
        (fun p1 ->
        sqrtrem_step (fun x -> Big.double x) (fun x -> Big.doubleplusone x)
          (sqrtrem p1))
        (fun _ -> (Big.one, (IsPos (Big.double
        Big.one))))
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        sqrtrem_step (fun x -> Big.doubleplusone x) (fun x -> Big.double x)
          (sqrtrem p1))
        (fun p1 ->
        sqrtrem_step (fun x -> Big.double x) (fun x -> Big.double x)
          (sqrtrem p1))
        (fun _ -> (Big.one, (IsPos
        Big.one)))
        p0)
      (fun _ -> (Big.one,
      IsNul))
      p
  
  (** val sqrt : Big.big_int -> Big.big_int **)
  
  let sqrt p =
    fst (sqrtrem p)
  
  (** val gcdn : Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec gcdn n a b =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun n0 ->
      Big.positive_case
        (fun a' ->
        Big.positive_case
          (fun b' ->
          match compare a' b' with
          | Eq -> a
          | Lt -> gcdn n0 (sub b' a') a
          | Gt -> gcdn n0 (sub a' b') b)
          (fun b0 ->
          gcdn n0 a b0)
          (fun _ ->
          Big.one)
          b)
        (fun a0 ->
        Big.positive_case
          (fun p ->
          gcdn n0 a0 b)
          (fun b0 -> Big.double
          (gcdn n0 a0 b0))
          (fun _ ->
          Big.one)
          b)
        (fun _ ->
        Big.one)
        a)
      n
  
  (** val gcd : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let gcd a b =
    gcdn (plus (size_nat a) (size_nat b)) a b
  
  (** val ggcdn :
      Big.big_int -> Big.big_int -> Big.big_int ->
      Big.big_int * (Big.big_int * Big.big_int) **)
  
  let rec ggcdn n a b =
    Big.nat_case
      (fun _ -> (Big.one, (a,
      b)))
      (fun n0 ->
      Big.positive_case
        (fun a' ->
        Big.positive_case
          (fun b' ->
          match compare a' b' with
          | Eq -> (a, (Big.one, Big.one))
          | Lt ->
            let (g, p) = ggcdn n0 (sub b' a') a in
            let (ba, aa) = p in (g, (aa, (add aa (Big.double ba))))
          | Gt ->
            let (g, p) = ggcdn n0 (sub a' b') b in
            let (ab, bb) = p in (g, ((add bb (Big.double ab)), bb)))
          (fun b0 ->
          let (g, p) = ggcdn n0 a b0 in
          let (aa, bb) = p in (g, (aa, (Big.double bb))))
          (fun _ -> (Big.one, (a,
          Big.one)))
          b)
        (fun a0 ->
        Big.positive_case
          (fun p ->
          let (g, p0) = ggcdn n0 a0 b in
          let (aa, bb) = p0 in (g, ((Big.double aa), bb)))
          (fun b0 ->
          let (g, p) = ggcdn n0 a0 b0 in ((Big.double g), p))
          (fun _ -> (Big.one, (a,
          Big.one)))
          b)
        (fun _ -> (Big.one, (Big.one,
        b)))
        a)
      n
  
  (** val ggcd :
      Big.big_int -> Big.big_int -> Big.big_int * (Big.big_int * Big.big_int) **)
  
  let ggcd a b =
    ggcdn (plus (size_nat a) (size_nat b)) a b
  
  (** val coq_Nsucc_double : Big.big_int -> Big.big_int **)
  
  let coq_Nsucc_double x =
    Big.n_case
      (fun _ ->
      Big.one)
      (fun p -> (Big.doubleplusone
      p))
      x
  
  (** val coq_Ndouble : Big.big_int -> Big.big_int **)
  
  let coq_Ndouble n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p -> (Big.double
      p))
      n
  
  (** val coq_lor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec coq_lor p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 -> Big.doubleplusone
        (coq_lor p0 q0))
        (fun q0 -> Big.doubleplusone
        (coq_lor p0 q0))
        (fun _ ->
        p)
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 -> Big.doubleplusone
        (coq_lor p0 q0))
        (fun q0 -> Big.double
        (coq_lor p0 q0))
        (fun _ -> Big.doubleplusone
        p0)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        q)
        (fun q0 -> Big.doubleplusone
        q0)
        (fun _ ->
        q)
        q)
      p
  
  (** val coq_land : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec coq_land p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Nsucc_double (coq_land p0 q0))
        (fun q0 ->
        coq_Ndouble (coq_land p0 q0))
        (fun _ ->
        Big.one)
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (coq_land p0 q0))
        (fun q0 ->
        coq_Ndouble (coq_land p0 q0))
        (fun _ ->
        Big.zero)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        Big.one)
        (fun q0 ->
        Big.zero)
        (fun _ ->
        Big.one)
        q)
      p
  
  (** val ldiff : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec ldiff p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (ldiff p0 q0))
        (fun q0 ->
        coq_Nsucc_double (ldiff p0 q0))
        (fun _ -> (Big.double
        p0))
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (ldiff p0 q0))
        (fun q0 ->
        coq_Ndouble (ldiff p0 q0))
        (fun _ ->
        p)
        q)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        Big.zero)
        (fun q0 ->
        Big.one)
        (fun _ ->
        Big.zero)
        q)
      p
  
  (** val coq_lxor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec coq_lxor p q =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Ndouble (coq_lxor p0 q0))
        (fun q0 ->
        coq_Nsucc_double (coq_lxor p0 q0))
        (fun _ -> (Big.double
        p0))
        q)
      (fun p0 ->
      Big.positive_case
        (fun q0 ->
        coq_Nsucc_double (coq_lxor p0 q0))
        (fun q0 ->
        coq_Ndouble (coq_lxor p0 q0))
        (fun _ -> (Big.doubleplusone
        p0))
        q)
      (fun _ ->
      Big.positive_case
        (fun q0 -> (Big.double
        q0))
        (fun q0 -> (Big.doubleplusone
        q0))
        (fun _ ->
        Big.zero)
        q)
      p
  
  (** val shiftl_nat : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftl_nat p n =
    nat_iter n (fun x -> Big.double x) p
  
  (** val shiftr_nat : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftr_nat p n =
    nat_iter n div2 p
  
  (** val shiftl : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftl p n =
    Big.n_case
      (fun _ ->
      p)
      (fun n0 ->
      iter n0 (fun x -> Big.double x) p)
      n
  
  (** val shiftr : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftr p n =
    Big.n_case
      (fun _ ->
      p)
      (fun n0 ->
      iter n0 div2 p)
      n
  
  (** val testbit_nat : Big.big_int -> Big.big_int -> bool **)
  
  let rec testbit_nat p n =
    Big.positive_case
      (fun p0 ->
      Big.nat_case
        (fun _ ->
        true)
        (fun n' ->
        testbit_nat p0 n')
        n)
      (fun p0 ->
      Big.nat_case
        (fun _ ->
        false)
        (fun n' ->
        testbit_nat p0 n')
        n)
      (fun _ ->
      Big.nat_case
        (fun _ ->
        true)
        (fun n0 ->
        false)
        n)
      p
  
  (** val testbit : Big.big_int -> Big.big_int -> bool **)
  
  let rec testbit p n =
    Big.positive_case
      (fun p0 ->
      Big.n_case
        (fun _ ->
        true)
        (fun n0 ->
        testbit p0 (pred_N n0))
        n)
      (fun p0 ->
      Big.n_case
        (fun _ ->
        false)
        (fun n0 ->
        testbit p0 (pred_N n0))
        n)
      (fun _ ->
      Big.n_case
        (fun _ ->
        true)
        (fun p0 ->
        false)
        n)
      p
  
  (** val iter_op : ('a1 -> 'a1 -> 'a1) -> Big.big_int -> 'a1 -> 'a1 **)
  
  let rec iter_op op p a =
    Big.positive_case
      (fun p0 ->
      op a (iter_op op p0 (op a a)))
      (fun p0 ->
      iter_op op p0 (op a a))
      (fun _ ->
      a)
      p
  
  (** val to_nat : Big.big_int -> Big.big_int **)
  
  let to_nat x =
    iter_op plus x (Big.succ Big.zero)
  
  (** val of_nat : Big.big_int -> Big.big_int **)
  
  let rec of_nat n =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun x ->
      Big.nat_case
        (fun _ ->
        Big.one)
        (fun n0 ->
        succ (of_nat x))
        x)
      n
  
  (** val of_succ_nat : Big.big_int -> Big.big_int **)
  
  let rec of_succ_nat n =
    Big.nat_case
      (fun _ ->
      Big.one)
      (fun x ->
      succ (of_succ_nat x))
      n
  
  (** val eq_dec : Big.big_int -> Big.big_int -> bool **)
  
  let rec eq_dec p y0 =
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        eq_dec p0 p1)
        (fun p1 ->
        false)
        (fun _ ->
        false)
        y0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        false)
        (fun p1 ->
        eq_dec p0 p1)
        (fun _ ->
        false)
        y0)
      (fun _ ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        false)
        (fun _ ->
        true)
        y0)
      p
  
  (** val peano_rect :
      'a1 -> (Big.big_int -> 'a1 -> 'a1) -> Big.big_int -> 'a1 **)
  
  let rec peano_rect a f p =
    let f2 =
      peano_rect (f Big.one a) (fun p0 x ->
        f (succ (Big.double p0)) (f (Big.double p0) x))
    in
    (Big.positive_case
       (fun q ->
       f (Big.double q) (f2 q))
       (fun q ->
       f2 q)
       (fun _ ->
       a)
       p)
  
  (** val peano_rec :
      'a1 -> (Big.big_int -> 'a1 -> 'a1) -> Big.big_int -> 'a1 **)
  
  let peano_rec =
    peano_rect
  
  type coq_PeanoView =
  | PeanoOne
  | PeanoSucc of Big.big_int * coq_PeanoView
  
  (** val coq_PeanoView_rect :
      'a1 -> (Big.big_int -> coq_PeanoView -> 'a1 -> 'a1) -> Big.big_int ->
      coq_PeanoView -> 'a1 **)
  
  let rec coq_PeanoView_rect f f0 p = function
  | PeanoOne -> f
  | PeanoSucc (p1, p2) -> f0 p1 p2 (coq_PeanoView_rect f f0 p1 p2)
  
  (** val coq_PeanoView_rec :
      'a1 -> (Big.big_int -> coq_PeanoView -> 'a1 -> 'a1) -> Big.big_int ->
      coq_PeanoView -> 'a1 **)
  
  let rec coq_PeanoView_rec f f0 p = function
  | PeanoOne -> f
  | PeanoSucc (p1, p2) -> f0 p1 p2 (coq_PeanoView_rec f f0 p1 p2)
  
  (** val peanoView_xO : Big.big_int -> coq_PeanoView -> coq_PeanoView **)
  
  let rec peanoView_xO p = function
  | PeanoOne -> PeanoSucc (Big.one, PeanoOne)
  | PeanoSucc (p0, q0) ->
    PeanoSucc ((succ (Big.double p0)), (PeanoSucc ((Big.double p0),
      (peanoView_xO p0 q0))))
  
  (** val peanoView_xI : Big.big_int -> coq_PeanoView -> coq_PeanoView **)
  
  let rec peanoView_xI p = function
  | PeanoOne -> PeanoSucc ((succ Big.one), (PeanoSucc (Big.one, PeanoOne)))
  | PeanoSucc (p0, q0) ->
    PeanoSucc ((succ (Big.doubleplusone p0)), (PeanoSucc ((Big.doubleplusone
      p0), (peanoView_xI p0 q0))))
  
  (** val peanoView : Big.big_int -> coq_PeanoView **)
  
  let rec peanoView p =
    Big.positive_case
      (fun p0 ->
      peanoView_xI p0 (peanoView p0))
      (fun p0 ->
      peanoView_xO p0 (peanoView p0))
      (fun _ ->
      PeanoOne)
      p
  
  (** val coq_PeanoView_iter :
      'a1 -> (Big.big_int -> 'a1 -> 'a1) -> Big.big_int -> coq_PeanoView ->
      'a1 **)
  
  let rec coq_PeanoView_iter a f p = function
  | PeanoOne -> a
  | PeanoSucc (p0, q0) -> f p0 (coq_PeanoView_iter a f p0 q0)
  
  (** val eqb_spec : Big.big_int -> Big.big_int -> reflect **)
  
  let eqb_spec x y =
    iff_reflect (eqb x y)
  
  (** val switch_Eq : comparison -> comparison -> comparison **)
  
  let switch_Eq c = function
  | Eq -> c
  | x -> x
  
  (** val mask2cmp : mask -> comparison **)
  
  let mask2cmp = function
  | IsNul -> Eq
  | IsPos p0 -> Gt
  | IsNeg -> Lt
  
  (** val leb_spec0 : Big.big_int -> Big.big_int -> reflect **)
  
  let leb_spec0 x y =
    iff_reflect (leb x y)
  
  (** val ltb_spec0 : Big.big_int -> Big.big_int -> reflect **)
  
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  
  module Private_Tac = 
   struct 
    
   end
  
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
    
    let max_case_strong n m compat hl hr =
      let c = compSpec2Type n m (compare n m) in
      (match c with
       | CompGtT -> compat n (max n m) __ (hl __)
       | _ -> compat m (max n m) __ (hr __))
    
    (** val max_case :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let max_case n m x x0 x1 =
      max_case_strong n m x (fun _ -> x0) (fun _ -> x1)
    
    (** val max_dec : Big.big_int -> Big.big_int -> bool **)
    
    let max_dec n m =
      max_case n m (fun x y _ h0 -> h0) true false
    
    (** val min_case_strong :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
    
    let min_case_strong n m compat hl hr =
      let c = compSpec2Type n m (compare n m) in
      (match c with
       | CompGtT -> compat m (min n m) __ (hr __)
       | _ -> compat n (min n m) __ (hl __))
    
    (** val min_case :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let min_case n m x x0 x1 =
      min_case_strong n m x (fun _ -> x0) (fun _ -> x1)
    
    (** val min_dec : Big.big_int -> Big.big_int -> bool **)
    
    let min_dec n m =
      min_case n m (fun x y _ h0 -> h0) true false
   end
  
  (** val max_case_strong :
      Big.big_int -> Big.big_int -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let max_case_strong n m x x0 =
    Private_Dec.max_case_strong n m (fun x1 y _ x2 -> x2) x x0
  
  (** val max_case : Big.big_int -> Big.big_int -> 'a1 -> 'a1 -> 'a1 **)
  
  let max_case n m x x0 =
    max_case_strong n m (fun _ -> x) (fun _ -> x0)
  
  (** val max_dec : Big.big_int -> Big.big_int -> bool **)
  
  let max_dec =
    Private_Dec.max_dec
  
  (** val min_case_strong :
      Big.big_int -> Big.big_int -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let min_case_strong n m x x0 =
    Private_Dec.min_case_strong n m (fun x1 y _ x2 -> x2) x x0
  
  (** val min_case : Big.big_int -> Big.big_int -> 'a1 -> 'a1 -> 'a1 **)
  
  let min_case n m x x0 =
    min_case_strong n m (fun _ -> x) (fun _ -> x0)
  
  (** val min_dec : Big.big_int -> Big.big_int -> bool **)
  
  let min_dec =
    Private_Dec.min_dec
 end

module N = 
 struct 
  type t = Big.big_int
  
  (** val zero : Big.big_int **)
  
  let zero =
    Big.zero
  
  (** val one : Big.big_int **)
  
  let one =
    Big.one
  
  (** val two : Big.big_int **)
  
  let two =
    (Big.double Big.one)
  
  (** val succ_double : Big.big_int -> Big.big_int **)
  
  let succ_double x =
    Big.n_case
      (fun _ ->
      Big.one)
      (fun p -> (Big.doubleplusone
      p))
      x
  
  (** val double : Big.big_int -> Big.big_int **)
  
  let double n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p -> (Big.double
      p))
      n
  
  (** val succ : Big.big_int -> Big.big_int **)
  
  let succ = Big.succ
  
  (** val pred : Big.big_int -> Big.big_int **)
  
  let pred = fun n -> Big.max Big.zero (Big.pred n)
  
  (** val succ_pos : Big.big_int -> Big.big_int **)
  
  let succ_pos n =
    Big.n_case
      (fun _ ->
      Big.one)
      (fun p ->
      Coq_Pos.succ p)
      n
  
  (** val add : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let add = Big.add
  
  (** val sub : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let sub = fun n m -> Big.max Big.zero (Big.sub n m)
  
  (** val mul : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let mul = Big.mult
  
  (** val compare : Big.big_int -> Big.big_int -> comparison **)
  
  let compare = Big.compare_case Eq Lt Gt
  
  (** val eqb : Big.big_int -> Big.big_int -> bool **)
  
  let rec eqb n m =
    Big.n_case
      (fun _ ->
      Big.n_case
        (fun _ ->
        true)
        (fun p ->
        false)
        m)
      (fun p ->
      Big.n_case
        (fun _ ->
        false)
        (fun q ->
        Coq_Pos.eqb p q)
        m)
      n
  
  (** val leb : Big.big_int -> Big.big_int -> bool **)
  
  let leb x y =
    match compare x y with
    | Gt -> false
    | _ -> true
  
  (** val ltb : Big.big_int -> Big.big_int -> bool **)
  
  let ltb x y =
    match compare x y with
    | Lt -> true
    | _ -> false
  
  (** val min : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let min = Big.min
  
  (** val max : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let max = Big.max
  
  (** val div2 : Big.big_int -> Big.big_int **)
  
  let div2 n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p0 ->
      Big.positive_case
        (fun p ->
        p)
        (fun p ->
        p)
        (fun _ ->
        Big.zero)
        p0)
      n
  
  (** val even : Big.big_int -> bool **)
  
  let even n =
    Big.n_case
      (fun _ ->
      true)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        true)
        (fun _ ->
        false)
        p)
      n
  
  (** val odd : Big.big_int -> bool **)
  
  let odd n =
    negb (even n)
  
  (** val pow : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let pow n p =
    Big.n_case
      (fun _ ->
      Big.one)
      (fun p0 ->
      Big.n_case
        (fun _ ->
        Big.zero)
        (fun q ->
        (Coq_Pos.pow q p0))
        n)
      p
  
  (** val square : Big.big_int -> Big.big_int **)
  
  let square n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Coq_Pos.square p))
      n
  
  (** val log2 : Big.big_int -> Big.big_int **)
  
  let log2 n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p0 ->
      Big.positive_case
        (fun p ->
        (Coq_Pos.size p))
        (fun p ->
        (Coq_Pos.size p))
        (fun _ ->
        Big.zero)
        p0)
      n
  
  (** val size : Big.big_int -> Big.big_int **)
  
  let size n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Coq_Pos.size p))
      n
  
  (** val size_nat : Big.big_int -> Big.big_int **)
  
  let size_nat n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Coq_Pos.size_nat p)
      n
  
  (** val pos_div_eucl :
      Big.big_int -> Big.big_int -> Big.big_int * Big.big_int **)
  
  let rec pos_div_eucl a b =
    Big.positive_case
      (fun a' ->
      let (q, r2) = pos_div_eucl a' b in
      let r' = succ_double r2 in
      if leb b r' then ((succ_double q), (sub r' b)) else ((double q), r'))
      (fun a' ->
      let (q, r2) = pos_div_eucl a' b in
      let r' = double r2 in
      if leb b r' then ((succ_double q), (sub r' b)) else ((double q), r'))
      (fun _ ->
      Big.n_case
        (fun _ -> (Big.zero,
        Big.one))
        (fun p ->
        Big.positive_case
          (fun p0 -> (Big.zero,
          Big.one))
          (fun p0 -> (Big.zero,
          Big.one))
          (fun _ -> (Big.one,
          Big.zero))
          p)
        b)
      a
  
  (** val div_eucl :
      Big.big_int -> Big.big_int -> Big.big_int * Big.big_int **)
  
  let div_eucl a b =
    Big.n_case
      (fun _ -> (Big.zero,
      Big.zero))
      (fun na ->
      Big.n_case
        (fun _ -> (Big.zero,
        a))
        (fun p ->
        pos_div_eucl na b)
        b)
      a
  
  (** val div : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let div = fun a b -> if Big.eq b Big.zero then Big.zero else Big.div a b
  
  (** val modulo : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let modulo = fun a b -> if Big.eq b Big.zero then Big.zero else Big.modulo a b
  
  (** val gcd : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let gcd a b =
    Big.n_case
      (fun _ ->
      b)
      (fun p ->
      Big.n_case
        (fun _ ->
        a)
        (fun q ->
        (Coq_Pos.gcd p q))
        b)
      a
  
  (** val ggcd :
      Big.big_int -> Big.big_int -> Big.big_int * (Big.big_int * Big.big_int) **)
  
  let ggcd a b =
    Big.n_case
      (fun _ -> (b, (Big.zero,
      Big.one)))
      (fun p ->
      Big.n_case
        (fun _ -> (a, (Big.one,
        Big.zero)))
        (fun q ->
        let (g, p0) = Coq_Pos.ggcd p q in let (aa, bb) = p0 in (g, (aa, bb)))
        b)
      a
  
  (** val sqrtrem : Big.big_int -> Big.big_int * Big.big_int **)
  
  let sqrtrem n =
    Big.n_case
      (fun _ -> (Big.zero,
      Big.zero))
      (fun p ->
      let (s, m) = Coq_Pos.sqrtrem p in
      (match m with
       | Coq_Pos.IsPos r2 -> (s, r2)
       | _ -> (s, Big.zero)))
      n
  
  (** val sqrt : Big.big_int -> Big.big_int **)
  
  let sqrt n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Coq_Pos.sqrt p))
      n
  
  (** val coq_lor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_lor n m =
    Big.n_case
      (fun _ ->
      m)
      (fun p ->
      Big.n_case
        (fun _ ->
        n)
        (fun q ->
        (Coq_Pos.coq_lor p q))
        m)
      n
  
  (** val coq_land : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_land n m =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Big.n_case
        (fun _ ->
        Big.zero)
        (fun q ->
        Coq_Pos.coq_land p q)
        m)
      n
  
  (** val ldiff : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec ldiff n m =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Big.n_case
        (fun _ ->
        n)
        (fun q ->
        Coq_Pos.ldiff p q)
        m)
      n
  
  (** val coq_lxor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_lxor n m =
    Big.n_case
      (fun _ ->
      m)
      (fun p ->
      Big.n_case
        (fun _ ->
        n)
        (fun q ->
        Coq_Pos.coq_lxor p q)
        m)
      n
  
  (** val shiftl_nat : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftl_nat a n =
    nat_iter n double a
  
  (** val shiftr_nat : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftr_nat a n =
    nat_iter n div2 a
  
  (** val shiftl : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftl a n =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun a0 ->
      (Coq_Pos.shiftl a0 n))
      a
  
  (** val shiftr : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftr a n =
    Big.n_case
      (fun _ ->
      a)
      (fun p ->
      Coq_Pos.iter p div2 a)
      n
  
  (** val testbit_nat : Big.big_int -> Big.big_int -> bool **)
  
  let testbit_nat a =
    Big.n_case
      (fun _ x ->
      false)
      (fun p ->
      Coq_Pos.testbit_nat p)
      a
  
  (** val testbit : Big.big_int -> Big.big_int -> bool **)
  
  let testbit a n =
    Big.n_case
      (fun _ ->
      false)
      (fun p ->
      Coq_Pos.testbit p n)
      a
  
  (** val to_nat : Big.big_int -> Big.big_int **)
  
  let to_nat a =
    Big.n_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Coq_Pos.to_nat p)
      a
  
  (** val of_nat : Big.big_int -> Big.big_int **)
  
  let of_nat n =
    Big.nat_case
      (fun _ ->
      Big.zero)
      (fun n' ->
      (Coq_Pos.of_succ_nat n'))
      n
  
  (** val iter : Big.big_int -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)
  
  let iter n f x =
    Big.n_case
      (fun _ ->
      x)
      (fun p ->
      Coq_Pos.iter p f x)
      n
  
  (** val eq_dec : Big.big_int -> Big.big_int -> bool **)
  
  let eq_dec n m =
    Big.n_case
      (fun _ ->
      Big.n_case
        (fun _ ->
        true)
        (fun p ->
        false)
        m)
      (fun x ->
      Big.n_case
        (fun _ ->
        false)
        (fun p0 ->
        Coq_Pos.eq_dec x p0)
        m)
      n
  
  (** val discr : Big.big_int -> Big.big_int option **)
  
  let discr n =
    Big.n_case
      (fun _ ->
      None)
      (fun p -> Some
      p)
      n
  
  (** val binary_rect :
      'a1 -> (Big.big_int -> 'a1 -> 'a1) -> (Big.big_int -> 'a1 -> 'a1) ->
      Big.big_int -> 'a1 **)
  
  let binary_rect f0 f2 fS2 n =
    let f2' = fun p -> f2 p in
    let fS2' = fun p -> fS2 p in
    (Big.n_case
       (fun _ ->
       f0)
       (fun p ->
       let rec f p0 =
         Big.positive_case
           (fun p1 ->
           fS2' p1 (f p1))
           (fun p1 ->
           f2' p1 (f p1))
           (fun _ ->
           fS2 Big.zero f0)
           p0
       in f p)
       n)
  
  (** val binary_rec :
      'a1 -> (Big.big_int -> 'a1 -> 'a1) -> (Big.big_int -> 'a1 -> 'a1) ->
      Big.big_int -> 'a1 **)
  
  let binary_rec =
    binary_rect
  
  (** val peano_rect :
      'a1 -> (Big.big_int -> 'a1 -> 'a1) -> Big.big_int -> 'a1 **)
  
  let peano_rect f0 f n =
    let f' = fun p -> f p in
    (Big.n_case
       (fun _ ->
       f0)
       (fun p ->
       Coq_Pos.peano_rect (f Big.zero f0) f' p)
       n)
  
  (** val peano_rec :
      'a1 -> (Big.big_int -> 'a1 -> 'a1) -> Big.big_int -> 'a1 **)
  
  let peano_rec =
    peano_rect
  
  (** val leb_spec0 : Big.big_int -> Big.big_int -> reflect **)
  
  let leb_spec0 x y =
    iff_reflect (leb x y)
  
  (** val ltb_spec0 : Big.big_int -> Big.big_int -> reflect **)
  
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  
  module Private_BootStrap = 
   struct 
    
   end
  
  (** val recursion :
      'a1 -> (Big.big_int -> 'a1 -> 'a1) -> Big.big_int -> 'a1 **)
  
  let recursion x =
    peano_rect x
  
  module Private_OrderTac = 
   struct 
    module IsTotal = 
     struct 
      
     end
    
    module Tac = 
     struct 
      
     end
   end
  
  module Private_NZPow = 
   struct 
    
   end
  
  module Private_NZSqrt = 
   struct 
    
   end
  
  (** val sqrt_up : Big.big_int -> Big.big_int **)
  
  let sqrt_up a =
    match compare Big.zero a with
    | Lt -> succ (sqrt (pred a))
    | _ -> Big.zero
  
  (** val log2_up : Big.big_int -> Big.big_int **)
  
  let log2_up a =
    match compare Big.one a with
    | Lt -> succ (log2 (pred a))
    | _ -> Big.zero
  
  module Private_NZDiv = 
   struct 
    
   end
  
  (** val lcm : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let lcm a b =
    mul a (div b (gcd a b))
  
  (** val eqb_spec : Big.big_int -> Big.big_int -> reflect **)
  
  let eqb_spec x y =
    iff_reflect (eqb x y)
  
  (** val b2n : bool -> Big.big_int **)
  
  let b2n = function
  | true -> Big.one
  | false -> Big.zero
  
  (** val setbit : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let setbit a n =
    coq_lor a (shiftl Big.one n)
  
  (** val clearbit : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let clearbit a n =
    ldiff a (shiftl Big.one n)
  
  (** val ones : Big.big_int -> Big.big_int **)
  
  let ones n =
    pred (shiftl Big.one n)
  
  (** val lnot : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let lnot a n =
    coq_lxor a (ones n)
  
  module Private_Tac = 
   struct 
    
   end
  
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
    
    let max_case_strong n m compat hl hr =
      let c = compSpec2Type n m (compare n m) in
      (match c with
       | CompGtT -> compat n (max n m) __ (hl __)
       | _ -> compat m (max n m) __ (hr __))
    
    (** val max_case :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let max_case n m x x0 x1 =
      max_case_strong n m x (fun _ -> x0) (fun _ -> x1)
    
    (** val max_dec : Big.big_int -> Big.big_int -> bool **)
    
    let max_dec n m =
      max_case n m (fun x y _ h0 -> h0) true false
    
    (** val min_case_strong :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
    
    let min_case_strong n m compat hl hr =
      let c = compSpec2Type n m (compare n m) in
      (match c with
       | CompGtT -> compat m (min n m) __ (hr __)
       | _ -> compat n (min n m) __ (hl __))
    
    (** val min_case :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let min_case n m x x0 x1 =
      min_case_strong n m x (fun _ -> x0) (fun _ -> x1)
    
    (** val min_dec : Big.big_int -> Big.big_int -> bool **)
    
    let min_dec n m =
      min_case n m (fun x y _ h0 -> h0) true false
   end
  
  (** val max_case_strong :
      Big.big_int -> Big.big_int -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let max_case_strong n m x x0 =
    Private_Dec.max_case_strong n m (fun x1 y _ x2 -> x2) x x0
  
  (** val max_case : Big.big_int -> Big.big_int -> 'a1 -> 'a1 -> 'a1 **)
  
  let max_case n m x x0 =
    max_case_strong n m (fun _ -> x) (fun _ -> x0)
  
  (** val max_dec : Big.big_int -> Big.big_int -> bool **)
  
  let max_dec =
    Private_Dec.max_dec
  
  (** val min_case_strong :
      Big.big_int -> Big.big_int -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let min_case_strong n m x x0 =
    Private_Dec.min_case_strong n m (fun x1 y _ x2 -> x2) x x0
  
  (** val min_case : Big.big_int -> Big.big_int -> 'a1 -> 'a1 -> 'a1 **)
  
  let min_case n m x x0 =
    min_case_strong n m (fun _ -> x) (fun _ -> x0)
  
  (** val min_dec : Big.big_int -> Big.big_int -> bool **)
  
  let min_dec =
    Private_Dec.min_dec
 end

(** val nth : Big.big_int -> 'a1 list -> 'a1 -> 'a1 **)

let rec nth n l default =
  Big.nat_case
    (fun _ ->
    match l with
    | [] -> default
    | x :: l' -> x)
    (fun m ->
    match l with
    | [] -> default
    | x :: t0 -> nth m t0 default)
    n

(** val nth_error : 'a1 list -> Big.big_int -> 'a1 exc **)

let rec nth_error l n =
  Big.nat_case
    (fun _ ->
    match l with
    | [] -> error
    | x :: l0 -> value x)
    (fun n0 ->
    match l with
    | [] -> error
    | a :: l0 -> nth_error l0 n0)
    n

(** val rev : 'a1 list -> 'a1 list **)

let rec rev = function
| [] -> []
| x :: l' -> app (rev l') (x :: [])

module Coq__1 = struct 
 (** val map : ('a1 -> 'a2) -> 'a1 list -> 'a2 list **)
 
 let rec map f = function
 | [] -> []
 | a :: t0 -> (f a) :: (map f t0)
end
let map = Coq__1.map


(** val fold_right : ('a2 -> 'a1 -> 'a1) -> 'a1 -> 'a2 list -> 'a1 **)

let rec fold_right f a0 = function
| [] -> a0
| b :: t0 -> f b (fold_right f a0 t0)

module Z = 
 struct 
  type t = Big.big_int
  
  (** val zero : Big.big_int **)
  
  let zero =
    Big.zero
  
  (** val one : Big.big_int **)
  
  let one =
    Big.one
  
  (** val two : Big.big_int **)
  
  let two =
    (Big.double Big.one)
  
  (** val double : Big.big_int -> Big.big_int **)
  
  let double x =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p -> (Big.double
      p))
      (fun p -> Big.opp (Big.double
      p))
      x
  
  (** val succ_double : Big.big_int -> Big.big_int **)
  
  let succ_double x =
    Big.z_case
      (fun _ ->
      Big.one)
      (fun p -> (Big.doubleplusone
      p))
      (fun p -> Big.opp
      (Coq_Pos.pred_double p))
      x
  
  (** val pred_double : Big.big_int -> Big.big_int **)
  
  let pred_double x =
    Big.z_case
      (fun _ -> Big.opp
      Big.one)
      (fun p ->
      (Coq_Pos.pred_double p))
      (fun p -> Big.opp (Big.doubleplusone
      p))
      x
  
  (** val pos_sub : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec pos_sub x y =
    Big.positive_case
      (fun p ->
      Big.positive_case
        (fun q ->
        double (pos_sub p q))
        (fun q ->
        succ_double (pos_sub p q))
        (fun _ -> (Big.double
        p))
        y)
      (fun p ->
      Big.positive_case
        (fun q ->
        pred_double (pos_sub p q))
        (fun q ->
        double (pos_sub p q))
        (fun _ ->
        (Coq_Pos.pred_double p))
        y)
      (fun _ ->
      Big.positive_case
        (fun q -> Big.opp (Big.double
        q))
        (fun q -> Big.opp
        (Coq_Pos.pred_double q))
        (fun _ ->
        Big.zero)
        y)
      x
  
  (** val add : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let add = Big.add
  
  (** val opp : Big.big_int -> Big.big_int **)
  
  let opp = Big.opp
  
  (** val succ : Big.big_int -> Big.big_int **)
  
  let succ = Big.succ
  
  (** val pred : Big.big_int -> Big.big_int **)
  
  let pred = Big.pred
  
  (** val sub : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let sub = Big.sub
  
  (** val mul : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let mul = Big.mult
  
  (** val pow_pos : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let pow_pos z n =
    Coq_Pos.iter n (mul z) Big.one
  
  (** val pow : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let pow x y =
    Big.z_case
      (fun _ ->
      Big.one)
      (fun p ->
      pow_pos x p)
      (fun p ->
      Big.zero)
      y
  
  (** val square : Big.big_int -> Big.big_int **)
  
  let square x =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Coq_Pos.square p))
      (fun p ->
      (Coq_Pos.square p))
      x
  
  (** val compare : Big.big_int -> Big.big_int -> comparison **)
  
  let compare = Big.compare_case Eq Lt Gt
  
  (** val sgn : Big.big_int -> Big.big_int **)
  
  let sgn z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Big.one)
      (fun p -> Big.opp
      Big.one)
      z
  
  (** val leb : Big.big_int -> Big.big_int -> bool **)
  
  let leb x y =
    match compare x y with
    | Gt -> false
    | _ -> true
  
  (** val ltb : Big.big_int -> Big.big_int -> bool **)
  
  let ltb x y =
    match compare x y with
    | Lt -> true
    | _ -> false
  
  (** val geb : Big.big_int -> Big.big_int -> bool **)
  
  let geb x y =
    match compare x y with
    | Lt -> false
    | _ -> true
  
  (** val gtb : Big.big_int -> Big.big_int -> bool **)
  
  let gtb x y =
    match compare x y with
    | Gt -> true
    | _ -> false
  
  (** val eqb : Big.big_int -> Big.big_int -> bool **)
  
  let rec eqb x y =
    Big.z_case
      (fun _ ->
      Big.z_case
        (fun _ ->
        true)
        (fun p ->
        false)
        (fun p ->
        false)
        y)
      (fun p ->
      Big.z_case
        (fun _ ->
        false)
        (fun q ->
        Coq_Pos.eqb p q)
        (fun p0 ->
        false)
        y)
      (fun p ->
      Big.z_case
        (fun _ ->
        false)
        (fun p0 ->
        false)
        (fun q ->
        Coq_Pos.eqb p q)
        y)
      x
  
  (** val max : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let max = Big.max
  
  (** val min : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let min = Big.min
  
  (** val abs : Big.big_int -> Big.big_int **)
  
  let abs = Big.abs
  
  (** val abs_nat : Big.big_int -> Big.big_int **)
  
  let abs_nat z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Coq_Pos.to_nat p)
      (fun p ->
      Coq_Pos.to_nat p)
      z
  
  (** val abs_N : Big.big_int -> Big.big_int **)
  
  let abs_N = Big.abs
  
  (** val to_nat : Big.big_int -> Big.big_int **)
  
  let to_nat z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Coq_Pos.to_nat p)
      (fun p ->
      Big.zero)
      z
  
  (** val to_N : Big.big_int -> Big.big_int **)
  
  let to_N z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      p)
      (fun p ->
      Big.zero)
      z
  
  (** val of_nat : Big.big_int -> Big.big_int **)
  
  let of_nat n =
    Big.nat_case
      (fun _ ->
      Big.zero)
      (fun n0 ->
      (Coq_Pos.of_succ_nat n0))
      n
  
  (** val of_N : Big.big_int -> Big.big_int **)
  
  let of_N = fun p -> p
  
  (** val to_pos : Big.big_int -> Big.big_int **)
  
  let to_pos z =
    Big.z_case
      (fun _ ->
      Big.one)
      (fun p ->
      p)
      (fun p ->
      Big.one)
      z
  
  (** val iter : Big.big_int -> ('a1 -> 'a1) -> 'a1 -> 'a1 **)
  
  let iter n f x =
    Big.z_case
      (fun _ ->
      x)
      (fun p ->
      Coq_Pos.iter p f x)
      (fun p ->
      x)
      n
  
  (** val pos_div_eucl :
      Big.big_int -> Big.big_int -> Big.big_int * Big.big_int **)
  
  let rec pos_div_eucl a b =
    Big.positive_case
      (fun a' ->
      let (q, r2) = pos_div_eucl a' b in
      let r' = add (mul (Big.double Big.one) r2) Big.one in
      if ltb r' b
      then ((mul (Big.double Big.one) q), r')
      else ((add (mul (Big.double Big.one) q) Big.one), (sub r' b)))
      (fun a' ->
      let (q, r2) = pos_div_eucl a' b in
      let r' = mul (Big.double Big.one) r2 in
      if ltb r' b
      then ((mul (Big.double Big.one) q), r')
      else ((add (mul (Big.double Big.one) q) Big.one), (sub r' b)))
      (fun _ ->
      if leb (Big.double Big.one) b
      then (Big.zero, Big.one)
      else (Big.one, Big.zero))
      a
  
  (** val div_eucl :
      Big.big_int -> Big.big_int -> Big.big_int * Big.big_int **)
  
  let div_eucl a b =
    Big.z_case
      (fun _ -> (Big.zero,
      Big.zero))
      (fun a' ->
      Big.z_case
        (fun _ -> (Big.zero,
        Big.zero))
        (fun p ->
        pos_div_eucl a' b)
        (fun b' ->
        let (q, r2) = pos_div_eucl a' b' in
        (Big.z_case
           (fun _ -> ((opp q),
           Big.zero))
           (fun p -> ((opp (add q Big.one)),
           (add b r2)))
           (fun p -> ((opp (add q Big.one)),
           (add b r2)))
           r2))
        b)
      (fun a' ->
      Big.z_case
        (fun _ -> (Big.zero,
        Big.zero))
        (fun p ->
        let (q, r2) = pos_div_eucl a' b in
        (Big.z_case
           (fun _ -> ((opp q),
           Big.zero))
           (fun p0 -> ((opp (add q Big.one)),
           (sub b r2)))
           (fun p0 -> ((opp (add q Big.one)),
           (sub b r2)))
           r2))
        (fun b' ->
        let (q, r2) = pos_div_eucl a' b' in (q, (opp r2)))
        b)
      a
  
  (** val div : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let div a b =
    let (q, x) = div_eucl a b in q
  
  (** val modulo : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let modulo a b =
    let (x, r2) = div_eucl a b in r2
  
  (** val quotrem :
      Big.big_int -> Big.big_int -> Big.big_int * Big.big_int **)
  
  let quotrem a b =
    Big.z_case
      (fun _ -> (Big.zero,
      Big.zero))
      (fun a0 ->
      Big.z_case
        (fun _ -> (Big.zero,
        a))
        (fun b0 ->
        let (q, r2) = N.pos_div_eucl a0 b0 in ((of_N q), (of_N r2)))
        (fun b0 ->
        let (q, r2) = N.pos_div_eucl a0 b0 in ((opp (of_N q)), (of_N r2)))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ -> (Big.zero,
        a))
        (fun b0 ->
        let (q, r2) = N.pos_div_eucl a0 b0 in
        ((opp (of_N q)), (opp (of_N r2))))
        (fun b0 ->
        let (q, r2) = N.pos_div_eucl a0 b0 in ((of_N q), (opp (of_N r2))))
        b)
      a
  
  (** val quot : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let quot a b =
    fst (quotrem a b)
  
  (** val rem : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rem a b =
    snd (quotrem a b)
  
  (** val even : Big.big_int -> bool **)
  
  let even z =
    Big.z_case
      (fun _ ->
      true)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        true)
        (fun _ ->
        false)
        p)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        false)
        (fun p0 ->
        true)
        (fun _ ->
        false)
        p)
      z
  
  (** val odd : Big.big_int -> bool **)
  
  let odd z =
    Big.z_case
      (fun _ ->
      false)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        true)
        (fun p0 ->
        false)
        (fun _ ->
        true)
        p)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        true)
        (fun p0 ->
        false)
        (fun _ ->
        true)
        p)
      z
  
  (** val div2 : Big.big_int -> Big.big_int **)
  
  let div2 z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        (Coq_Pos.div2 p))
        (fun p0 ->
        (Coq_Pos.div2 p))
        (fun _ ->
        Big.zero)
        p)
      (fun p -> Big.opp
      (Coq_Pos.div2_up p))
      z
  
  (** val quot2 : Big.big_int -> Big.big_int **)
  
  let quot2 z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      Big.positive_case
        (fun p0 ->
        (Coq_Pos.div2 p))
        (fun p0 ->
        (Coq_Pos.div2 p))
        (fun _ ->
        Big.zero)
        p)
      (fun p ->
      Big.positive_case
        (fun p0 -> Big.opp
        (Coq_Pos.div2 p))
        (fun p0 -> Big.opp
        (Coq_Pos.div2 p))
        (fun _ ->
        Big.zero)
        p)
      z
  
  (** val log2 : Big.big_int -> Big.big_int **)
  
  let log2 z =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p0 ->
      Big.positive_case
        (fun p ->
        (Coq_Pos.size p))
        (fun p ->
        (Coq_Pos.size p))
        (fun _ ->
        Big.zero)
        p0)
      (fun p ->
      Big.zero)
      z
  
  (** val sqrtrem : Big.big_int -> Big.big_int * Big.big_int **)
  
  let sqrtrem n =
    Big.z_case
      (fun _ -> (Big.zero,
      Big.zero))
      (fun p ->
      let (s, m) = Coq_Pos.sqrtrem p in
      (match m with
       | Coq_Pos.IsPos r2 -> (s, r2)
       | _ -> (s, Big.zero)))
      (fun p -> (Big.zero,
      Big.zero))
      n
  
  (** val sqrt : Big.big_int -> Big.big_int **)
  
  let sqrt n =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun p ->
      (Coq_Pos.sqrt p))
      (fun p ->
      Big.zero)
      n
  
  (** val gcd : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let gcd a b =
    Big.z_case
      (fun _ ->
      abs b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        abs a)
        (fun b0 ->
        (Coq_Pos.gcd a0 b0))
        (fun b0 ->
        (Coq_Pos.gcd a0 b0))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        abs a)
        (fun b0 ->
        (Coq_Pos.gcd a0 b0))
        (fun b0 ->
        (Coq_Pos.gcd a0 b0))
        b)
      a
  
  (** val ggcd :
      Big.big_int -> Big.big_int -> Big.big_int * (Big.big_int * Big.big_int) **)
  
  let ggcd a b =
    Big.z_case
      (fun _ -> ((abs b), (Big.zero,
      (sgn b))))
      (fun a0 ->
      Big.z_case
        (fun _ -> ((abs a), ((sgn a),
        Big.zero)))
        (fun b0 ->
        let (g, p) = Coq_Pos.ggcd a0 b0 in let (aa, bb) = p in (g, (aa, bb)))
        (fun b0 ->
        let (g, p) = Coq_Pos.ggcd a0 b0 in
        let (aa, bb) = p in (g, (aa, (Big.opp bb))))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ -> ((abs a), ((sgn a),
        Big.zero)))
        (fun b0 ->
        let (g, p) = Coq_Pos.ggcd a0 b0 in
        let (aa, bb) = p in (g, ((Big.opp aa), bb)))
        (fun b0 ->
        let (g, p) = Coq_Pos.ggcd a0 b0 in
        let (aa, bb) = p in (g, ((Big.opp aa), (Big.opp bb))))
        b)
      a
  
  (** val testbit : Big.big_int -> Big.big_int -> bool **)
  
  let testbit a n =
    Big.z_case
      (fun _ ->
      odd a)
      (fun p ->
      Big.z_case
        (fun _ ->
        false)
        (fun a0 ->
        Coq_Pos.testbit a0 p)
        (fun a0 ->
        negb (N.testbit (Coq_Pos.pred_N a0) p))
        a)
      (fun p ->
      false)
      n
  
  (** val shiftl : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftl a n =
    Big.z_case
      (fun _ ->
      a)
      (fun p ->
      Coq_Pos.iter p (mul (Big.double Big.one)) a)
      (fun p ->
      Coq_Pos.iter p div2 a)
      n
  
  (** val shiftr : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let shiftr a n =
    shiftl a (opp n)
  
  (** val coq_lor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_lor a b =
    Big.z_case
      (fun _ ->
      b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 ->
        (Coq_Pos.coq_lor a0 b0))
        (fun b0 -> Big.opp
        (N.succ_pos (N.ldiff (Coq_Pos.pred_N b0) a0)))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 -> Big.opp
        (N.succ_pos (N.ldiff (Coq_Pos.pred_N a0) b0)))
        (fun b0 -> Big.opp
        (N.succ_pos (N.coq_land (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
        b)
      a
  
  (** val coq_land : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_land a b =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        Big.zero)
        (fun b0 ->
        of_N (Coq_Pos.coq_land a0 b0))
        (fun b0 ->
        of_N (N.ldiff a0 (Coq_Pos.pred_N b0)))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        Big.zero)
        (fun b0 ->
        of_N (N.ldiff b0 (Coq_Pos.pred_N a0)))
        (fun b0 -> Big.opp
        (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0))))
        b)
      a
  
  (** val ldiff : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let ldiff a b =
    Big.z_case
      (fun _ ->
      Big.zero)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 ->
        of_N (Coq_Pos.ldiff a0 b0))
        (fun b0 ->
        of_N (N.coq_land a0 (Coq_Pos.pred_N b0)))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 -> Big.opp
        (N.succ_pos (N.coq_lor (Coq_Pos.pred_N a0) b0)))
        (fun b0 ->
        of_N (N.ldiff (Coq_Pos.pred_N b0) (Coq_Pos.pred_N a0)))
        b)
      a
  
  (** val coq_lxor : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_lxor a b =
    Big.z_case
      (fun _ ->
      b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 ->
        of_N (Coq_Pos.coq_lxor a0 b0))
        (fun b0 -> Big.opp
        (N.succ_pos (N.coq_lxor a0 (Coq_Pos.pred_N b0))))
        b)
      (fun a0 ->
      Big.z_case
        (fun _ ->
        a)
        (fun b0 -> Big.opp
        (N.succ_pos (N.coq_lxor (Coq_Pos.pred_N a0) b0)))
        (fun b0 ->
        of_N (N.coq_lxor (Coq_Pos.pred_N a0) (Coq_Pos.pred_N b0)))
        b)
      a
  
  (** val eq_dec : Big.big_int -> Big.big_int -> bool **)
  
  let eq_dec x y =
    Big.z_case
      (fun _ ->
      Big.z_case
        (fun _ ->
        true)
        (fun p ->
        false)
        (fun p ->
        false)
        y)
      (fun x0 ->
      Big.z_case
        (fun _ ->
        false)
        (fun p0 ->
        Coq_Pos.eq_dec x0 p0)
        (fun p0 ->
        false)
        y)
      (fun x0 ->
      Big.z_case
        (fun _ ->
        false)
        (fun p0 ->
        false)
        (fun p0 ->
        Coq_Pos.eq_dec x0 p0)
        y)
      x
  
  module Private_BootStrap = 
   struct 
    
   end
  
  (** val leb_spec0 : Big.big_int -> Big.big_int -> reflect **)
  
  let leb_spec0 x y =
    iff_reflect (leb x y)
  
  (** val ltb_spec0 : Big.big_int -> Big.big_int -> reflect **)
  
  let ltb_spec0 x y =
    iff_reflect (ltb x y)
  
  module Private_OrderTac = 
   struct 
    module IsTotal = 
     struct 
      
     end
    
    module Tac = 
     struct 
      
     end
   end
  
  (** val sqrt_up : Big.big_int -> Big.big_int **)
  
  let sqrt_up a =
    match compare Big.zero a with
    | Lt -> succ (sqrt (pred a))
    | _ -> Big.zero
  
  (** val log2_up : Big.big_int -> Big.big_int **)
  
  let log2_up a =
    match compare Big.one a with
    | Lt -> succ (log2 (pred a))
    | _ -> Big.zero
  
  module Private_NZDiv = 
   struct 
    
   end
  
  module Private_Div = 
   struct 
    module Quot2Div = 
     struct 
      (** val div : Big.big_int -> Big.big_int -> Big.big_int **)
      
      let div =
        quot
      
      (** val modulo : Big.big_int -> Big.big_int -> Big.big_int **)
      
      let modulo =
        rem
     end
    
    module NZQuot = 
     struct 
      
     end
   end
  
  (** val lcm : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let lcm a b =
    abs (mul a (div b (gcd a b)))
  
  (** val eqb_spec : Big.big_int -> Big.big_int -> reflect **)
  
  let eqb_spec x y =
    iff_reflect (eqb x y)
  
  (** val b2z : bool -> Big.big_int **)
  
  let b2z = function
  | true -> Big.one
  | false -> Big.zero
  
  (** val setbit : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let setbit a n =
    coq_lor a (shiftl Big.one n)
  
  (** val clearbit : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let clearbit a n =
    ldiff a (shiftl Big.one n)
  
  (** val lnot : Big.big_int -> Big.big_int **)
  
  let lnot a =
    pred (opp a)
  
  (** val ones : Big.big_int -> Big.big_int **)
  
  let ones n =
    pred (shiftl Big.one n)
  
  module Private_Tac = 
   struct 
    
   end
  
  module Private_Dec = 
   struct 
    (** val max_case_strong :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
    
    let max_case_strong n m compat hl hr =
      let c = compSpec2Type n m (compare n m) in
      (match c with
       | CompGtT -> compat n (max n m) __ (hl __)
       | _ -> compat m (max n m) __ (hr __))
    
    (** val max_case :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let max_case n m x x0 x1 =
      max_case_strong n m x (fun _ -> x0) (fun _ -> x1)
    
    (** val max_dec : Big.big_int -> Big.big_int -> bool **)
    
    let max_dec n m =
      max_case n m (fun x y _ h0 -> h0) true false
    
    (** val min_case_strong :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
    
    let min_case_strong n m compat hl hr =
      let c = compSpec2Type n m (compare n m) in
      (match c with
       | CompGtT -> compat m (min n m) __ (hr __)
       | _ -> compat n (min n m) __ (hl __))
    
    (** val min_case :
        Big.big_int -> Big.big_int -> (Big.big_int -> Big.big_int -> __ ->
        'a1 -> 'a1) -> 'a1 -> 'a1 -> 'a1 **)
    
    let min_case n m x x0 x1 =
      min_case_strong n m x (fun _ -> x0) (fun _ -> x1)
    
    (** val min_dec : Big.big_int -> Big.big_int -> bool **)
    
    let min_dec n m =
      min_case n m (fun x y _ h0 -> h0) true false
   end
  
  (** val max_case_strong :
      Big.big_int -> Big.big_int -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let max_case_strong n m x x0 =
    Private_Dec.max_case_strong n m (fun x1 y _ x2 -> x2) x x0
  
  (** val max_case : Big.big_int -> Big.big_int -> 'a1 -> 'a1 -> 'a1 **)
  
  let max_case n m x x0 =
    max_case_strong n m (fun _ -> x) (fun _ -> x0)
  
  (** val max_dec : Big.big_int -> Big.big_int -> bool **)
  
  let max_dec =
    Private_Dec.max_dec
  
  (** val min_case_strong :
      Big.big_int -> Big.big_int -> (__ -> 'a1) -> (__ -> 'a1) -> 'a1 **)
  
  let min_case_strong n m x x0 =
    Private_Dec.min_case_strong n m (fun x1 y _ x2 -> x2) x x0
  
  (** val min_case : Big.big_int -> Big.big_int -> 'a1 -> 'a1 -> 'a1 **)
  
  let min_case n m x x0 =
    min_case_strong n m (fun _ -> x) (fun _ -> x0)
  
  (** val min_dec : Big.big_int -> Big.big_int -> bool **)
  
  let min_dec =
    Private_Dec.min_dec
 end

(** val z_lt_dec : Big.big_int -> Big.big_int -> bool **)

let z_lt_dec x y =
  match Z.compare x y with
  | Lt -> true
  | _ -> false

(** val z_le_dec : Big.big_int -> Big.big_int -> bool **)

let z_le_dec x y =
  match Z.compare x y with
  | Gt -> false
  | _ -> true

(** val z_lt_ge_dec : Big.big_int -> Big.big_int -> bool **)

let z_lt_ge_dec x y =
  z_lt_dec x y

(** val z_le_gt_dec : Big.big_int -> Big.big_int -> bool **)

let z_le_gt_dec x y =
  z_le_dec x y

(** val zeq_bool : Big.big_int -> Big.big_int -> bool **)

let zeq_bool x y =
  match Z.compare x y with
  | Eq -> true
  | _ -> false

(** val append : char list -> char list -> char list **)

let rec append s1 s2 =
  match s1 with
  | [] -> s2
  | c::s1' -> c::(append s1' s2)

(** val length0 : char list -> Big.big_int **)

let rec length0 = function
| [] -> Big.zero
| c::s' -> Big.succ (length0 s')

(** val shift_nat : Big.big_int -> Big.big_int -> Big.big_int **)

let shift_nat n z =
  nat_iter n (fun x -> Big.double x) z

(** val shift_pos : Big.big_int -> Big.big_int -> Big.big_int **)

let shift_pos n z =
  Coq_Pos.iter n (fun x -> Big.double x) z

(** val two_power_nat : Big.big_int -> Big.big_int **)

let two_power_nat n =
  (shift_nat n Big.one)

(** val two_power_pos : Big.big_int -> Big.big_int **)

let two_power_pos x =
  (shift_pos x Big.one)

(** val two_p : Big.big_int -> Big.big_int **)

let two_p x =
  Big.z_case
    (fun _ ->
    Big.one)
    (fun y ->
    two_power_pos y)
    (fun y ->
    Big.zero)
    x

(** val peq : Big.big_int -> Big.big_int -> bool **)

let peq x y =
  match Coq_Pos.compare_cont x y Eq with
  | Eq -> true
  | _ -> false

(** val zeq : Big.big_int -> Big.big_int -> bool **)

let zeq =
  Z.eq_dec

(** val zlt : Big.big_int -> Big.big_int -> bool **)

let zlt =
  z_lt_ge_dec

(** val zle : Big.big_int -> Big.big_int -> bool **)

let zle =
  z_le_gt_dec

(** val option_map : ('a1 -> 'a2) -> 'a1 option -> 'a2 option **)

let option_map f = function
| Some y -> Some (f y)
| None -> None

(** val proj_sumbool : bool -> bool **)

let proj_sumbool = function
| true -> true
| false -> false

module Word = 
 struct 
  (** val wordsize : Big.big_int -> Big.big_int **)
  
  let wordsize wordsize_minus_one =
    Big.succ wordsize_minus_one
  
  (** val modulus : Big.big_int -> Big.big_int **)
  
  let modulus wordsize_minus_one =
    two_power_nat (wordsize wordsize_minus_one)
  
  (** val half_modulus : Big.big_int -> Big.big_int **)
  
  let half_modulus wordsize_minus_one =
    Z.div (modulus wordsize_minus_one) (Big.double Big.one)
  
  type comparison =
  | Ceq
  | Cne
  | Clt
  | Cle
  | Cgt
  | Cge
  
  (** val comparison_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> comparison -> 'a1 **)
  
  let comparison_rect f f0 f1 f2 f3 f4 = function
  | Ceq -> f
  | Cne -> f0
  | Clt -> f1
  | Cle -> f2
  | Cgt -> f3
  | Cge -> f4
  
  (** val comparison_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> comparison -> 'a1 **)
  
  let comparison_rec f f0 f1 f2 f3 f4 = function
  | Ceq -> f
  | Cne -> f0
  | Clt -> f1
  | Cle -> f2
  | Cgt -> f3
  | Cge -> f4
  
  (** val negate_comparison : comparison -> comparison **)
  
  let negate_comparison = function
  | Ceq -> Cne
  | Cne -> Ceq
  | Clt -> Cge
  | Cle -> Cgt
  | Cgt -> Cle
  | Cge -> Clt
  
  (** val swap_comparison : comparison -> comparison **)
  
  let swap_comparison = function
  | Clt -> Cgt
  | Cle -> Cge
  | Cgt -> Clt
  | Cge -> Cle
  | x -> x
  
  type int =
    Big.big_int
    (* singleton inductive, whose constructor was mkint *)
  
  (** val int_rect :
      Big.big_int -> (Big.big_int -> __ -> 'a1) -> int -> 'a1 **)
  
  let int_rect wordsize_minus_one f i =
    f i __
  
  (** val int_rec :
      Big.big_int -> (Big.big_int -> __ -> 'a1) -> int -> 'a1 **)
  
  let int_rec wordsize_minus_one f i =
    f i __
  
  (** val intval : Big.big_int -> int -> Big.big_int **)
  
  let intval wordsize_minus_one i =
    i
  
  (** val max_unsigned : Big.big_int -> Big.big_int **)
  
  let max_unsigned wordsize_minus_one =
    Z.sub (modulus wordsize_minus_one) Big.one
  
  (** val max_signed : Big.big_int -> Big.big_int **)
  
  let max_signed wordsize_minus_one =
    Z.sub (half_modulus wordsize_minus_one) Big.one
  
  (** val min_signed : Big.big_int -> Big.big_int **)
  
  let min_signed wordsize_minus_one =
    Z.opp (half_modulus wordsize_minus_one)
  
  (** val unsigned : Big.big_int -> int -> Big.big_int **)
  
  let unsigned wordsize_minus_one n =
    intval wordsize_minus_one n
  
  (** val signed : Big.big_int -> int -> Big.big_int **)
  
  let signed wordsize_minus_one n =
    if zlt (unsigned wordsize_minus_one n) (half_modulus wordsize_minus_one)
    then unsigned wordsize_minus_one n
    else Z.sub (unsigned wordsize_minus_one n) (modulus wordsize_minus_one)
  
  (** val repr : Big.big_int -> Big.big_int -> int **)
  
  let repr wordsize_minus_one x =
    Z.modulo x (modulus wordsize_minus_one)
  
  (** val zero : Big.big_int -> int **)
  
  let zero wordsize_minus_one =
    repr wordsize_minus_one Big.zero
  
  (** val one : Big.big_int -> int **)
  
  let one wordsize_minus_one =
    repr wordsize_minus_one Big.one
  
  (** val mone : Big.big_int -> int **)
  
  let mone wordsize_minus_one =
    repr wordsize_minus_one (Big.opp Big.one)
  
  (** val eq_dec : Big.big_int -> int -> int -> bool **)
  
  let eq_dec wordsize_minus_one x y =
    zeq x y
  
  (** val eq : Big.big_int -> int -> int -> bool **)
  
  let eq wordsize_minus_one x y =
    if zeq (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y)
    then true
    else false
  
  (** val lt : Big.big_int -> int -> int -> bool **)
  
  let lt wordsize_minus_one x y =
    if zlt (signed wordsize_minus_one x) (signed wordsize_minus_one y)
    then true
    else false
  
  (** val ltu : Big.big_int -> int -> int -> bool **)
  
  let ltu wordsize_minus_one x y =
    if zlt (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y)
    then true
    else false
  
  (** val lequ : Big.big_int -> int -> int -> bool **)
  
  let lequ wordsize_minus_one x y =
    (||) (ltu wordsize_minus_one x y) (eq wordsize_minus_one x y)
  
  (** val neg : Big.big_int -> int -> int **)
  
  let neg wordsize_minus_one x =
    repr wordsize_minus_one (Z.opp (unsigned wordsize_minus_one x))
  
  (** val zero_ext : Big.big_int -> Big.big_int -> int -> int **)
  
  let zero_ext wordsize_minus_one n x =
    repr wordsize_minus_one
      (Z.modulo (unsigned wordsize_minus_one x) (two_p n))
  
  (** val sign_ext : Big.big_int -> Big.big_int -> int -> int **)
  
  let sign_ext wordsize_minus_one n x =
    repr wordsize_minus_one
      (let p = two_p n in
       let y = Z.modulo (unsigned wordsize_minus_one x) p in
       if zlt y (two_p (Z.sub n Big.one)) then y else Z.sub y p)
  
  (** val add : Big.big_int -> int -> int -> int **)
  
  let add wordsize_minus_one x y =
    repr wordsize_minus_one
      (Z.add (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y))
  
  (** val sub : Big.big_int -> int -> int -> int **)
  
  let sub wordsize_minus_one x y =
    repr wordsize_minus_one
      (Z.sub (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y))
  
  (** val mul : Big.big_int -> int -> int -> int **)
  
  let mul wordsize_minus_one x y =
    repr wordsize_minus_one
      (Z.mul (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y))
  
  (** val coq_Zdiv_round : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_Zdiv_round x y =
    if zlt x Big.zero
    then if zlt y Big.zero
         then Z.div (Z.opp x) (Z.opp y)
         else Z.opp (Z.div (Z.opp x) y)
    else if zlt y Big.zero then Z.opp (Z.div x (Z.opp y)) else Z.div x y
  
  (** val coq_Zmod_round : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let coq_Zmod_round x y =
    Z.sub x (Z.mul (coq_Zdiv_round x y) y)
  
  (** val divs : Big.big_int -> int -> int -> int **)
  
  let divs wordsize_minus_one x y =
    repr wordsize_minus_one
      (coq_Zdiv_round (signed wordsize_minus_one x)
        (signed wordsize_minus_one y))
  
  (** val mods : Big.big_int -> int -> int -> int **)
  
  let mods wordsize_minus_one x y =
    repr wordsize_minus_one
      (coq_Zmod_round (signed wordsize_minus_one x)
        (signed wordsize_minus_one y))
  
  (** val divu : Big.big_int -> int -> int -> int **)
  
  let divu wordsize_minus_one x y =
    repr wordsize_minus_one
      (Z.div (unsigned wordsize_minus_one x) (unsigned wordsize_minus_one y))
  
  (** val modu : Big.big_int -> int -> int -> int **)
  
  let modu wordsize_minus_one x y =
    repr wordsize_minus_one
      (Z.modulo (unsigned wordsize_minus_one x)
        (unsigned wordsize_minus_one y))
  
  (** val bool_to_int : Big.big_int -> bool -> int **)
  
  let bool_to_int wordsize_minus_one = function
  | true -> one wordsize_minus_one
  | false -> zero wordsize_minus_one
  
  (** val unsigned_overflow :
      Big.big_int -> Big.big_int -> Big.big_int -> bool **)
  
  let unsigned_overflow wordsize_minus_one o1 o2 =
    let res = Z.add o1 o2 in
    if zlt res (modulus wordsize_minus_one) then false else true
  
  (** val unsigned_overflow_with_carry :
      Big.big_int -> Big.big_int -> Big.big_int -> bool -> bool **)
  
  let unsigned_overflow_with_carry wordsize_minus_one o1 o2 carry =
    let c = bool_to_int wordsize_minus_one carry in
    let res = Z.add (Z.add o1 o2) (unsigned wordsize_minus_one c) in
    if zle res (max_unsigned wordsize_minus_one) then false else true
  
  (** val signed_overflow :
      Big.big_int -> Big.big_int -> Big.big_int -> bool **)
  
  let signed_overflow wordsize_minus_one o1 o2 =
    let res = Z.add o1 o2 in
    if (&&) (proj_sumbool (zle res (max_signed wordsize_minus_one)))
         (proj_sumbool (zle (min_signed wordsize_minus_one) res))
    then false
    else true
  
  (** val signed_overflow_with_carry :
      Big.big_int -> Big.big_int -> Big.big_int -> bool -> bool **)
  
  let signed_overflow_with_carry wordsize_minus_one o1 o2 carry =
    let c = bool_to_int wordsize_minus_one carry in
    let res = Z.add (Z.add o1 o2) (signed wordsize_minus_one c) in
    if (&&) (proj_sumbool (zle res (max_signed wordsize_minus_one)))
         (proj_sumbool (zle (min_signed wordsize_minus_one) res))
    then false
    else true
  
  (** val signed_overflow_with_borrow :
      Big.big_int -> Big.big_int -> Big.big_int -> bool -> bool **)
  
  let signed_overflow_with_borrow wordsize_minus_one o1 o2 borrow =
    let b = bool_to_int wordsize_minus_one borrow in
    let res = Z.sub (Z.add o1 o2) (signed wordsize_minus_one b) in
    if (&&) (proj_sumbool (zle res (max_signed wordsize_minus_one)))
         (proj_sumbool (zle (min_signed wordsize_minus_one) res))
    then false
    else true
  
  (** val is_zero : Big.big_int -> int -> bool **)
  
  let is_zero wordsize_minus_one i =
    eq wordsize_minus_one i (zero wordsize_minus_one)
  
  (** val is_signed : Big.big_int -> int -> bool **)
  
  let is_signed wordsize_minus_one i =
    lt wordsize_minus_one i (zero wordsize_minus_one)
  
  (** val coq_Z_shift_add : bool -> Big.big_int -> Big.big_int **)
  
  let coq_Z_shift_add b x =
    if b
    then Z.add (Z.mul (Big.double Big.one) x) Big.one
    else Z.mul (Big.double Big.one) x
  
  (** val coq_Z_bin_decomp : Big.big_int -> bool * Big.big_int **)
  
  let coq_Z_bin_decomp x =
    Big.z_case
      (fun _ -> (false,
      Big.zero))
      (fun p ->
      Big.positive_case
        (fun q -> (true,
        q))
        (fun q -> (false,
        q))
        (fun _ -> (true,
        Big.zero))
        p)
      (fun p ->
      Big.positive_case
        (fun q -> (true,
        (Z.sub (Big.opp q) Big.one)))
        (fun q -> (false, (Big.opp
        q)))
        (fun _ -> (true, (Big.opp
        Big.one)))
        p)
      x
  
  (** val bits_of_Z : Big.big_int -> Big.big_int -> Big.big_int -> bool **)
  
  let rec bits_of_Z n x =
    Big.nat_case
      (fun _ i ->
      false)
      (fun m ->
      let (b, y) = coq_Z_bin_decomp x in
      let f = bits_of_Z m y in
      (fun i -> if zeq i Big.zero then b else f (Z.sub i Big.one)))
      n
  
  (** val coq_Z_of_bits :
      Big.big_int -> (Big.big_int -> bool) -> Big.big_int **)
  
  let rec coq_Z_of_bits n f =
    Big.nat_case
      (fun _ ->
      Big.zero)
      (fun m ->
      coq_Z_shift_add (f Big.zero)
        (coq_Z_of_bits m (fun i -> f (Z.add i Big.one))))
      n
  
  (** val bitwise_binop :
      Big.big_int -> (bool -> bool -> bool) -> int -> int -> int **)
  
  let bitwise_binop wordsize_minus_one f x y =
    let fx =
      bits_of_Z (wordsize wordsize_minus_one) (unsigned wordsize_minus_one x)
    in
    let fy =
      bits_of_Z (wordsize wordsize_minus_one) (unsigned wordsize_minus_one y)
    in
    repr wordsize_minus_one
      (coq_Z_of_bits (wordsize wordsize_minus_one) (fun i ->
        f (fx i) (fy i)))
  
  (** val coq_and : Big.big_int -> int -> int -> int **)
  
  let coq_and wordsize_minus_one x y =
    bitwise_binop wordsize_minus_one (&&) x y
  
  (** val coq_or : Big.big_int -> int -> int -> int **)
  
  let coq_or wordsize_minus_one x y =
    bitwise_binop wordsize_minus_one (||) x y
  
  (** val xor : Big.big_int -> int -> int -> int **)
  
  let xor wordsize_minus_one x y =
    bitwise_binop wordsize_minus_one xorb x y
  
  (** val not : Big.big_int -> int -> int **)
  
  let not wordsize_minus_one x =
    xor wordsize_minus_one x (mone wordsize_minus_one)
  
  (** val shl : Big.big_int -> int -> int -> int **)
  
  let shl wordsize_minus_one x y =
    let fx =
      bits_of_Z (wordsize wordsize_minus_one) (unsigned wordsize_minus_one x)
    in
    let vy = unsigned wordsize_minus_one y in
    repr wordsize_minus_one
      (coq_Z_of_bits (wordsize wordsize_minus_one) (fun i ->
        fx (Z.sub i vy)))
  
  (** val shru : Big.big_int -> int -> int -> int **)
  
  let shru wordsize_minus_one x y =
    let fx =
      bits_of_Z (wordsize wordsize_minus_one) (unsigned wordsize_minus_one x)
    in
    let vy = unsigned wordsize_minus_one y in
    repr wordsize_minus_one
      (coq_Z_of_bits (wordsize wordsize_minus_one) (fun i ->
        fx (Z.add i vy)))
  
  (** val shr : Big.big_int -> int -> int -> int **)
  
  let shr wordsize_minus_one x y =
    repr wordsize_minus_one
      (Z.div (signed wordsize_minus_one x)
        (two_p (unsigned wordsize_minus_one y)))
  
  (** val shrx : Big.big_int -> int -> int -> int **)
  
  let shrx wordsize_minus_one x y =
    divs wordsize_minus_one x
      (shl wordsize_minus_one (one wordsize_minus_one) y)
  
  (** val shr_carry : Big.big_int -> int -> int -> int **)
  
  let shr_carry wordsize_minus_one x y =
    sub wordsize_minus_one (shrx wordsize_minus_one x y)
      (shr wordsize_minus_one x y)
  
  (** val rol : Big.big_int -> int -> int -> int **)
  
  let rol wordsize_minus_one x y =
    let fx =
      bits_of_Z (wordsize wordsize_minus_one) (unsigned wordsize_minus_one x)
    in
    let vy = unsigned wordsize_minus_one y in
    repr wordsize_minus_one
      (coq_Z_of_bits (wordsize wordsize_minus_one) (fun i ->
        fx (Z.modulo (Z.sub i vy) (Z.of_nat (wordsize wordsize_minus_one)))))
  
  (** val ror : Big.big_int -> int -> int -> int **)
  
  let ror wordsize_minus_one x y =
    let fx =
      bits_of_Z (wordsize wordsize_minus_one) (unsigned wordsize_minus_one x)
    in
    let vy = unsigned wordsize_minus_one y in
    repr wordsize_minus_one
      (coq_Z_of_bits (wordsize wordsize_minus_one) (fun i ->
        fx (Z.modulo (Z.add i vy) (Z.of_nat (wordsize wordsize_minus_one)))))
  
  (** val rolm : Big.big_int -> int -> int -> int -> int **)
  
  let rolm wordsize_minus_one x a m =
    coq_and wordsize_minus_one (rol wordsize_minus_one x a) m
  
  (** val coq_Z_one_bits :
      Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int list **)
  
  let rec coq_Z_one_bits n x i =
    Big.nat_case
      (fun _ ->
      [])
      (fun m ->
      let (b, y) = coq_Z_bin_decomp x in
      if b
      then i :: (coq_Z_one_bits m y (Z.add i Big.one))
      else coq_Z_one_bits m y (Z.add i Big.one))
      n
  
  (** val one_bits : Big.big_int -> int -> int list **)
  
  let one_bits wordsize_minus_one x =
    map (repr wordsize_minus_one)
      (coq_Z_one_bits (wordsize wordsize_minus_one)
        (unsigned wordsize_minus_one x) Big.zero)
  
  (** val is_power2 : Big.big_int -> int -> int option **)
  
  let is_power2 wordsize_minus_one x =
    match coq_Z_one_bits (wordsize wordsize_minus_one)
            (unsigned wordsize_minus_one x) Big.zero with
    | [] -> None
    | i :: l ->
      (match l with
       | [] -> Some (repr wordsize_minus_one i)
       | z :: l0 -> None)
  
  type rlw_state =
  | RLW_S0
  | RLW_S1
  | RLW_S2
  | RLW_S3
  | RLW_S4
  | RLW_S5
  | RLW_S6
  | RLW_Sbad
  
  (** val rlw_state_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> rlw_state ->
      'a1 **)
  
  let rlw_state_rect f f0 f1 f2 f3 f4 f5 f6 = function
  | RLW_S0 -> f
  | RLW_S1 -> f0
  | RLW_S2 -> f1
  | RLW_S3 -> f2
  | RLW_S4 -> f3
  | RLW_S5 -> f4
  | RLW_S6 -> f5
  | RLW_Sbad -> f6
  
  (** val rlw_state_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> rlw_state ->
      'a1 **)
  
  let rlw_state_rec f f0 f1 f2 f3 f4 f5 f6 = function
  | RLW_S0 -> f
  | RLW_S1 -> f0
  | RLW_S2 -> f1
  | RLW_S3 -> f2
  | RLW_S4 -> f3
  | RLW_S5 -> f4
  | RLW_S6 -> f5
  | RLW_Sbad -> f6
  
  (** val rlw_transition : rlw_state -> bool -> rlw_state **)
  
  let rlw_transition s b =
    match s with
    | RLW_S0 -> if b then RLW_S4 else RLW_S1
    | RLW_S1 -> if b then RLW_S2 else RLW_S1
    | RLW_S2 -> if b then RLW_S2 else RLW_S3
    | RLW_S3 -> if b then RLW_Sbad else RLW_S3
    | RLW_S4 -> if b then RLW_S4 else RLW_S5
    | RLW_S5 -> if b then RLW_S6 else RLW_S5
    | RLW_S6 -> if b then RLW_S6 else RLW_Sbad
    | RLW_Sbad -> RLW_Sbad
  
  (** val rlw_accepting : rlw_state -> bool **)
  
  let rlw_accepting = function
  | RLW_S0 -> false
  | RLW_S1 -> false
  | RLW_Sbad -> false
  | _ -> true
  
  (** val is_rlw_mask_rec :
      Big.big_int -> rlw_state -> Big.big_int -> bool **)
  
  let rec is_rlw_mask_rec n s x =
    Big.nat_case
      (fun _ ->
      rlw_accepting s)
      (fun m ->
      let (b, y) = coq_Z_bin_decomp x in
      is_rlw_mask_rec m (rlw_transition s b) y)
      n
  
  (** val is_rlw_mask : Big.big_int -> int -> bool **)
  
  let is_rlw_mask wordsize_minus_one x =
    is_rlw_mask_rec (wordsize wordsize_minus_one) RLW_S0
      (unsigned wordsize_minus_one x)
  
  (** val cmp : Big.big_int -> comparison -> int -> int -> bool **)
  
  let cmp wordsize_minus_one c x y =
    match c with
    | Ceq -> eq wordsize_minus_one x y
    | Cne -> negb (eq wordsize_minus_one x y)
    | Clt -> lt wordsize_minus_one x y
    | Cle -> negb (lt wordsize_minus_one y x)
    | Cgt -> lt wordsize_minus_one y x
    | Cge -> negb (lt wordsize_minus_one x y)
  
  (** val cmpu : Big.big_int -> comparison -> int -> int -> bool **)
  
  let cmpu wordsize_minus_one c x y =
    match c with
    | Ceq -> eq wordsize_minus_one x y
    | Cne -> negb (eq wordsize_minus_one x y)
    | Clt -> ltu wordsize_minus_one x y
    | Cle -> negb (ltu wordsize_minus_one y x)
    | Cgt -> ltu wordsize_minus_one y x
    | Cge -> negb (ltu wordsize_minus_one x y)
  
  (** val notbool : Big.big_int -> int -> int **)
  
  let notbool wordsize_minus_one x =
    if eq wordsize_minus_one x (zero wordsize_minus_one)
    then one wordsize_minus_one
    else zero wordsize_minus_one
  
  (** val check_equal_on_range :
      Big.big_int -> (int -> int) -> (int -> int) -> Big.big_int -> bool **)
  
  let rec check_equal_on_range wordsize_minus_one f g n =
    Big.nat_case
      (fun _ ->
      true)
      (fun n0 ->
      if eq wordsize_minus_one (f (repr wordsize_minus_one (Z.of_nat n0)))
           (g (repr wordsize_minus_one (Z.of_nat n0)))
      then check_equal_on_range wordsize_minus_one f g n0
      else false)
      n
  
  (** val powerserie : Big.big_int list -> Big.big_int **)
  
  let rec powerserie = function
  | [] -> Big.zero
  | x :: xs -> Z.add (two_p x) (powerserie xs)
  
  (** val int_of_one_bits : Big.big_int -> int list -> int **)
  
  let rec int_of_one_bits wordsize_minus_one = function
  | [] -> zero wordsize_minus_one
  | a :: b ->
    add wordsize_minus_one
      (shl wordsize_minus_one (one wordsize_minus_one) a)
      (int_of_one_bits wordsize_minus_one b)
  
  (** val string_to_bool_list : char list -> bool list **)
  
  let rec string_to_bool_list = function
  | [] -> []
  | a::s0 -> (if (=) a '0' then false else true) :: (string_to_bool_list s0)
  
  (** val string_to_Z_bool : char list -> Big.big_int -> bool **)
  
  let rec string_to_Z_bool s =
    let lb = string_to_bool_list s in
    let rec to_Z_bool l i =
      match l with
      | [] -> false
      | b :: l' ->
        if zeq i Big.zero then b else to_Z_bool l' (Z.sub i Big.one)
    in to_Z_bool (rev lb)
  
  (** val string_to_int : Big.big_int -> char list -> int **)
  
  let string_to_int n s =
    let zb = string_to_Z_bool s in repr n (coq_Z_of_bits n zb)
 end

type int1 = Word.int

type int2 = Word.int

type int3 = Word.int

type int8 = Word.int

type int16 = Word.int

type int32 = Word.int

type int80 = Word.int

(** val zero_extend8_32 : int8 -> int32 **)

let zero_extend8_32 w =
  Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ
    Big.zero)))))))))))))))))))))))))))))))
    (Word.unsigned (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero))))))) w)

(** val sign_extend8_32 : int8 -> int32 **)

let sign_extend8_32 w =
  Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ
    Big.zero)))))))))))))))))))))))))))))))
    (Word.signed (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ Big.zero))))))) w)

(** val sign_extend16_32 : int16 -> int32 **)

let sign_extend16_32 w =
  Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ
    Big.zero)))))))))))))))))))))))))))))))
    (Word.signed (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero))))))))))))))) w)

type port_number = int8

type interrupt_type = int8

type selector = int16

type register =
| EAX
| ECX
| EDX
| EBX
| ESP
| EBP
| ESI
| EDI

(** val register_eq_dec : register -> register -> bool **)

let register_eq_dec x y =
  match x with
  | EAX ->
    (match y with
     | EAX -> true
     | _ -> false)
  | ECX ->
    (match y with
     | ECX -> true
     | _ -> false)
  | EDX ->
    (match y with
     | EDX -> true
     | _ -> false)
  | EBX ->
    (match y with
     | EBX -> true
     | _ -> false)
  | ESP ->
    (match y with
     | ESP -> true
     | _ -> false)
  | EBP ->
    (match y with
     | EBP -> true
     | _ -> false)
  | ESI ->
    (match y with
     | ESI -> true
     | _ -> false)
  | EDI ->
    (match y with
     | EDI -> true
     | _ -> false)

(** val z_to_register : Big.big_int -> register **)

let z_to_register n =
  Big.z_case
    (fun _ ->
    EAX)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        EDI)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          EDI)
          (fun p2 ->
          EDI)
          (fun _ ->
          EBP)
          p1)
        (fun _ ->
        EBX)
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          EDI)
          (fun p2 ->
          EDI)
          (fun _ ->
          ESI)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          EDI)
          (fun p2 ->
          EDI)
          (fun _ ->
          ESP)
          p1)
        (fun _ ->
        EDX)
        p0)
      (fun _ ->
      ECX)
      p)
    (fun p ->
    EDI)
    n

type scale =
| Scale1
| Scale2
| Scale4
| Scale8

(** val z_to_scale : Big.big_int -> scale **)

let z_to_scale n =
  Big.z_case
    (fun _ ->
    Scale1)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Scale8)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Scale8)
        (fun p1 ->
        Scale8)
        (fun _ ->
        Scale4)
        p0)
      (fun _ ->
      Scale2)
      p)
    (fun p ->
    Scale8)
    n

type segment_register =
| ES
| CS
| SS
| DS
| FS
| GS

(** val segment_register_eq_dec :
    segment_register -> segment_register -> bool **)

let segment_register_eq_dec x y =
  match x with
  | ES ->
    (match y with
     | ES -> true
     | _ -> false)
  | CS ->
    (match y with
     | CS -> true
     | _ -> false)
  | SS ->
    (match y with
     | SS -> true
     | _ -> false)
  | DS ->
    (match y with
     | DS -> true
     | _ -> false)
  | FS ->
    (match y with
     | FS -> true
     | _ -> false)
  | GS ->
    (match y with
     | GS -> true
     | _ -> false)

type control_register =
| CR0
| CR2
| CR3
| CR4

(** val control_register_eq_dec :
    control_register -> control_register -> bool **)

let control_register_eq_dec x y =
  match x with
  | CR0 ->
    (match y with
     | CR0 -> true
     | _ -> false)
  | CR2 ->
    (match y with
     | CR2 -> true
     | _ -> false)
  | CR3 ->
    (match y with
     | CR3 -> true
     | _ -> false)
  | CR4 ->
    (match y with
     | CR4 -> true
     | _ -> false)

type debug_register =
| DR0
| DR1
| DR2
| DR3
| DR6
| DR7

(** val debug_register_eq_dec : debug_register -> debug_register -> bool **)

let debug_register_eq_dec x y =
  match x with
  | DR0 ->
    (match y with
     | DR0 -> true
     | _ -> false)
  | DR1 ->
    (match y with
     | DR1 -> true
     | _ -> false)
  | DR2 ->
    (match y with
     | DR2 -> true
     | _ -> false)
  | DR3 ->
    (match y with
     | DR3 -> true
     | _ -> false)
  | DR6 ->
    (match y with
     | DR6 -> true
     | _ -> false)
  | DR7 ->
    (match y with
     | DR7 -> true
     | _ -> false)

type address = { addrDisp : int32; addrBase : register option;
                 addrIndex : (scale * register) option }

(** val addrDisp : address -> int32 **)

let addrDisp x = x.addrDisp

(** val addrBase : address -> register option **)

let addrBase x = x.addrBase

(** val addrIndex : address -> (scale * register) option **)

let addrIndex x = x.addrIndex

type operand =
| Imm_op of int32
| Reg_op of register
| Address_op of address
| Offset_op of int32

type reg_or_immed =
| Reg_ri of register
| Imm_ri of int8

type condition_type =
| O_ct
| NO_ct
| B_ct
| NB_ct
| E_ct
| NE_ct
| BE_ct
| NBE_ct
| S_ct
| NS_ct
| P_ct
| NP_ct
| L_ct
| NL_ct
| LE_ct
| NLE_ct

(** val z_to_condition_type : Big.big_int -> condition_type **)

let z_to_condition_type n =
  Big.z_case
    (fun _ ->
    O_ct)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          NLE_ct)
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            NP_ct)
            p2)
          (fun _ ->
          NBE_ct)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            NL_ct)
            p2)
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            NS_ct)
            p2)
          (fun _ ->
          NE_ct)
          p1)
        (fun _ ->
        NB_ct)
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            LE_ct)
            p2)
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            P_ct)
            p2)
          (fun _ ->
          BE_ct)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            L_ct)
            p2)
          (fun p2 ->
          Big.positive_case
            (fun p3 ->
            NLE_ct)
            (fun p3 ->
            NLE_ct)
            (fun _ ->
            S_ct)
            p2)
          (fun _ ->
          E_ct)
          p1)
        (fun _ ->
        B_ct)
        p0)
      (fun _ ->
      NO_ct)
      p)
    (fun p ->
    NLE_ct)
    n

type fp_operand =
| FPS_op of int3
| FPM16_op of address
| FPM32_op of address
| FPM64_op of address
| FPM80_op of address

type fp_condition_type =
| B_fct
| E_fct
| BE_fct
| U_fct
| NB_fct
| NE_fct
| NBE_fct
| NU_fct

(** val z_to_fp_condition_type : Big.big_int -> fp_condition_type **)

let z_to_fp_condition_type n =
  Big.z_case
    (fun _ ->
    B_fct)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        NU_fct)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          NU_fct)
          (fun p2 ->
          NU_fct)
          (fun _ ->
          NE_fct)
          p1)
        (fun _ ->
        U_fct)
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          NU_fct)
          (fun p2 ->
          NU_fct)
          (fun _ ->
          NBE_fct)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          NU_fct)
          (fun p2 ->
          NU_fct)
          (fun _ ->
          NB_fct)
          p1)
        (fun _ ->
        BE_fct)
        p0)
      (fun _ ->
      E_fct)
      p)
    (fun p ->
    NU_fct)
    n

type mmx_register =
| MM0
| MM1
| MM2
| MM3
| MM4
| MM5
| MM6
| MM7

(** val z_to_mmx_register : Big.big_int -> mmx_register **)

let z_to_mmx_register n =
  Big.z_case
    (fun _ ->
    MM0)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        MM7)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          MM7)
          (fun p2 ->
          MM7)
          (fun _ ->
          MM5)
          p1)
        (fun _ ->
        MM3)
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          MM7)
          (fun p2 ->
          MM7)
          (fun _ ->
          MM6)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          MM7)
          (fun p2 ->
          MM7)
          (fun _ ->
          MM4)
          p1)
        (fun _ ->
        MM2)
        p0)
      (fun _ ->
      MM1)
      p)
    (fun p ->
    MM7)
    n

type mmx_granularity =
| MMX_8
| MMX_16
| MMX_32
| MMX_64

type mmx_operand =
| GP_Reg_op of register
| MMX_Addr_op of address
| MMX_Reg_op of mmx_register
| MMX_Imm_op of int32

type sse_register =
| XMM0
| XMM1
| XMM2
| XMM3
| XMM4
| XMM5
| XMM6
| XMM7

(** val z_to_sse_register : Big.big_int -> sse_register **)

let z_to_sse_register n =
  Big.z_case
    (fun _ ->
    XMM0)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        XMM7)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          XMM7)
          (fun p2 ->
          XMM7)
          (fun _ ->
          XMM5)
          p1)
        (fun _ ->
        XMM3)
        p0)
      (fun p0 ->
      Big.positive_case
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          XMM7)
          (fun p2 ->
          XMM7)
          (fun _ ->
          XMM6)
          p1)
        (fun p1 ->
        Big.positive_case
          (fun p2 ->
          XMM7)
          (fun p2 ->
          XMM7)
          (fun _ ->
          XMM4)
          p1)
        (fun _ ->
        XMM2)
        p0)
      (fun _ ->
      XMM1)
      p)
    (fun p ->
    XMM7)
    n

type sse_operand =
| SSE_XMM_Reg_op of sse_register
| SSE_MM_Reg_op of mmx_register
| SSE_Addr_op of address
| SSE_GP_Reg_op of register
| SSE_Imm_op of int32

type instr =
| AAA
| AAD
| AAM
| AAS
| ADC of bool * operand * operand
| ADD of bool * operand * operand
| AND of bool * operand * operand
| ARPL of operand * operand
| BOUND of operand * operand
| BSF of operand * operand
| BSR of operand * operand
| BSWAP of register
| BT of operand * operand
| BTC of operand * operand
| BTR of operand * operand
| BTS of operand * operand
| CALL of bool * bool * operand * selector option
| CDQ
| CLC
| CLD
| CLI
| CLTS
| CMC
| CMOVcc of condition_type * operand * operand
| CMP of bool * operand * operand
| CMPS of bool
| CMPXCHG of bool * operand * operand
| CPUID
| CWDE
| DAA
| DAS
| DEC of bool * operand
| DIV of bool * operand
| F2XM1
| FABS
| FADD of bool * fp_operand
| FADDP of fp_operand
| FBLD of fp_operand
| FBSTP of fp_operand
| FCHS
| FCMOVcc of fp_condition_type * fp_operand
| FCOM of fp_operand
| FCOMP of fp_operand
| FCOMPP
| FCOMIP of fp_operand
| FCOS
| FDECSTP
| FDIV of bool * fp_operand
| FDIVP of fp_operand
| FDIVR of bool * fp_operand
| FDIVRP of fp_operand
| FFREE of fp_operand
| FIADD of fp_operand
| FICOM of fp_operand
| FICOMP of fp_operand
| FIDIV of fp_operand
| FIDIVR of fp_operand
| FILD of fp_operand
| FIMUL of fp_operand
| FINCSTP
| FIST of fp_operand
| FISTP of fp_operand
| FISUB of fp_operand
| FISUBR of fp_operand
| FLD of fp_operand
| FLD1
| FLDCW of fp_operand
| FLDENV of fp_operand
| FLDL2E
| FLDL2T
| FLDLG2
| FLDLN2
| FLDPI
| FLDZ
| FMUL of bool * fp_operand
| FMULP of fp_operand
| FNCLEX
| FNINIT
| FNOP
| FNSAVE of fp_operand
| FNSTCW of fp_operand
| FNSTSW of fp_operand option
| FPATAN
| FPREM
| FPREM1
| FPTAN
| FRNDINT
| FRSTOR of fp_operand
| FSCALE
| FSIN
| FSINCOS
| FSQRT
| FST of fp_operand
| FSTENV of fp_operand
| FSTP of fp_operand
| FSUB of bool * fp_operand
| FSUBP of fp_operand
| FSUBR of bool * fp_operand
| FSUBRP of fp_operand
| FTST
| FUCOM of fp_operand
| FUCOMP of fp_operand
| FUCOMPP
| FUCOMI of fp_operand
| FUCOMIP of fp_operand
| FXAM
| FXCH of fp_operand
| FXTRACT
| FYL2X
| FYL2XP1
| FWAIT
| EMMS
| MOVD of mmx_operand * mmx_operand
| MOVQ of mmx_operand * mmx_operand
| PACKSSDW of mmx_operand * mmx_operand
| PACKSSWB of mmx_operand * mmx_operand
| PACKUSWB of mmx_operand * mmx_operand
| PADD of mmx_granularity * mmx_operand * mmx_operand
| PADDS of mmx_granularity * mmx_operand * mmx_operand
| PADDUS of mmx_granularity * mmx_operand * mmx_operand
| PAND of mmx_operand * mmx_operand
| PANDN of mmx_operand * mmx_operand
| PCMPEQ of mmx_granularity * mmx_operand * mmx_operand
| PCMPGT of mmx_granularity * mmx_operand * mmx_operand
| PMADDWD of mmx_operand * mmx_operand
| PMULHUW of mmx_operand * mmx_operand
| PMULHW of mmx_operand * mmx_operand
| PMULLW of mmx_operand * mmx_operand
| POR of mmx_operand * mmx_operand
| PSLL of mmx_granularity * mmx_operand * mmx_operand
| PSRA of mmx_granularity * mmx_operand * mmx_operand
| PSRL of mmx_granularity * mmx_operand * mmx_operand
| PSUB of mmx_granularity * mmx_operand * mmx_operand
| PSUBS of mmx_granularity * mmx_operand * mmx_operand
| PSUBUS of mmx_granularity * mmx_operand * mmx_operand
| PUNPCKH of mmx_granularity * mmx_operand * mmx_operand
| PUNPCKL of mmx_granularity * mmx_operand * mmx_operand
| PXOR of mmx_operand * mmx_operand
| ADDPS of sse_operand * sse_operand
| ADDSS of sse_operand * sse_operand
| ANDNPS of sse_operand * sse_operand
| ANDPS of sse_operand * sse_operand
| CMPPS of sse_operand * sse_operand * sse_operand
| CMPSS of sse_operand * sse_operand * sse_operand
| COMISS of sse_operand * sse_operand
| CVTPI2PS of sse_operand * sse_operand
| CVTPS2PI of sse_operand * sse_operand
| CVTSI2SS of sse_operand * sse_operand
| CVTSS2SI of sse_operand * sse_operand
| CVTTPS2PI of sse_operand * sse_operand
| CVTTSS2SI of sse_operand * sse_operand
| DIVPS of sse_operand * sse_operand
| DIVSS of sse_operand * sse_operand
| LDMXCSR of sse_operand
| MAXPS of sse_operand * sse_operand
| MAXSS of sse_operand * sse_operand
| MINPS of sse_operand * sse_operand
| MINSS of sse_operand * sse_operand
| MOVAPS of sse_operand * sse_operand
| MOVHLPS of sse_operand * sse_operand
| MOVHPS of sse_operand * sse_operand
| MOVLHPS of sse_operand * sse_operand
| MOVLPS of sse_operand * sse_operand
| MOVMSKPS of sse_operand * sse_operand
| MOVSS of sse_operand * sse_operand
| MOVUPS of sse_operand * sse_operand
| MULPS of sse_operand * sse_operand
| MULSS of sse_operand * sse_operand
| ORPS of sse_operand * sse_operand
| RCPPS of sse_operand * sse_operand
| RCPSS of sse_operand * sse_operand
| RSQRTPS of sse_operand * sse_operand
| RSQRTSS of sse_operand * sse_operand
| SHUFPS of sse_operand * sse_operand * sse_operand
| SQRTPS of sse_operand * sse_operand
| SQRTSS of sse_operand * sse_operand
| STMXCSR of sse_operand
| SUBPS of sse_operand * sse_operand
| SUBSS of sse_operand * sse_operand
| UCOMISS of sse_operand * sse_operand
| UNPCKHPS of sse_operand * sse_operand
| UNPCKLPS of sse_operand * sse_operand
| XORPS of sse_operand * sse_operand
| PAVGB of sse_operand * sse_operand
| PEXTRW of sse_operand * sse_operand * sse_operand
| PINSRW of sse_operand * sse_operand * sse_operand
| PMAXSW of sse_operand * sse_operand
| PMAXUB of sse_operand * sse_operand
| PMINSW of sse_operand * sse_operand
| PMINUB of sse_operand * sse_operand
| PMOVMSKB of sse_operand * sse_operand
| PSADBW of sse_operand * sse_operand
| PSHUFW of sse_operand * sse_operand * sse_operand
| MASKMOVQ of sse_operand * sse_operand
| MOVNTPS of sse_operand * sse_operand
| MOVNTQ of sse_operand * sse_operand
| PREFETCHT0 of sse_operand
| PREFETCHT1 of sse_operand
| PREFETCHT2 of sse_operand
| PREFETCHNTA of sse_operand
| SFENCE
| HLT
| IDIV of bool * operand
| IMUL of bool * operand * operand option * int32 option
| IN of bool * port_number option
| INC of bool * operand
| INS of bool
| INTn of interrupt_type
| INT
| INTO
| INVD
| INVLPG of operand
| IRET
| Jcc of condition_type * int32
| JCXZ of int8
| JMP of bool * bool * operand * selector option
| LAHF
| LAR of operand * operand
| LDS of operand * operand
| LEA of operand * operand
| LEAVE
| LES of operand * operand
| LFS of operand * operand
| LGDT of operand
| LGS of operand * operand
| LIDT of operand
| LLDT of operand
| LMSW of operand
| LODS of bool
| LOOP of int8
| LOOPZ of int8
| LOOPNZ of int8
| LSL of operand * operand
| LSS of operand * operand
| LTR of operand
| MOV of bool * operand * operand
| MOVCR of bool * control_register * register
| MOVDR of bool * debug_register * register
| MOVSR of bool * segment_register * operand
| MOVBE of operand * operand
| MOVS of bool
| MOVSX of bool * operand * operand
| MOVZX of bool * operand * operand
| MUL of bool * operand
| NEG of bool * operand
| NOP of operand
| NOT of bool * operand
| OR of bool * operand * operand
| OUT of bool * port_number option
| OUTS of bool
| POP of operand
| POPSR of segment_register
| POPA
| POPF
| PUSH of bool * operand
| PUSHSR of segment_register
| PUSHA
| PUSHF
| RCL of bool * operand * reg_or_immed
| RCR of bool * operand * reg_or_immed
| RDMSR
| RDPMC
| RDTSC
| RDTSCP
| RET of bool * int16 option
| ROL of bool * operand * reg_or_immed
| ROR of bool * operand * reg_or_immed
| RSM
| SAHF
| SAR of bool * operand * reg_or_immed
| SBB of bool * operand * operand
| SCAS of bool
| SETcc of condition_type * operand
| SGDT of operand
| SHL of bool * operand * reg_or_immed
| SHLD of operand * register * reg_or_immed
| SHR of bool * operand * reg_or_immed
| SHRD of operand * register * reg_or_immed
| SIDT of operand
| SLDT of operand
| SMSW of operand
| STC
| STD
| STI
| STOS of bool
| STR of operand
| SUB of bool * operand * operand
| TEST of bool * operand * operand
| UD2
| VERR of operand
| VERW of operand
| WBINVD
| WRMSR
| XADD of bool * operand * operand
| XCHG of bool * operand * operand
| XLAT
| XOR of bool * operand * operand

type lock_or_rep =
| Lock
| Rep
| Repn

type prefix = { lock_rep : lock_or_rep option;
                seg_override : segment_register option; op_override : 
                bool; addr_override : bool }

(** val lock_rep : prefix -> lock_or_rep option **)

let lock_rep x = x.lock_rep

(** val seg_override : prefix -> segment_register option **)

let seg_override x = x.seg_override

(** val op_override : prefix -> bool **)

let op_override x = x.op_override

(** val addr_override : prefix -> bool **)

let addr_override x = x.addr_override

module X86_PARSER_ARG = 
 struct 
  type char_p = bool
  
  (** val char_dec : char_p -> char_p -> bool **)
  
  let char_dec =
    bool_dec
  
  type coq_type =
  | Int_t
  | Register_t
  | Byte_t
  | Half_t
  | Word_t
  | Double_Word_t
  | Ten_Byte_t
  | Scale_t
  | Condition_t
  | Address_t
  | Operand_t
  | Fpu_Register_t
  | Fp_Debug_Register_t
  | Fp_Operand_t
  | MMX_Granularity_t
  | MMX_Register_t
  | MMX_Operand_t
  | SSE_Register_t
  | SSE_Operand_t
  | Instruction_t
  | Control_Register_t
  | Debug_Register_t
  | Segment_Register_t
  | Lock_or_Rep_t
  | Bool_t
  | Prefix_t
  | Option_t of coq_type
  | UPair_t of coq_type * coq_type
  
  (** val type_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> (coq_type -> 'a1 -> 'a1) ->
      (coq_type -> 'a1 -> coq_type -> 'a1 -> 'a1) -> coq_type -> 'a1 **)
  
  let rec type_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 = function
  | Int_t -> f
  | Register_t -> f0
  | Byte_t -> f1
  | Half_t -> f2
  | Word_t -> f3
  | Double_Word_t -> f4
  | Ten_Byte_t -> f5
  | Scale_t -> f6
  | Condition_t -> f7
  | Address_t -> f8
  | Operand_t -> f9
  | Fpu_Register_t -> f10
  | Fp_Debug_Register_t -> f11
  | Fp_Operand_t -> f12
  | MMX_Granularity_t -> f13
  | MMX_Register_t -> f14
  | MMX_Operand_t -> f15
  | SSE_Register_t -> f16
  | SSE_Operand_t -> f17
  | Instruction_t -> f18
  | Control_Register_t -> f19
  | Debug_Register_t -> f20
  | Segment_Register_t -> f21
  | Lock_or_Rep_t -> f22
  | Bool_t -> f23
  | Prefix_t -> f24
  | Option_t t1 ->
    f25 t1
      (type_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t1)
  | UPair_t (t1, t2) ->
    f26 t1
      (type_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t1) t2
      (type_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t2)
  
  (** val type_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> (coq_type -> 'a1 -> 'a1) ->
      (coq_type -> 'a1 -> coq_type -> 'a1 -> 'a1) -> coq_type -> 'a1 **)
  
  let rec type_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 = function
  | Int_t -> f
  | Register_t -> f0
  | Byte_t -> f1
  | Half_t -> f2
  | Word_t -> f3
  | Double_Word_t -> f4
  | Ten_Byte_t -> f5
  | Scale_t -> f6
  | Condition_t -> f7
  | Address_t -> f8
  | Operand_t -> f9
  | Fpu_Register_t -> f10
  | Fp_Debug_Register_t -> f11
  | Fp_Operand_t -> f12
  | MMX_Granularity_t -> f13
  | MMX_Register_t -> f14
  | MMX_Operand_t -> f15
  | SSE_Register_t -> f16
  | SSE_Operand_t -> f17
  | Instruction_t -> f18
  | Control_Register_t -> f19
  | Debug_Register_t -> f20
  | Segment_Register_t -> f21
  | Lock_or_Rep_t -> f22
  | Bool_t -> f23
  | Prefix_t -> f24
  | Option_t t1 ->
    f25 t1
      (type_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t1)
  | UPair_t (t1, t2) ->
    f26 t1
      (type_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t1) t2
      (type_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16
        f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 t2)
  
  type tipe = coq_type
  
  (** val tipe_eq : tipe -> tipe -> bool **)
  
  let rec tipe_eq t0 t1 =
    match t0 with
    | Int_t ->
      (match t1 with
       | Int_t -> true
       | _ -> false)
    | Register_t ->
      (match t1 with
       | Register_t -> true
       | _ -> false)
    | Byte_t ->
      (match t1 with
       | Byte_t -> true
       | _ -> false)
    | Half_t ->
      (match t1 with
       | Half_t -> true
       | _ -> false)
    | Word_t ->
      (match t1 with
       | Word_t -> true
       | _ -> false)
    | Double_Word_t ->
      (match t1 with
       | Double_Word_t -> true
       | _ -> false)
    | Ten_Byte_t ->
      (match t1 with
       | Ten_Byte_t -> true
       | _ -> false)
    | Scale_t ->
      (match t1 with
       | Scale_t -> true
       | _ -> false)
    | Condition_t ->
      (match t1 with
       | Condition_t -> true
       | _ -> false)
    | Address_t ->
      (match t1 with
       | Address_t -> true
       | _ -> false)
    | Operand_t ->
      (match t1 with
       | Operand_t -> true
       | _ -> false)
    | Fpu_Register_t ->
      (match t1 with
       | Fpu_Register_t -> true
       | _ -> false)
    | Fp_Debug_Register_t ->
      (match t1 with
       | Fp_Debug_Register_t -> true
       | _ -> false)
    | Fp_Operand_t ->
      (match t1 with
       | Fp_Operand_t -> true
       | _ -> false)
    | MMX_Granularity_t ->
      (match t1 with
       | MMX_Granularity_t -> true
       | _ -> false)
    | MMX_Register_t ->
      (match t1 with
       | MMX_Register_t -> true
       | _ -> false)
    | MMX_Operand_t ->
      (match t1 with
       | MMX_Operand_t -> true
       | _ -> false)
    | SSE_Register_t ->
      (match t1 with
       | SSE_Register_t -> true
       | _ -> false)
    | SSE_Operand_t ->
      (match t1 with
       | SSE_Operand_t -> true
       | _ -> false)
    | Instruction_t ->
      (match t1 with
       | Instruction_t -> true
       | _ -> false)
    | Control_Register_t ->
      (match t1 with
       | Control_Register_t -> true
       | _ -> false)
    | Debug_Register_t ->
      (match t1 with
       | Debug_Register_t -> true
       | _ -> false)
    | Segment_Register_t ->
      (match t1 with
       | Segment_Register_t -> true
       | _ -> false)
    | Lock_or_Rep_t ->
      (match t1 with
       | Lock_or_Rep_t -> true
       | _ -> false)
    | Bool_t ->
      (match t1 with
       | Bool_t -> true
       | _ -> false)
    | Prefix_t ->
      (match t1 with
       | Prefix_t -> true
       | _ -> false)
    | Option_t t2 ->
      (match t1 with
       | Option_t t3 -> tipe_eq t2 t3
       | _ -> false)
    | UPair_t (t2, t3) ->
      (match t1 with
       | UPair_t (t4, t5) -> if tipe_eq t2 t4 then tipe_eq t3 t5 else false
       | _ -> false)
  
  type tipe_m = __
  
  type user_type = coq_type
  
  (** val user_type_dec : user_type -> user_type -> bool **)
  
  let user_type_dec =
    tipe_eq
  
  type user_type_denote = tipe_m
  
  (** val byte_explode : int8 -> bool list **)
  
  let byte_explode b =
    let bs =
      Word.bits_of_Z (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ Big.zero))))))))
        (Word.unsigned (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ Big.zero))))))) b)
    in
    (bs (Big.doubleplusone (Big.doubleplusone Big.one))) :: ((bs (Big.double
                                                               (Big.doubleplusone
                                                               Big.one))) :: (
    (bs (Big.doubleplusone (Big.double Big.one))) :: ((bs (Big.double
                                                        (Big.double
                                                        Big.one))) :: (
    (bs (Big.doubleplusone Big.one)) :: ((bs (Big.double Big.one)) :: (
    (bs Big.one) :: ((bs Big.zero) :: [])))))))
  
  (** val nat_explode : Big.big_int -> bool list **)
  
  let nat_explode n =
    byte_explode
      (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ Big.zero))))))) (Z.of_nat n))
  
  type token_id = Big.big_int
  
  (** val num_tokens : token_id **)
  
  let num_tokens =
    Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
  
  (** val token_id_to_chars : token_id -> char_p list **)
  
  let token_id_to_chars =
    nat_explode
 end

type type0 =
| Unit_t
| Char_t
| Void_t
| Pair_t of type0 * type0
| Sum_t of type0 * type0
| List_t of type0
| User_t of X86_PARSER_ARG.user_type

type interp = __

type xform =
| Xid
| Xzero
| Xcomp of xform * xform
| Xchar of X86_PARSER_ARG.char_p
| Xunit
| Xempty
| Xpair of xform * xform
| Xfst
| Xsnd
| Xinl
| Xinr
| Xmatch of xform * xform
| Xcons of xform * xform
| Xmap of xform

(** val xinterp : xform -> interp -> interp **)

let rec xinterp = function
| Xid -> (fun x0 -> x0)
| Xzero -> Obj.magic (fun _ -> assert false (* absurd case *))
| Xcomp (f1, f2) ->
  let f1' = xinterp f1 in let f2' = xinterp f2 in (fun x0 -> f2' (f1' x0))
| Xchar c -> (fun x0 -> Obj.magic c)
| Xunit -> (fun x0 -> Obj.magic ())
| Xempty -> (fun x0 -> Obj.magic [])
| Xpair (f1, f2) ->
  let f1' = xinterp f1 in
  let f2' = xinterp f2 in (fun x0 -> Obj.magic ((f1' x0), (f2' x0)))
| Xfst -> (fun x0 -> fst (Obj.magic x0))
| Xsnd -> (fun x0 -> snd (Obj.magic x0))
| Xinl -> (fun x0 -> Obj.magic (Inl x0))
| Xinr -> (fun x0 -> Obj.magic (Inr x0))
| Xmatch (f1, f2) ->
  let f1' = xinterp f1 in
  let f2' = xinterp f2 in
  (fun x0 ->
  match Obj.magic x0 with
  | Inl x1 -> f1' x1
  | Inr x2 -> f2' x2)
| Xcons (f1, f2) ->
  let f1' = xinterp f1 in
  let f2' = xinterp f2 in
  (fun x0 -> Obj.magic ((f1' x0) :: (Obj.magic f2' x0)))
| Xmap f ->
  let f' = xinterp f in (fun x0 -> Obj.magic (map f' (Obj.magic x0)))

type grammar =
| Eps
| Zero
| Char of X86_PARSER_ARG.char_p
| Any
| Cat of grammar * grammar
| Alt of grammar * grammar
| Star of grammar
| Map of (interp -> interp) * grammar
| Xform of xform * grammar

(** val xcoerce : xform -> xform **)

let xcoerce x =
  x

(** val xpair_fst : xform -> xform **)

let xpair_fst = function
| Xfst -> Xpair ((xcoerce Xfst), Xfst)
| Xsnd -> xcoerce Xid
| x -> Xpair ((xcoerce Xfst), x)

(** val xpair_r : xform -> xform -> xform **)

let xpair_r x2 x1 =
  match x2 with
  | Xzero -> Xzero
  | x -> Xpair (x1, x)

(** val xpair : xform -> xform -> xform **)

let xpair x1 x2 =
  match x1 with
  | Xzero -> Xzero
  | Xfst -> xpair_fst x2
  | x -> xpair_r x2 x

(** val xmatch_inl : xform -> xform **)

let xmatch_inl = function
| Xinl -> Xmatch (Xinl, (xcoerce Xinl))
| Xinr -> xcoerce Xid
| x -> Xmatch (Xinl, (xcoerce x))

(** val xmatch : xform -> xform -> xform **)

let xmatch x1 x2 =
  match x1 with
  | Xinl -> xmatch_inl x2
  | x -> Xmatch (x, x2)

(** val xcomp_pair : xform -> xform -> xform -> xform **)

let xcomp_pair x2 x11 x12 =
  match x2 with
  | Xid -> xcoerce (Xpair (x11, x12))
  | Xchar c -> Xchar c
  | Xunit -> Xunit
  | Xempty -> Xempty
  | Xpair (x21, x22) ->
    Xpair ((Xcomp ((Xpair (x11, x12)), (xcoerce x21))), (Xcomp ((Xpair (x11,
      x12)), (xcoerce x22))))
  | Xfst -> xcoerce x11
  | Xsnd -> xcoerce x12
  | x -> Xcomp ((Xpair (x11, x12)), (xcoerce x))

(** val xcomp_inl : xform -> xform **)

let xcomp_inl = function
| Xid -> xcoerce Xinl
| Xchar c -> Xchar c
| Xunit -> Xunit
| Xempty -> Xempty
| Xinl -> Xcomp (Xinl, (xcoerce Xinl))
| Xmatch (x21, x22) -> xcoerce x21
| x -> Xcomp (Xinl, (xcoerce x))

(** val xcomp_inr : xform -> xform **)

let xcomp_inr = function
| Xid -> xcoerce Xinr
| Xchar c -> Xchar c
| Xunit -> Xunit
| Xempty -> Xempty
| Xinr -> Xcomp (Xinr, (xcoerce Xinr))
| Xmatch (x21, x22) -> xcoerce x22
| x -> Xcomp (Xinr, (xcoerce x))

(** val xcomp_map : xform -> xform -> xform **)

let xcomp_map x2 x11 =
  match x2 with
  | Xid -> xcoerce (Xmap x11)
  | Xchar c -> Xchar c
  | Xunit -> Xunit
  | Xempty -> Xempty
  | Xmap x21 -> Xmap (Xcomp (x11, (xcoerce x21)))
  | x -> Xcomp ((Xmap x11), (xcoerce x))

(** val xcomp_empty : xform -> xform **)

let xcomp_empty = function
| Xid -> xcoerce Xempty
| Xchar c -> Xchar c
| Xunit -> Xunit
| Xempty -> Xempty
| Xmap f -> Xempty
| x -> Xcomp (Xempty, (xcoerce x))

(** val xcomp_cons : xform -> xform -> xform -> xform **)

let xcomp_cons x2 x11 x12 =
  match x2 with
  | Xid -> xcoerce (Xcons (x11, x12))
  | Xchar c -> Xchar c
  | Xunit -> Xunit
  | Xempty -> Xempty
  | Xmap x ->
    Xcons ((Xcomp (x11, (xcoerce x))), (Xcomp (x12, (xcoerce (Xmap x)))))
  | x -> Xcomp ((Xcons (x11, x12)), (xcoerce x))

(** val xcomp_r : xform -> xform -> xform **)

let xcomp_r x2 x =
  match x2 with
  | Xid -> x
  | Xchar c -> Xchar c
  | Xunit -> Xunit
  | Xempty -> Xempty
  | Xpair (x21, x22) -> Xpair ((Xcomp (x, x21)), (Xcomp (x, x22)))
  | x0 -> Xcomp (x, x0)

(** val xcomp : xform -> xform -> xform **)

let rec xcomp x1 x =
  match x1 with
  | Xid -> x
  | Xzero -> Xzero
  | Xcomp (x11, x12) -> xcomp x11 (xcomp x12 x)
  | Xempty -> xcomp_empty x
  | Xpair (x11, x12) -> xcomp_pair x x11 x12
  | Xinl -> xcomp_inl x
  | Xinr -> xcomp_inr x
  | Xmatch (x11, x12) -> Xmatch ((xcomp x11 x), (xcomp x12 x))
  | Xcons (x11, x12) -> xcomp_cons x x11 x12
  | Xmap x11 -> xcomp_map x x11
  | x0 -> xcomp_r x x0

(** val xcomp' : xform -> xform -> xform **)

let rec xcomp' x2 x =
  match x2 with
  | Xcomp (x21, x22) -> xcomp' x22 (xcomp' x21 x)
  | Xpair (x21, x22) -> Xpair ((xcomp' x21 x), (xcomp' x22 x))
  | x0 -> xcomp x x0

(** val xopt : xform -> xform **)

let rec xopt = function
| Xcomp (x1, x2) -> xcomp' (xopt x2) (xopt x1)
| Xpair (x1, x2) -> xpair (xopt x1) (xopt x2)
| Xmatch (x1, x2) -> xmatch (xopt x1) (xopt x2)
| Xcons (x1, x2) -> Xcons ((xopt x1), (xopt x2))
| Xmap x1 -> Xmap (xopt x1)
| x0 -> x0

type astgram =
| AEps
| AZero
| AChar of X86_PARSER_ARG.char_p
| AAny
| ACat of astgram * astgram
| AAlt of astgram * astgram
| AStar of astgram

(** val astgram_dec : astgram -> astgram -> bool **)

let rec astgram_dec a a0 =
  match a with
  | AEps ->
    (match a0 with
     | AEps -> true
     | _ -> false)
  | AZero ->
    (match a0 with
     | AZero -> true
     | _ -> false)
  | AChar c ->
    (match a0 with
     | AChar c0 -> X86_PARSER_ARG.char_dec c c0
     | _ -> false)
  | AAny ->
    (match a0 with
     | AAny -> true
     | _ -> false)
  | ACat (a1, a2) ->
    (match a0 with
     | ACat (a3, a4) ->
       if astgram_dec a1 a3 then astgram_dec a2 a4 else false
     | _ -> false)
  | AAlt (a1, a2) ->
    (match a0 with
     | AAlt (a3, a4) ->
       if astgram_dec a1 a3 then astgram_dec a2 a4 else false
     | _ -> false)
  | AStar a1 ->
    (match a0 with
     | AStar a2 -> astgram_dec a1 a2
     | _ -> false)

(** val astgram_type : astgram -> type0 **)

let rec astgram_type = function
| AEps -> Unit_t
| AZero -> Void_t
| ACat (pg1, pg2) -> Pair_t ((astgram_type pg1), (astgram_type pg2))
| AAlt (pg1, pg2) -> Sum_t ((astgram_type pg1), (astgram_type pg2))
| AStar pg0 -> List_t (astgram_type pg0)
| _ -> Char_t

type fixfn = interp -> interp

(** val ag_and_fn : astgram -> fixfn -> (astgram, fixfn) sigT **)

let ag_and_fn ag f =
  ExistT (ag, f)

(** val split_astgram : grammar -> (astgram, fixfn) sigT **)

let rec split_astgram = function
| Eps -> ag_and_fn AEps (fun x -> x)
| Zero ->
  ag_and_fn AZero (Obj.magic (fun _ -> assert false (* absurd case *)))
| Char c -> ag_and_fn (AChar c) (fun x -> x)
| Any -> ag_and_fn AAny (fun x -> x)
| Cat (g1, g2) ->
  let ExistT (ag1, f1) = split_astgram g1 in
  let ExistT (ag2, f2) = split_astgram g2 in
  ag_and_fn (ACat (ag1, ag2)) (fun p ->
    Obj.magic ((f1 (fst (Obj.magic p))), (f2 (snd (Obj.magic p)))))
| Alt (g1, g2) ->
  let ExistT (ag1, f1) = split_astgram g1 in
  let ExistT (ag2, f2) = split_astgram g2 in
  ag_and_fn (AAlt (ag1, ag2)) (fun s ->
    match Obj.magic s with
    | Inl x -> Obj.magic (Inl (f1 x))
    | Inr y -> Obj.magic (Inr (f2 y)))
| Star g0 ->
  let ExistT (ag, f) = split_astgram g0 in
  ag_and_fn (AStar ag) (fun xs -> Obj.magic (map f (Obj.magic xs)))
| Map (f1, g0) ->
  let ExistT (ag, f2) = split_astgram g0 in ag_and_fn ag (fun x -> f1 (f2 x))
| Xform (f, g0) ->
  let ExistT (ag, f2) = split_astgram g0 in
  ag_and_fn ag (fun x -> xinterp f (f2 x))

(** val agxf : astgram -> xform -> (astgram, xform) sigT **)

let agxf ag f =
  ExistT (ag, f)

(** val append_alt : astgram -> astgram -> (astgram, xform) sigT **)

let rec append_alt ag1 ag2 =
  match ag1 with
  | AZero -> agxf ag2 Xinr
  | x ->
    (match ag2 with
     | AZero -> agxf x Xinl
     | x0 -> agxf (AAlt (x, x0)) Xid)

(** val append_cat : astgram -> astgram -> (astgram, xform) sigT **)

let rec append_cat ag1 ag2 =
  match ag1 with
  | AEps -> agxf ag2 (Xpair (Xunit, Xid))
  | AZero -> agxf AZero Xzero
  | x ->
    (match ag2 with
     | AEps -> agxf x (Xpair (Xid, Xunit))
     | AZero -> agxf AZero Xzero
     | x0 -> agxf (ACat (x, x0)) Xid)

(** val opt_ag : astgram -> (astgram, xform) sigT **)

let opt_ag = function
| ACat (ag1, ag2) -> append_cat ag1 ag2
| AAlt (ag1, ag2) -> append_alt ag1 ag2
| AStar a ->
  (match a with
   | AZero -> agxf AEps Xempty
   | x -> let ag' = AStar x in agxf ag' Xid)
| x -> agxf x Xid

(** val opt_agxf : astgram -> xform -> (astgram, xform) sigT **)

let opt_agxf ag f =
  let ExistT (ag', f') = opt_ag ag in agxf ag' (xcomp f' f)

(** val null_and_split : astgram -> (astgram, xform) sigT **)

let rec null_and_split = function
| AEps -> agxf AEps Xid
| ACat (ag11, ag12) ->
  let ExistT (ag11', f1) = null_and_split ag11 in
  (match ag11' with
   | AZero -> agxf AZero Xzero
   | _ ->
     let ExistT (ag12', f2) = null_and_split ag12 in
     opt_agxf (ACat (ag11', ag12')) (Xpair ((Xcomp (Xfst, f1)), (Xcomp (Xsnd,
       f2)))))
| AAlt (ag11, ag12) ->
  let ExistT (ag11', f1) = null_and_split ag11 in
  let ExistT (ag12', f2) = null_and_split ag12 in
  opt_agxf (AAlt (ag11', ag12')) (Xmatch ((Xcomp (f1, Xinl)), (Xcomp (f2,
    Xinr))))
| AStar ag11 -> agxf AEps Xempty
| _ -> agxf AZero Xzero

(** val deriv_and_split :
    astgram -> X86_PARSER_ARG.char_p -> (astgram, xform) sigT **)

let rec deriv_and_split ag1 c =
  match ag1 with
  | AChar c' ->
    if X86_PARSER_ARG.char_dec c c'
    then agxf AEps (Xchar c)
    else agxf AZero Xzero
  | AAny -> agxf AEps (Xchar c)
  | ACat (ag11, ag12) ->
    let ExistT (ag11', f1) = deriv_and_split ag11 c in
    let ExistT (ag_left, f_left) = opt_ag (ACat (ag11', ag12)) in
    let ExistT (ag11null', fnull) = null_and_split ag11 in
    (match ag11null' with
     | AZero ->
       agxf ag_left (Xcomp (f_left, (Xpair ((Xcomp (Xfst, f1)), Xsnd))))
     | _ ->
       let ExistT (ag12', f2) = deriv_and_split ag12 c in
       let ExistT (ag_right, f_right) = opt_ag (ACat (ag11null', ag12')) in
       opt_agxf (AAlt (ag_left, ag_right)) (Xmatch ((Xcomp (f_left, (Xpair
         ((Xcomp (Xfst, f1)), Xsnd)))), (Xcomp (f_right, (Xpair ((Xcomp
         (Xfst, fnull)), (Xcomp (Xsnd, f2)))))))))
  | AAlt (ag11, ag12) ->
    let ExistT (ag11', f1) = deriv_and_split ag11 c in
    let ExistT (ag12', f2) = deriv_and_split ag12 c in
    opt_agxf (AAlt (ag11', ag12')) (Xmatch ((Xcomp (f1, Xinl)), (Xcomp (f2,
      Xinr))))
  | AStar ag0 ->
    let ExistT (ag0', f) = deriv_and_split ag0 c in
    opt_agxf (ACat (ag0', (AStar ag0))) (Xcons ((Xcomp (Xfst, f)), Xsnd))
  | _ -> agxf AZero Xzero

(** val cross_prod : 'a1 list -> 'a2 list -> ('a1 * 'a2) list **)

let cross_prod xs ys =
  fold_right (fun v a -> app (map (fun w -> (v, w)) ys) a) [] xs

(** val astgram_extract_nil : astgram -> interp list **)

let rec astgram_extract_nil = function
| AEps -> (Obj.magic ()) :: []
| ACat (ag1, ag2) ->
  Obj.magic (cross_prod (astgram_extract_nil ag1) (astgram_extract_nil ag2))
| AAlt (ag1, ag2) ->
  app (map (fun x -> Obj.magic (Inl x)) (astgram_extract_nil ag1))
    (map (fun x -> Obj.magic (Inr x)) (astgram_extract_nil ag2))
| AStar ag0 -> (Obj.magic []) :: []
| _ -> []

(** val derivs_and_split :
    astgram -> X86_PARSER_ARG.char_p list -> (astgram, xform) sigT **)

let rec derivs_and_split ag = function
| [] -> agxf ag Xid
| c :: cs' ->
  let ExistT (ag1, x1) = deriv_and_split ag c in
  let ExistT (ag2, x2) = derivs_and_split ag1 cs' in
  agxf ag2 (xopt (xcomp' x1 x2))

type states_t = astgram list

type entry_t = { next_state : Big.big_int; next_xform : (interp -> interp) }

(** val next_state : Big.big_int -> states_t -> entry_t -> Big.big_int **)

let next_state _ _ x = x.next_state

(** val next_xform :
    Big.big_int -> states_t -> entry_t -> interp -> interp **)

let next_xform _ _ x = x.next_xform

type row_t = entry_t list

type transition_t = { row_num : Big.big_int; row_entries : entry_t list;
                      row_nils : interp list }

(** val row_num : states_t -> transition_t -> Big.big_int **)

let row_num _ x = x.row_num

(** val row_entries : states_t -> transition_t -> entry_t list **)

let row_entries _ x = x.row_entries

(** val row_nils : states_t -> transition_t -> interp list **)

let row_nils _ x = x.row_nils

type transitions_t = transition_t list

type dFA = { dfa_num_states : Big.big_int; dfa_states : states_t;
             dfa_transition : transitions_t; dfa_accepts : bool list;
             dfa_rejects : bool list }

(** val dfa_states : dFA -> states_t **)

let dfa_states x = x.dfa_states

(** val dfa_transition : dFA -> transitions_t **)

let dfa_transition x = x.dfa_transition

(** val find_index' :
    astgram -> Big.big_int -> states_t -> Big.big_int option **)

let rec find_index' g n = function
| [] -> None
| h :: t0 ->
  if astgram_dec g h
  then Some n
  else find_index' g (plus (Big.succ Big.zero) n) t0

(** val find_index : astgram -> states_t -> Big.big_int option **)

let find_index g states =
  find_index' g Big.zero states

(** val find_or_add : astgram -> states_t -> states_t * Big.big_int **)

let find_or_add g states =
  match find_index g states with
  | Some i -> ([], i)
  | None -> ((g :: []), (length states))

(** val accepts_null : astgram -> bool **)

let rec accepts_null = function
| AEps -> true
| ACat (g1, g2) -> (&&) (accepts_null g1) (accepts_null g2)
| AAlt (g1, g2) -> (||) (accepts_null g1) (accepts_null g2)
| AStar a -> true
| _ -> false

(** val build_accept_table : states_t -> bool list **)

let build_accept_table s =
  map accepts_null s

(** val always_rejects : astgram -> bool **)

let rec always_rejects = function
| AZero -> true
| ACat (g1, g2) -> (||) (always_rejects g1) (always_rejects g2)
| AAlt (g1, g2) -> (&&) (always_rejects g1) (always_rejects g2)
| _ -> false

(** val build_reject_table : states_t -> bool list **)

let build_reject_table s =
  map always_rejects s

(** val gen_row' :
    astgram -> Big.big_int -> Big.big_int -> states_t ->
    X86_PARSER_ARG.token_id -> (states_t, (row_t, __) sigT) sigT **)

let rec gen_row' g gpos n s tid =
  Big.nat_case
    (fun _ -> ExistT ([], (ExistT ([],
    __))))
    (fun n' ->
    let ExistT (g', x) =
      derivs_and_split g (X86_PARSER_ARG.token_id_to_chars tid)
    in
    let ExistT (s2, row) =
      gen_row' g gpos n' (app s (fst (find_or_add g' s)))
        (plus (Big.succ Big.zero) tid)
    in
    let e = { next_state = (snd (find_or_add g' s)); next_xform =
      (xinterp (xcoerce x)) }
    in
    let ExistT (r2, _) = row in
    ExistT ((app (fst (find_or_add g' s)) s2), (ExistT ((e :: r2), __))))
    n

(** val gen_row :
    astgram -> Big.big_int -> states_t -> (states_t, (row_t, __) sigT) sigT **)

let gen_row g gpos s =
  let ExistT (s', s0) = gen_row' g gpos X86_PARSER_ARG.num_tokens s Big.zero
  in
  let ExistT (r2, _) = s0 in ExistT (s', (ExistT (r2, __)))

(** val coerce_entry :
    Big.big_int -> astgram list -> astgram list -> entry_t -> entry_t **)

let coerce_entry r2 s s1 e =
  { next_state = e.next_state; next_xform = e.next_xform }

(** val coerce_nils :
    astgram list -> astgram list -> Big.big_int -> interp -> interp **)

let coerce_nils s1 s2 i v =
  v

(** val coerce_transitions :
    astgram list -> states_t -> transitions_t -> transitions_t **)

let coerce_transitions s1 s ts =
  map (fun t0 -> { row_num = t0.row_num; row_entries =
    (map (coerce_entry t0.row_num s s1) t0.row_entries); row_nils =
    (map (coerce_nils s s1 t0.row_num) t0.row_nils) }) ts

(** val build_table :
    Big.big_int -> states_t -> transitions_t -> Big.big_int -> (states_t,
    transitions_t) sigT option **)

let rec build_table n s rows next_state0 =
  Big.nat_case
    (fun _ ->
    None)
    (fun n' ->
    match nth_error s next_state0 with
    | Some r2 ->
      let ExistT (s1, s0) = gen_row r2 next_state0 s in
      let ExistT (row, _) = s0 in
      let t0 = { row_num = next_state0; row_entries = row; row_nils =
        (astgram_extract_nil (nth next_state0 (app s s1) AZero)) }
      in
      build_table n' (app s s1)
        (app (coerce_transitions s1 s rows) (t0 :: []))
        (plus (Big.succ Big.zero) next_state0)
    | None -> Some (ExistT (s, rows)))
    n

(** val build_transition_table :
    Big.big_int -> astgram -> (states_t, transitions_t) sigT option **)

let build_transition_table n r2 =
  build_table n (r2 :: []) [] Big.zero

(** val build_dfa : Big.big_int -> astgram -> dFA option **)

let build_dfa n a =
  match build_transition_table n a with
  | Some s ->
    let ExistT (states, table) = s in
    Some { dfa_num_states = (length states); dfa_states = states;
    dfa_transition = table; dfa_accepts = (build_accept_table states);
    dfa_rejects = (build_reject_table states) }
  | None -> None

(** val coerce_dom : type0 -> type0 -> (interp -> 'a1) -> interp -> 'a1 **)

let coerce_dom a a' f x =
  f x

type instParserState = { dfa_ps : dFA; row_ps : Big.big_int; fixup_ps : fixfn }

(** val dfa_ps : type0 -> instParserState -> dFA **)

let dfa_ps _ x = x.dfa_ps

(** val row_ps : type0 -> instParserState -> Big.big_int **)

let row_ps _ x = x.row_ps

(** val fixup_ps : type0 -> instParserState -> fixfn **)

let fixup_ps _ x = x.fixup_ps

(** val opt_initial_parser_state :
    Big.big_int -> grammar -> instParserState option **)

let opt_initial_parser_state n g =
  let ExistT (ag, f) = split_astgram g in
  (match build_dfa n ag with
   | Some d ->
     Some { dfa_ps = d; row_ps = Big.zero; fixup_ps =
       (coerce_dom (astgram_type ag)
         (astgram_type (nth Big.zero d.dfa_states AZero)) f) }
   | None -> None)

(** val compose : ('a1 -> 'a2) -> ('a2 -> 'a3) -> 'a1 -> 'a3 **)

let compose f g z =
  g (f z)

(** val coerce : 'a1 -> 'a2 **)

let coerce x =
  Obj.magic x

(** val parse_token :
    instParserState -> X86_PARSER_ARG.token_id -> instParserState * interp
    list **)

let parse_token ps tk =
  let d = ps.dfa_ps in
  (match nth_error d.dfa_transition ps.row_ps with
   | Some row ->
     (match nth_error row.row_entries tk with
      | Some e ->
        let next_i = e.next_state in
        let g = compose e.next_xform (coerce ps.fixup_ps) in
        let vs0 =
          match nth_error d.dfa_transition next_i with
          | Some row' -> coerce row'.row_nils
          | None -> []
        in
        let vs' = map g vs0 in
        ({ dfa_ps = d; row_ps = next_i; fixup_ps = g }, vs')
      | None -> assert false (* absurd case *))
   | None -> assert false (* absurd case *))

module PTree = 
 struct 
  type elt = Big.big_int
  
  (** val elt_eq : Big.big_int -> Big.big_int -> bool **)
  
  let elt_eq =
    peq
  
  type 'a tree =
  | Leaf
  | Node of 'a tree * 'a option * 'a tree
  
  (** val tree_rect :
      'a2 -> ('a1 tree -> 'a2 -> 'a1 option -> 'a1 tree -> 'a2 -> 'a2) -> 'a1
      tree -> 'a2 **)
  
  let rec tree_rect f f0 = function
  | Leaf -> f
  | Node (t1, o, t2) -> f0 t1 (tree_rect f f0 t1) o t2 (tree_rect f f0 t2)
  
  (** val tree_rec :
      'a2 -> ('a1 tree -> 'a2 -> 'a1 option -> 'a1 tree -> 'a2 -> 'a2) -> 'a1
      tree -> 'a2 **)
  
  let rec tree_rec f f0 = function
  | Leaf -> f
  | Node (t1, o, t2) -> f0 t1 (tree_rec f f0 t1) o t2 (tree_rec f f0 t2)
  
  type 'a t = 'a tree
  
  (** val eq : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool **)
  
  let rec eq eqA a b =
    match a with
    | Leaf ->
      (match b with
       | Leaf -> true
       | Node (t0, o, t1) -> false)
    | Node (t0, o, t1) ->
      (match b with
       | Leaf -> false
       | Node (t2, o0, t3) ->
         if eq eqA t0 t2
         then if match o with
                 | Some x ->
                   (match o0 with
                    | Some a1 -> eqA x a1
                    | None -> false)
                 | None ->
                   (match o0 with
                    | Some a0 -> false
                    | None -> true)
              then eq eqA t1 t3
              else false
         else false)
  
  (** val empty : 'a1 t **)
  
  let empty =
    Leaf
  
  (** val get : Big.big_int -> 'a1 t -> 'a1 option **)
  
  let rec get i = function
  | Leaf -> None
  | Node (l, o, r2) ->
    (Big.positive_case
       (fun ii ->
       get ii r2)
       (fun ii ->
       get ii l)
       (fun _ ->
       o)
       i)
  
  (** val set : Big.big_int -> 'a1 -> 'a1 t -> 'a1 t **)
  
  let rec set i v = function
  | Leaf ->
    (Big.positive_case
       (fun ii -> Node (Leaf, None,
       (set ii v Leaf)))
       (fun ii -> Node ((set ii v Leaf), None,
       Leaf))
       (fun _ -> Node (Leaf, (Some v),
       Leaf))
       i)
  | Node (l, o, r2) ->
    (Big.positive_case
       (fun ii -> Node (l, o,
       (set ii v r2)))
       (fun ii -> Node ((set ii v l), o,
       r2))
       (fun _ -> Node (l, (Some v),
       r2))
       i)
  
  (** val remove : Big.big_int -> 'a1 t -> 'a1 t **)
  
  let rec remove i m =
    Big.positive_case
      (fun ii ->
      match m with
      | Leaf -> Leaf
      | Node (l, o, r2) ->
        (match l with
         | Leaf ->
           (match o with
            | Some a -> Node (l, o, (remove ii r2))
            | None ->
              (match remove ii r2 with
               | Leaf -> Leaf
               | Node (t0, o0, t1) -> Node (Leaf, None, (Node (t0, o0, t1)))))
         | Node (t0, o0, t1) -> Node (l, o, (remove ii r2))))
      (fun ii ->
      match m with
      | Leaf -> Leaf
      | Node (l, o, r2) ->
        (match o with
         | Some a -> Node ((remove ii l), o, r2)
         | None ->
           (match r2 with
            | Leaf ->
              (match remove ii l with
               | Leaf -> Leaf
               | Node (t0, o0, t1) -> Node ((Node (t0, o0, t1)), None, Leaf))
            | Node (t0, o0, t1) -> Node ((remove ii l), o, r2))))
      (fun _ ->
      match m with
      | Leaf -> Leaf
      | Node (l, o, r2) ->
        (match l with
         | Leaf ->
           (match r2 with
            | Leaf -> Leaf
            | Node (t0, o0, t1) -> Node (l, None, r2))
         | Node (t0, o0, t1) -> Node (l, None, r2)))
      i
  
  (** val bempty : 'a1 t -> bool **)
  
  let rec bempty = function
  | Leaf -> true
  | Node (l, o, r2) ->
    (match o with
     | Some a -> false
     | None -> (&&) (bempty l) (bempty r2))
  
  (** val beq : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool **)
  
  let rec beq beqA m1 m2 =
    match m1 with
    | Leaf -> bempty m2
    | Node (l1, o1, r2) ->
      (match m2 with
       | Leaf -> bempty m1
       | Node (l2, o2, r3) ->
         (&&)
           ((&&)
             (match o1 with
              | Some y1 ->
                (match o2 with
                 | Some y2 -> beqA y1 y2
                 | None -> false)
              | None ->
                (match o2 with
                 | Some a -> false
                 | None -> true)) (beq beqA l1 l2)) (beq beqA r2 r3))
  
  (** val append : Big.big_int -> Big.big_int -> Big.big_int **)
  
  let rec append i j =
    Big.positive_case
      (fun ii -> Big.doubleplusone
      (append ii j))
      (fun ii -> Big.double
      (append ii j))
      (fun _ ->
      j)
      i
  
  (** val xmap :
      (Big.big_int -> 'a1 -> 'a2) -> 'a1 t -> Big.big_int -> 'a2 t **)
  
  let rec xmap f m i =
    match m with
    | Leaf -> Leaf
    | Node (l, o, r2) ->
      Node ((xmap f l (append i (Big.double Big.one))), (option_map (f i) o),
        (xmap f r2 (append i (Big.doubleplusone Big.one))))
  
  (** val map : (Big.big_int -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t **)
  
  let map f m =
    xmap f m Big.one
  
  (** val coq_Node' : 'a1 t -> 'a1 option -> 'a1 t -> 'a1 t **)
  
  let coq_Node' l x r2 =
    match l with
    | Leaf ->
      (match x with
       | Some a -> Node (l, x, r2)
       | None ->
         (match r2 with
          | Leaf -> Leaf
          | Node (t0, o, t1) -> Node (l, x, r2)))
    | Node (t0, o, t1) -> Node (l, x, r2)
  
  (** val xcombine_l :
      ('a1 option -> 'a1 option -> 'a1 option) -> 'a1 t -> 'a1 t **)
  
  let rec xcombine_l f = function
  | Leaf -> Leaf
  | Node (l, o, r2) ->
    coq_Node' (xcombine_l f l) (f o None) (xcombine_l f r2)
  
  (** val xcombine_r :
      ('a1 option -> 'a1 option -> 'a1 option) -> 'a1 t -> 'a1 t **)
  
  let rec xcombine_r f = function
  | Leaf -> Leaf
  | Node (l, o, r2) ->
    coq_Node' (xcombine_r f l) (f None o) (xcombine_r f r2)
  
  (** val combine :
      ('a1 option -> 'a1 option -> 'a1 option) -> 'a1 t -> 'a1 t -> 'a1 t **)
  
  let rec combine f m1 m2 =
    match m1 with
    | Leaf -> xcombine_r f m2
    | Node (l1, o1, r2) ->
      (match m2 with
       | Leaf -> xcombine_l f m1
       | Node (l2, o2, r3) ->
         coq_Node' (combine f l1 l2) (f o1 o2) (combine f r2 r3))
  
  (** val xelements : 'a1 t -> Big.big_int -> (Big.big_int * 'a1) list **)
  
  let rec xelements m i =
    match m with
    | Leaf -> []
    | Node (l, o, r2) ->
      (match o with
       | Some x ->
         app (xelements l (append i (Big.double Big.one))) ((i,
           x) :: (xelements r2 (append i (Big.doubleplusone Big.one))))
       | None ->
         app (xelements l (append i (Big.double Big.one)))
           (xelements r2 (append i (Big.doubleplusone Big.one))))
  
  (** val elements : 'a1 t -> (Big.big_int * 'a1) list **)
  
  let elements m =
    xelements m Big.one
  
  (** val xget : Big.big_int -> Big.big_int -> 'a1 t -> 'a1 option **)
  
  let rec xget i j m =
    Big.positive_case
      (fun ii ->
      Big.positive_case
        (fun jj ->
        xget ii jj m)
        (fun p ->
        None)
        (fun _ ->
        get i m)
        j)
      (fun ii ->
      Big.positive_case
        (fun p ->
        None)
        (fun jj ->
        xget ii jj m)
        (fun _ ->
        get i m)
        j)
      (fun _ ->
      Big.positive_case
        (fun p ->
        None)
        (fun p ->
        None)
        (fun _ ->
        get i m)
        j)
      i
  
  (** val xkeys : 'a1 t -> Big.big_int -> Big.big_int list **)
  
  let xkeys m i =
    Coq__1.map fst (xelements m i)
  
  (** val xfold :
      ('a2 -> Big.big_int -> 'a1 -> 'a2) -> Big.big_int -> 'a1 t -> 'a2 ->
      'a2 **)
  
  let rec xfold f i m v =
    match m with
    | Leaf -> v
    | Node (l, o, r2) ->
      (match o with
       | Some x ->
         let v1 = xfold f (append i (Big.double Big.one)) l v in
         let v2 = f v1 i x in
         xfold f (append i (Big.doubleplusone Big.one)) r2 v2
       | None ->
         let v1 = xfold f (append i (Big.double Big.one)) l v in
         xfold f (append i (Big.doubleplusone Big.one)) r2 v1)
  
  (** val fold :
      ('a2 -> Big.big_int -> 'a1 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 **)
  
  let fold f m v =
    xfold f Big.one m v
 end

module PMap = 
 struct 
  type elt = Big.big_int
  
  (** val elt_eq : Big.big_int -> Big.big_int -> bool **)
  
  let elt_eq =
    peq
  
  type 'a t = 'a * 'a PTree.t
  
  (** val eq : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool **)
  
  let eq x a b =
    let x0 = PTree.eq x in
    let (x1, x2) = a in
    let (a1, t0) = b in if x x1 a1 then x0 x2 t0 else false
  
  (** val init : 'a1 -> 'a1 * 'a1 PTree.t **)
  
  let init x =
    (x, PTree.empty)
  
  (** val get : Big.big_int -> 'a1 t -> 'a1 **)
  
  let get i m =
    match PTree.get i (snd m) with
    | Some x -> x
    | None -> fst m
  
  (** val set : Big.big_int -> 'a1 -> 'a1 t -> 'a1 * 'a1 PTree.t **)
  
  let set i x m =
    ((fst m), (PTree.set i x (snd m)))
  
  (** val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t **)
  
  let map f m =
    ((f (fst m)), (PTree.map (fun x -> f) (snd m)))
 end

module type INDEXED_TYPE = 
 sig 
  type t 
  
  val index : t -> Big.big_int
  
  val eq : t -> t -> bool
 end

module IMap = 
 functor (X:INDEXED_TYPE) ->
 struct 
  type elt = X.t
  
  (** val elt_eq : X.t -> X.t -> bool **)
  
  let elt_eq =
    X.eq
  
  type 'x t = 'x PMap.t
  
  (** val eq : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool **)
  
  let eq x a b =
    PMap.eq x a b
  
  (** val init : 'a1 -> 'a1 * 'a1 PTree.t **)
  
  let init x =
    PMap.init x
  
  (** val get : X.t -> 'a1 t -> 'a1 **)
  
  let get i m =
    PMap.get (X.index i) m
  
  (** val set : X.t -> 'a1 -> 'a1 t -> 'a1 * 'a1 PTree.t **)
  
  let set i v m =
    PMap.set (X.index i) v m
  
  (** val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t **)
  
  let map f m =
    PMap.map f m
 end

module ZIndexed = 
 struct 
  type t = Big.big_int
  
  (** val index : Big.big_int -> Big.big_int **)
  
  let index z =
    Big.z_case
      (fun _ ->
      Big.one)
      (fun p -> Big.double
      p)
      (fun p -> Big.doubleplusone
      p)
      z
  
  (** val eq : Big.big_int -> Big.big_int -> bool **)
  
  let eq =
    zeq
 end

module X86_PARSER = 
 struct 
  (** val option_t : X86_PARSER_ARG.coq_type -> type0 **)
  
  let option_t x =
    User_t (X86_PARSER_ARG.Option_t x)
  
  (** val int_t : type0 **)
  
  let int_t =
    User_t X86_PARSER_ARG.Int_t
  
  (** val register_t : type0 **)
  
  let register_t =
    User_t X86_PARSER_ARG.Register_t
  
  (** val byte_t : type0 **)
  
  let byte_t =
    User_t X86_PARSER_ARG.Byte_t
  
  (** val half_t : type0 **)
  
  let half_t =
    User_t X86_PARSER_ARG.Half_t
  
  (** val word_t : type0 **)
  
  let word_t =
    User_t X86_PARSER_ARG.Word_t
  
  (** val double_word_t : type0 **)
  
  let double_word_t =
    User_t X86_PARSER_ARG.Double_Word_t
  
  (** val ten_byte_t : type0 **)
  
  let ten_byte_t =
    User_t X86_PARSER_ARG.Ten_Byte_t
  
  (** val scale_t : type0 **)
  
  let scale_t =
    User_t X86_PARSER_ARG.Scale_t
  
  (** val condition_t : type0 **)
  
  let condition_t =
    User_t X86_PARSER_ARG.Condition_t
  
  (** val fpu_register_t : type0 **)
  
  let fpu_register_t =
    User_t X86_PARSER_ARG.Fpu_Register_t
  
  (** val fp_debug_register_t : type0 **)
  
  let fp_debug_register_t =
    User_t X86_PARSER_ARG.Fp_Debug_Register_t
  
  (** val mmx_granularity_t : type0 **)
  
  let mmx_granularity_t =
    User_t X86_PARSER_ARG.MMX_Granularity_t
  
  (** val mmx_operand_t : type0 **)
  
  let mmx_operand_t =
    User_t X86_PARSER_ARG.MMX_Operand_t
  
  (** val mmx_register_t : type0 **)
  
  let mmx_register_t =
    User_t X86_PARSER_ARG.MMX_Register_t
  
  (** val sse_operand_t : type0 **)
  
  let sse_operand_t =
    User_t X86_PARSER_ARG.SSE_Operand_t
  
  (** val sse_register_t : type0 **)
  
  let sse_register_t =
    User_t X86_PARSER_ARG.SSE_Register_t
  
  (** val address_t : type0 **)
  
  let address_t =
    User_t X86_PARSER_ARG.Address_t
  
  (** val operand_t : type0 **)
  
  let operand_t =
    User_t X86_PARSER_ARG.Operand_t
  
  (** val fp_operand_t : type0 **)
  
  let fp_operand_t =
    User_t X86_PARSER_ARG.Fp_Operand_t
  
  (** val instruction_t : type0 **)
  
  let instruction_t =
    User_t X86_PARSER_ARG.Instruction_t
  
  (** val control_register_t : type0 **)
  
  let control_register_t =
    User_t X86_PARSER_ARG.Control_Register_t
  
  (** val debug_register_t : type0 **)
  
  let debug_register_t =
    User_t X86_PARSER_ARG.Debug_Register_t
  
  (** val segment_register_t : type0 **)
  
  let segment_register_t =
    User_t X86_PARSER_ARG.Segment_Register_t
  
  (** val lock_or_rep_t : type0 **)
  
  let lock_or_rep_t =
    User_t X86_PARSER_ARG.Lock_or_Rep_t
  
  (** val bool_t : type0 **)
  
  let bool_t =
    User_t X86_PARSER_ARG.Bool_t
  
  (** val prefix_t : type0 **)
  
  let prefix_t =
    User_t X86_PARSER_ARG.Prefix_t
  
  (** val bit : bool -> grammar **)
  
  let bit x =
    Char x
  
  (** val never : type0 -> grammar **)
  
  let never t0 =
    Zero
  
  (** val always : type0 -> interp -> grammar **)
  
  let always t0 x =
    Map ((fun x0 -> x), Eps)
  
  (** val alt : type0 -> grammar -> grammar -> grammar **)
  
  let alt t0 p1 p2 =
    Map ((fun x ->
      match Obj.magic x with
      | Inl a -> a
      | Inr b -> b), (Alt (p1, p2)))
  
  (** val alts0 : type0 -> grammar list -> grammar **)
  
  let rec alts0 t0 = function
  | [] -> never t0
  | p :: rest ->
    (match rest with
     | [] -> p
     | g :: l -> alt t0 p (alts0 t0 rest))
  
  (** val half : 'a1 list -> 'a1 list -> 'a1 list -> 'a1 list * 'a1 list **)
  
  let rec half xs ys zs =
    match xs with
    | [] -> (ys, zs)
    | h :: t0 -> half t0 zs (h :: ys)
  
  (** val alts' : Big.big_int -> type0 -> grammar list -> grammar **)
  
  let rec alts' n t0 ps =
    Big.nat_case
      (fun _ ->
      alts0 t0 ps)
      (fun n0 ->
      match ps with
      | [] -> never t0
      | p :: l ->
        (match l with
         | [] -> p
         | g :: l0 ->
           let (ps1, ps2) = half ps [] [] in
           let g1 = alts' n0 t0 ps1 in
           let g2 = alts' n0 t0 ps2 in alt t0 g1 g2))
      n
  
  (** val alts : type0 -> grammar list -> grammar **)
  
  let alts t0 ps =
    alts' (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero)))))))))))))))))))) t0 ps
  
  (** val map :
      type0 -> type0 -> grammar -> (interp -> interp) -> grammar **)
  
  let map t1 t2 p f =
    Map (f, p)
  
  (** val seq : type0 -> type0 -> grammar -> grammar -> grammar **)
  
  let seq t1 t2 p1 p2 =
    Cat (p1, p2)
  
  (** val cons : type0 -> (__ * __ list) -> __ list **)
  
  let cons t0 pair =
    (fst pair) :: (snd pair)
  
  (** val seqs : type0 -> grammar list -> grammar **)
  
  let seqs t0 ps =
    fold_right (fun p1 p2 ->
      map (Pair_t (t0, (List_t t0))) (List_t t0) (seq t0 (List_t t0) p1 p2)
        (Obj.magic (cons t0))) (always (List_t t0) (Obj.magic [])) ps
  
  (** val string_to_bool_list : char list -> bool list **)
  
  let rec string_to_bool_list = function
  | [] -> []
  | a::s0 -> (if (=) a '0' then false else true) :: (string_to_bool_list s0)
  
  (** val bits_n : Big.big_int -> type0 **)
  
  let rec bits_n n =
    Big.nat_case
      (fun _ ->
      Unit_t)
      (fun n0 -> Pair_t (Char_t,
      (bits_n n0)))
      n
  
  (** val field' : Big.big_int -> grammar **)
  
  let rec field' n =
    Big.nat_case
      (fun _ ->
      Eps)
      (fun n0 -> Cat (Any,
      (field' n0)))
      n
  
  (** val bits2Z : Big.big_int -> Big.big_int -> interp -> interp **)
  
  let rec bits2Z n a x =
    Big.nat_case
      (fun _ ->
      Obj.magic a)
      (fun n0 ->
      bits2Z n0
        (Z.add (Z.mul (Big.double Big.one) a)
          (if fst (Obj.magic x) then Big.one else Big.zero))
        (snd (Obj.magic x)))
      n
  
  (** val bits2int : Big.big_int -> interp -> interp **)
  
  let bits2int n bs =
    bits2Z n Big.zero bs
  
  (** val bits : char list -> grammar **)
  
  let rec bits = function
  | [] -> Eps
  | c::s -> Cat ((Char (if (=) c '0' then false else true)), (bits s))
  
  (** val bitsleft : type0 -> char list -> grammar -> grammar **)
  
  let bitsleft t0 s p =
    map (Pair_t ((bits_n (length0 s)), t0)) t0
      (seq (bits_n (length0 s)) t0 (bits s) p) (Obj.magic snd)
  
  (** val anybit : grammar **)
  
  let anybit =
    Any
  
  (** val field : Big.big_int -> grammar **)
  
  let field n =
    map (bits_n n) int_t (field' n) (bits2int n)
  
  (** val reg : grammar **)
  
  let reg =
    map int_t register_t (field (Big.succ (Big.succ (Big.succ Big.zero))))
      (Obj.magic z_to_register)
  
  (** val fpu_reg : grammar **)
  
  let fpu_reg =
    map int_t fpu_register_t
      (field (Big.succ (Big.succ (Big.succ Big.zero))))
      (Obj.magic (Word.repr (Big.succ (Big.succ Big.zero))))
  
  (** val mmx_reg : grammar **)
  
  let mmx_reg =
    map int_t mmx_register_t
      (field (Big.succ (Big.succ (Big.succ Big.zero))))
      (Obj.magic z_to_mmx_register)
  
  (** val sse_reg : grammar **)
  
  let sse_reg =
    map int_t sse_register_t
      (field (Big.succ (Big.succ (Big.succ Big.zero))))
      (Obj.magic z_to_sse_register)
  
  (** val byte : grammar **)
  
  let byte =
    map int_t byte_t
      (field (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero)))))))))
      (Obj.magic
        (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ Big.zero)))))))))
  
  (** val halfword : grammar **)
  
  let halfword =
    map (Pair_t (byte_t, byte_t)) half_t (seq byte_t byte_t byte byte)
      (fun p ->
      let b0 =
        Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
          (Word.unsigned (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero))))))) (fst (Obj.magic p)))
      in
      let b1 =
        Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
          (Word.unsigned (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero))))))) (snd (Obj.magic p)))
      in
      Obj.magic
        (Word.coq_or (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
          (Word.shl (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
            b1
            (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
              (Big.double (Big.double (Big.double Big.one))))) b0))
  
  (** val word : grammar **)
  
  let word =
    map (Pair_t (byte_t, (Pair_t (byte_t, (Pair_t (byte_t, byte_t))))))
      word_t
      (seq byte_t (Pair_t (byte_t, (Pair_t (byte_t, byte_t)))) byte
        (seq byte_t (Pair_t (byte_t, byte_t)) byte
          (seq byte_t byte_t byte byte))) (fun p ->
      let b0 = zero_extend8_32 (fst (Obj.magic p)) in
      let b1 = zero_extend8_32 (fst (snd (Obj.magic p))) in
      let b2 = zero_extend8_32 (fst (snd (snd (Obj.magic p)))) in
      let b3 = zero_extend8_32 (snd (snd (snd (Obj.magic p)))) in
      let w1 =
        Word.shl (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ Big.zero))))))))))))))))))))))))))))))) b1
          (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
            (Big.double (Big.double (Big.double Big.one))))
      in
      let w2 =
        Word.shl (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ Big.zero))))))))))))))))))))))))))))))) b2
          (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
            (Big.double (Big.double (Big.double (Big.double Big.one)))))
      in
      let w3 =
        Word.shl (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ Big.zero))))))))))))))))))))))))))))))) b3
          (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
            (Big.double (Big.double (Big.double (Big.doubleplusone
            Big.one)))))
      in
      Obj.magic
        (Word.coq_or (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))) w3
          (Word.coq_or (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))) w2
            (Word.coq_or (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))) w1
              b0))))
  
  (** val scale_p : grammar **)
  
  let scale_p =
    map int_t scale_t (field (Big.succ (Big.succ Big.zero)))
      (Obj.magic z_to_scale)
  
  (** val tttn : grammar **)
  
  let tttn =
    map int_t condition_t
      (field (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))
      (Obj.magic z_to_condition_type)
  
  (** val reg_no_esp : grammar **)
  
  let reg_no_esp =
    map (bits_n (length0 ('0'::('0'::('0'::[]))))) register_t
      (alt (bits_n (length0 ('0'::('0'::('0'::[])))))
        (bits ('0'::('0'::('0'::[]))))
        (alt (bits_n (length0 ('0'::('0'::('1'::[])))))
          (bits ('0'::('0'::('1'::[]))))
          (alt (bits_n (length0 ('0'::('1'::('0'::[])))))
            (bits ('0'::('1'::('0'::[]))))
            (alt (bits_n (length0 ('0'::('1'::('1'::[])))))
              (bits ('0'::('1'::('1'::[]))))
              (alt (bits_n (length0 ('1'::('0'::('1'::[])))))
                (bits ('1'::('0'::('1'::[]))))
                (alt (bits_n (length0 ('1'::('1'::('0'::[])))))
                  (bits ('1'::('1'::('0'::[]))))
                  (bits ('1'::('1'::('1'::[])))))))))) (fun bs ->
      Obj.magic
        (z_to_register
          (Obj.magic (bits2int (Big.succ (Big.succ (Big.succ Big.zero))) bs))))
  
  (** val reg_no_ebp : grammar **)
  
  let reg_no_ebp =
    map (bits_n (length0 ('0'::('0'::('0'::[]))))) register_t
      (alt (bits_n (length0 ('0'::('0'::('0'::[])))))
        (bits ('0'::('0'::('0'::[]))))
        (alt (bits_n (length0 ('0'::('0'::('1'::[])))))
          (bits ('0'::('0'::('1'::[]))))
          (alt (bits_n (length0 ('0'::('1'::('0'::[])))))
            (bits ('0'::('1'::('0'::[]))))
            (alt (bits_n (length0 ('0'::('1'::('1'::[])))))
              (bits ('0'::('1'::('1'::[]))))
              (alt (bits_n (length0 ('1'::('0'::('0'::[])))))
                (bits ('1'::('0'::('0'::[]))))
                (alt (bits_n (length0 ('1'::('1'::('0'::[])))))
                  (bits ('1'::('1'::('0'::[]))))
                  (bits ('1'::('1'::('1'::[])))))))))) (fun bs ->
      Obj.magic
        (z_to_register
          (Obj.magic (bits2int (Big.succ (Big.succ (Big.succ Big.zero))) bs))))
  
  (** val si : grammar **)
  
  let si =
    map (Pair_t (scale_t, register_t))
      (option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
        X86_PARSER_ARG.Register_t))) (seq scale_t register_t scale_p reg)
      (fun p ->
      match snd (Obj.magic p) with
      | ESP -> Obj.magic None
      | _ -> Obj.magic (Some p))
  
  (** val sib : grammar **)
  
  let sib =
    seq
      (option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
        X86_PARSER_ARG.Register_t))) register_t si reg
  
  (** val rm00 : grammar **)
  
  let rm00 =
    alt address_t
      (map (bits_n (length0 ('0'::('0'::('0'::[]))))) address_t
        (alt (bits_n (length0 ('0'::('0'::('0'::[])))))
          (bits ('0'::('0'::('0'::[]))))
          (alt (bits_n (length0 ('0'::('0'::('1'::[])))))
            (bits ('0'::('0'::('1'::[]))))
            (alt (bits_n (length0 ('0'::('1'::('0'::[])))))
              (bits ('0'::('1'::('0'::[]))))
              (alt (bits_n (length0 ('0'::('1'::('1'::[])))))
                (bits ('0'::('1'::('1'::[]))))
                (alt (bits_n (length0 ('1'::('1'::('0'::[])))))
                  (bits ('1'::('1'::('0'::[]))))
                  (bits ('1'::('1'::('1'::[]))))))))) (fun bs ->
        Obj.magic { addrDisp =
          (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
            Big.zero); addrBase = (Some
          (z_to_register
            (Obj.magic
              (bits2int (Big.succ (Big.succ (Big.succ Big.zero))) bs))));
          addrIndex = None }))
      (alt address_t
        (map (Pair_t ((bits_n (length0 ('1'::('0'::('0'::[]))))), (Pair_t
          ((option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
             X86_PARSER_ARG.Register_t))), register_t)))) address_t
          (seq (bits_n (length0 ('1'::('0'::('0'::[]))))) (Pair_t
            ((option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
               X86_PARSER_ARG.Register_t))), register_t))
            (bits ('1'::('0'::('0'::[]))))
            (seq
              (option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
                X86_PARSER_ARG.Register_t))) register_t si reg_no_ebp))
          (fun p ->
          let (i, i0) = Obj.magic p in
          let (si0, base) = i0 in
          Obj.magic { addrDisp =
            (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
              Big.zero); addrBase = (Some base); addrIndex = si0 }))
        (alt address_t
          (map (Pair_t ((bits_n (length0 ('1'::('0'::('0'::[]))))), (Pair_t
            ((option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
               X86_PARSER_ARG.Register_t))), (Pair_t
            ((bits_n (length0 ('1'::('0'::('1'::[]))))), word_t))))))
            address_t
            (seq (bits_n (length0 ('1'::('0'::('0'::[]))))) (Pair_t
              ((option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
                 X86_PARSER_ARG.Register_t))), (Pair_t
              ((bits_n (length0 ('1'::('0'::('1'::[]))))), word_t))))
              (bits ('1'::('0'::('0'::[]))))
              (seq
                (option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
                  X86_PARSER_ARG.Register_t))) (Pair_t
                ((bits_n (length0 ('1'::('0'::('1'::[]))))), word_t)) si
                (seq (bits_n (length0 ('1'::('0'::('1'::[]))))) word_t
                  (bits ('1'::('0'::('1'::[])))) word))) (fun p ->
            let (i, i0) = Obj.magic p in
            let (si0, i1) = i0 in
            let (i2, disp) = i1 in
            Obj.magic { addrDisp = disp; addrBase = None; addrIndex = si0 }))
          (map (Pair_t ((bits_n (length0 ('1'::('0'::('1'::[]))))), word_t))
            address_t
            (seq (bits_n (length0 ('1'::('0'::('1'::[]))))) word_t
              (bits ('1'::('0'::('1'::[])))) word) (fun p ->
            let (i, disp) = Obj.magic p in
            Obj.magic { addrDisp = disp; addrBase = None; addrIndex = None }))))
  
  (** val rm01 : grammar **)
  
  let rm01 =
    alt address_t
      (map (Pair_t ((bits_n (length0 ('0'::('0'::('0'::[]))))), byte_t))
        address_t
        (seq (bits_n (length0 ('0'::('0'::('0'::[]))))) byte_t
          (alt (bits_n (length0 ('0'::('0'::('0'::[])))))
            (bits ('0'::('0'::('0'::[]))))
            (alt (bits_n (length0 ('0'::('0'::('1'::[])))))
              (bits ('0'::('0'::('1'::[]))))
              (alt (bits_n (length0 ('0'::('1'::('0'::[])))))
                (bits ('0'::('1'::('0'::[]))))
                (alt (bits_n (length0 ('0'::('1'::('1'::[])))))
                  (bits ('0'::('1'::('1'::[]))))
                  (alt (bits_n (length0 ('1'::('0'::('1'::[])))))
                    (bits ('1'::('0'::('1'::[]))))
                    (alt (bits_n (length0 ('1'::('1'::('0'::[])))))
                      (bits ('1'::('1'::('0'::[]))))
                      (bits ('1'::('1'::('1'::[])))))))))) byte) (fun p ->
        let (bs, disp) = Obj.magic p in
        Obj.magic { addrDisp = (sign_extend8_32 disp); addrBase = (Some
          (z_to_register
            (Obj.magic
              (bits2int (Big.succ (Big.succ (Big.succ Big.zero))) bs))));
          addrIndex = None }))
      (map (Pair_t ((bits_n (length0 ('1'::('0'::('0'::[]))))), (Pair_t
        ((Pair_t
        ((option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
           X86_PARSER_ARG.Register_t))), register_t)), byte_t)))) address_t
        (seq (bits_n (length0 ('1'::('0'::('0'::[]))))) (Pair_t ((Pair_t
          ((option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
             X86_PARSER_ARG.Register_t))), register_t)), byte_t))
          (bits ('1'::('0'::('0'::[]))))
          (seq (Pair_t
            ((option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
               X86_PARSER_ARG.Register_t))), register_t)) byte_t sib byte))
        (fun p ->
        let (i, i0) = Obj.magic p in
        let (i1, disp) = i0 in
        let (si0, base) = i1 in
        Obj.magic { addrDisp = (sign_extend8_32 disp); addrBase = (Some
          base); addrIndex = si0 }))
  
  (** val rm10 : grammar **)
  
  let rm10 =
    alt address_t
      (map (Pair_t ((bits_n (length0 ('0'::('0'::('0'::[]))))), word_t))
        address_t
        (seq (bits_n (length0 ('0'::('0'::('0'::[]))))) word_t
          (alt (bits_n (length0 ('0'::('0'::('0'::[])))))
            (bits ('0'::('0'::('0'::[]))))
            (alt (bits_n (length0 ('0'::('0'::('1'::[])))))
              (bits ('0'::('0'::('1'::[]))))
              (alt (bits_n (length0 ('0'::('1'::('0'::[])))))
                (bits ('0'::('1'::('0'::[]))))
                (alt (bits_n (length0 ('0'::('1'::('1'::[])))))
                  (bits ('0'::('1'::('1'::[]))))
                  (alt (bits_n (length0 ('1'::('0'::('1'::[])))))
                    (bits ('1'::('0'::('1'::[]))))
                    (alt (bits_n (length0 ('1'::('1'::('0'::[])))))
                      (bits ('1'::('1'::('0'::[]))))
                      (bits ('1'::('1'::('1'::[])))))))))) word) (fun p ->
        let (bs, disp) = Obj.magic p in
        Obj.magic { addrDisp = disp; addrBase = (Some
          (z_to_register
            (Obj.magic
              (bits2int (Big.succ (Big.succ (Big.succ Big.zero))) bs))));
          addrIndex = None }))
      (map (Pair_t ((bits_n (length0 ('1'::('0'::('0'::[]))))), (Pair_t
        ((Pair_t
        ((option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
           X86_PARSER_ARG.Register_t))), register_t)), word_t)))) address_t
        (seq (bits_n (length0 ('1'::('0'::('0'::[]))))) (Pair_t ((Pair_t
          ((option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
             X86_PARSER_ARG.Register_t))), register_t)), word_t))
          (bits ('1'::('0'::('0'::[]))))
          (seq (Pair_t
            ((option_t (X86_PARSER_ARG.UPair_t (X86_PARSER_ARG.Scale_t,
               X86_PARSER_ARG.Register_t))), register_t)) word_t sib word))
        (fun p ->
        let (i, i0) = Obj.magic p in
        let (i1, disp) = i0 in
        let (si0, base) = i1 in
        Obj.magic { addrDisp = disp; addrBase = (Some base); addrIndex =
          si0 }))
  
  (** val modrm_gen : type0 -> grammar -> (address -> interp) -> grammar **)
  
  let modrm_gen res_t reg_p addr_op =
    alt (Pair_t (res_t, res_t))
      (map (Pair_t (res_t, address_t)) (Pair_t (res_t, res_t))
        (alt (Pair_t (res_t, address_t))
          (bitsleft (Pair_t (res_t, address_t)) ('0'::('0'::[]))
            (seq res_t address_t reg_p rm00))
          (alt (Pair_t (res_t, address_t))
            (bitsleft (Pair_t (res_t, address_t)) ('0'::('1'::[]))
              (seq res_t address_t reg_p rm01))
            (bitsleft (Pair_t (res_t, address_t)) ('1'::('0'::[]))
              (seq res_t address_t reg_p rm10)))) (fun p ->
        let (op1, addr) = Obj.magic p in Obj.magic (op1, (addr_op addr))))
      (map (Pair_t (res_t, res_t)) (Pair_t (res_t, res_t))
        (bitsleft (Pair_t (res_t, res_t)) ('1'::('1'::[]))
          (seq res_t res_t reg_p reg_p)) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (op1, op2)))
  
  (** val reg_op : grammar **)
  
  let reg_op =
    map register_t operand_t reg (fun x -> Obj.magic (Reg_op (Obj.magic x)))
  
  (** val modrm : grammar **)
  
  let modrm =
    modrm_gen operand_t reg_op (Obj.magic (fun x -> Address_op x))
  
  (** val mmx_reg_op : grammar **)
  
  let mmx_reg_op =
    map mmx_register_t mmx_operand_t mmx_reg (fun r2 ->
      Obj.magic (MMX_Reg_op (Obj.magic r2)))
  
  (** val modrm_mmx : grammar **)
  
  let modrm_mmx =
    modrm_gen mmx_operand_t mmx_reg_op (Obj.magic (fun x -> MMX_Addr_op x))
  
  (** val sse_reg_op : grammar **)
  
  let sse_reg_op =
    map sse_register_t sse_operand_t sse_reg (fun r2 ->
      Obj.magic (SSE_XMM_Reg_op (Obj.magic r2)))
  
  (** val modrm_xmm : grammar **)
  
  let modrm_xmm =
    modrm_gen sse_operand_t sse_reg_op (Obj.magic (fun x -> SSE_Addr_op x))
  
  (** val modrm_mm : grammar **)
  
  let modrm_mm =
    modrm_gen sse_operand_t
      (map mmx_register_t sse_operand_t mmx_reg (fun r2 ->
        Obj.magic (SSE_MM_Reg_op (Obj.magic r2))))
      (Obj.magic (fun x -> SSE_Addr_op x))
  
  (** val modrm_gen_noreg :
      type0 -> type0 -> grammar -> (address -> interp) -> grammar **)
  
  let modrm_gen_noreg reg_t res_t reg_p addr_op =
    map (Pair_t (reg_t, address_t)) (Pair_t (reg_t, res_t))
      (alt (Pair_t (reg_t, address_t))
        (bitsleft (Pair_t (reg_t, address_t)) ('0'::('0'::[]))
          (seq reg_t address_t reg_p rm00))
        (alt (Pair_t (reg_t, address_t))
          (bitsleft (Pair_t (reg_t, address_t)) ('0'::('1'::[]))
            (seq reg_t address_t reg_p rm01))
          (bitsleft (Pair_t (reg_t, address_t)) ('1'::('0'::[]))
            (seq reg_t address_t reg_p rm10)))) (fun p ->
      let (op1, addr) = Obj.magic p in Obj.magic (op1, (addr_op addr)))
  
  (** val modrm_noreg : grammar **)
  
  let modrm_noreg =
    modrm_gen_noreg register_t operand_t reg
      (Obj.magic (fun x -> Address_op x))
  
  (** val modrm_xmm_noreg : grammar **)
  
  let modrm_xmm_noreg =
    modrm_gen_noreg sse_operand_t sse_operand_t sse_reg_op
      (Obj.magic (fun x -> SSE_Addr_op x))
  
  (** val modrm_xmm_gp_noreg : grammar **)
  
  let modrm_xmm_gp_noreg =
    modrm_gen_noreg sse_operand_t sse_operand_t
      (map register_t sse_operand_t reg (fun r2 ->
        Obj.magic (SSE_GP_Reg_op (Obj.magic r2))))
      (Obj.magic (fun x -> SSE_Addr_op x))
  
  (** val modrm_mm_noreg : grammar **)
  
  let modrm_mm_noreg =
    modrm_gen_noreg sse_operand_t sse_operand_t
      (map mmx_register_t sse_operand_t mmx_reg (fun r2 ->
        Obj.magic (SSE_MM_Reg_op (Obj.magic r2))))
      (Obj.magic (fun x -> SSE_Addr_op x))
  
  (** val ext_op_modrm_gen :
      type0 -> (address -> interp) -> char list -> grammar **)
  
  let ext_op_modrm_gen res_t addr_op bs =
    map (Pair_t ((bits_n (length0 ('0'::('0'::[])))), (Pair_t
      ((bits_n (length0 bs)), address_t)))) res_t
      (alt (Pair_t ((bits_n (length0 ('0'::('0'::[])))), (Pair_t
        ((bits_n (length0 bs)), address_t))))
        (seq (bits_n (length0 ('0'::('0'::[])))) (Pair_t
          ((bits_n (length0 bs)), address_t)) (bits ('0'::('0'::[])))
          (seq (bits_n (length0 bs)) address_t (bits bs) rm00))
        (alt (Pair_t ((bits_n (length0 ('0'::('1'::[])))), (Pair_t
          ((bits_n (length0 bs)), address_t))))
          (seq (bits_n (length0 ('0'::('1'::[])))) (Pair_t
            ((bits_n (length0 bs)), address_t)) (bits ('0'::('1'::[])))
            (seq (bits_n (length0 bs)) address_t (bits bs) rm01))
          (seq (bits_n (length0 ('1'::('0'::[])))) (Pair_t
            ((bits_n (length0 bs)), address_t)) (bits ('1'::('0'::[])))
            (seq (bits_n (length0 bs)) address_t (bits bs) rm10)))) (fun p ->
      let (i, i0) = Obj.magic p in let (i1, addr) = i0 in addr_op addr)
  
  (** val ext_op_modrm : char list -> grammar **)
  
  let ext_op_modrm =
    ext_op_modrm_gen operand_t (Obj.magic (fun x -> Address_op x))
  
  (** val ext_op_modrm_sse : char list -> grammar **)
  
  let ext_op_modrm_sse =
    ext_op_modrm_gen sse_operand_t (Obj.magic (fun x -> SSE_Addr_op x))
  
  (** val ext_op_modrm_FPM16 : char list -> grammar **)
  
  let ext_op_modrm_FPM16 =
    ext_op_modrm_gen fp_operand_t (Obj.magic (fun x -> FPM16_op x))
  
  (** val ext_op_modrm_FPM32 : char list -> grammar **)
  
  let ext_op_modrm_FPM32 =
    ext_op_modrm_gen fp_operand_t (Obj.magic (fun x -> FPM32_op x))
  
  (** val ext_op_modrm_FPM64 : char list -> grammar **)
  
  let ext_op_modrm_FPM64 =
    ext_op_modrm_gen fp_operand_t (Obj.magic (fun x -> FPM64_op x))
  
  (** val ext_op_modrm_FPM80 : char list -> grammar **)
  
  let ext_op_modrm_FPM80 =
    ext_op_modrm_gen fp_operand_t (Obj.magic (fun x -> FPM80_op x))
  
  (** val ext_op_modrm2_gen :
      type0 -> grammar -> (address -> interp) -> char list -> grammar **)
  
  let ext_op_modrm2_gen res_t reg_p addr_op bs =
    alt res_t
      (map (Pair_t ((bits_n (length0 ('0'::('0'::[])))), (Pair_t
        ((bits_n (length0 bs)), address_t)))) res_t
        (alt (Pair_t ((bits_n (length0 ('0'::('0'::[])))), (Pair_t
          ((bits_n (length0 bs)), address_t))))
          (seq (bits_n (length0 ('0'::('0'::[])))) (Pair_t
            ((bits_n (length0 bs)), address_t)) (bits ('0'::('0'::[])))
            (seq (bits_n (length0 bs)) address_t (bits bs) rm00))
          (alt (Pair_t ((bits_n (length0 ('0'::('1'::[])))), (Pair_t
            ((bits_n (length0 bs)), address_t))))
            (seq (bits_n (length0 ('0'::('1'::[])))) (Pair_t
              ((bits_n (length0 bs)), address_t)) (bits ('0'::('1'::[])))
              (seq (bits_n (length0 bs)) address_t (bits bs) rm01))
            (seq (bits_n (length0 ('1'::('0'::[])))) (Pair_t
              ((bits_n (length0 bs)), address_t)) (bits ('1'::('0'::[])))
              (seq (bits_n (length0 bs)) address_t (bits bs) rm10))))
        (fun p ->
        let (i, i0) = Obj.magic p in let (i1, addr) = i0 in addr_op addr))
      (map (Pair_t ((bits_n (length0 bs)), res_t)) res_t
        (bitsleft (Pair_t ((bits_n (length0 bs)), res_t)) ('1'::('1'::[]))
          (seq (bits_n (length0 bs)) res_t (bits bs) reg_p)) (fun p ->
        let (i, op) = Obj.magic p in op))
  
  (** val ext_op_modrm2 : char list -> grammar **)
  
  let ext_op_modrm2 =
    ext_op_modrm2_gen operand_t reg_op (Obj.magic (fun x -> Address_op x))
  
  (** val coq_AAA_p : grammar **)
  
  let coq_AAA_p =
    map
      (bits_n
        (length0 ('0'::('0'::('1'::('1'::('0'::('1'::('1'::('1'::[]))))))))))
      instruction_t
      (bits ('0'::('0'::('1'::('1'::('0'::('1'::('1'::('1'::[])))))))))
      (fun x -> Obj.magic AAA)
  
  (** val coq_AAD_p : grammar **)
  
  let coq_AAD_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('0'::('1'::('0'::('1'::('0'::('1'::('0'::('0'::('0'::('0'::('1'::('0'::('1'::('0'::[]))))))))))))))))))
      instruction_t
      (bits
        ('1'::('1'::('0'::('1'::('0'::('1'::('0'::('1'::('0'::('0'::('0'::('0'::('1'::('0'::('1'::('0'::[])))))))))))))))))
      (fun x -> Obj.magic AAD)
  
  (** val coq_AAM_p : grammar **)
  
  let coq_AAM_p =
    map
      (bits_n
        (length0
          ('1'::('1'::('0'::('1'::('0'::('1'::('0'::('0'::('0'::('0'::('0'::('0'::('1'::('0'::('1'::('0'::[]))))))))))))))))))
      instruction_t
      (bits
        ('1'::('1'::('0'::('1'::('0'::('1'::('0'::('0'::('0'::('0'::('0'::('0'::('1'::('0'::('1'::('0'::[])))))))))))))))))
      (fun x -> Obj.magic AAM)
  
  (** val coq_AAS_p : grammar **)
  
  let coq_AAS_p =
    map
      (bits_n
        (length0 ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))))
      instruction_t
      (bits ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[])))))))))
      (fun x -> Obj.magic AAS)
  
  (** val imm_op : bool -> grammar **)
  
  let imm_op = function
  | true ->
    map half_t operand_t halfword (fun w ->
      Obj.magic (Imm_op (sign_extend16_32 (Obj.magic w))))
  | false ->
    map word_t operand_t word (fun w -> Obj.magic (Imm_op (Obj.magic w)))
  
  (** val logic_or_arith_p :
      bool -> char list -> char list -> (bool -> operand -> operand -> instr)
      -> grammar **)
  
  let logic_or_arith_p opsize_override op1 op2 instCon =
    alt instruction_t
      (map (Pair_t (Char_t, (Pair_t (Char_t, (Pair_t (operand_t,
        operand_t)))))) instruction_t
        (bitsleft (Pair_t (Char_t, (Pair_t (Char_t, (Pair_t (operand_t,
          operand_t)))))) op1
          (bitsleft (Pair_t (Char_t, (Pair_t (Char_t, (Pair_t (operand_t,
            operand_t)))))) ('0'::[])
            (seq Char_t (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
              anybit
              (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm))))
        (fun p ->
        let (d, i) = Obj.magic p in
        let (w, i0) = i in
        let (op3, op4) = i0 in
        if d
        then Obj.magic instCon w op3 op4
        else Obj.magic instCon w op4 op3))
      (alt instruction_t
        (map (Pair_t (register_t, byte_t)) instruction_t
          (bitsleft (Pair_t (register_t, byte_t))
            ('1'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (register_t, byte_t))
              ('0'::('0'::('1'::('1'::[]))))
              (bitsleft (Pair_t (register_t, byte_t)) ('1'::('1'::[]))
                (bitsleft (Pair_t (register_t, byte_t)) op2
                  (seq register_t byte_t reg byte))))) (fun p ->
          let (r2, imm) = Obj.magic p in
          Obj.magic instCon true (Reg_op r2) (Imm_op (sign_extend8_32 imm))))
        (alt instruction_t
          (map (Pair_t (register_t, byte_t)) instruction_t
            (bitsleft (Pair_t (register_t, byte_t))
              ('1'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (register_t, byte_t))
                ('0'::('0'::('0'::('0'::[]))))
                (bitsleft (Pair_t (register_t, byte_t)) ('1'::('1'::[]))
                  (bitsleft (Pair_t (register_t, byte_t)) op2
                    (seq register_t byte_t reg byte))))) (fun p ->
            let (r2, imm) = Obj.magic p in
            Obj.magic instCon false (Reg_op r2) (Imm_op
              (zero_extend8_32 imm))))
          (alt instruction_t
            (map (Pair_t (register_t, operand_t)) instruction_t
              (bitsleft (Pair_t (register_t, operand_t))
                ('1'::('0'::('0'::('0'::[]))))
                (bitsleft (Pair_t (register_t, operand_t))
                  ('0'::('0'::('0'::('1'::[]))))
                  (bitsleft (Pair_t (register_t, operand_t)) ('1'::('1'::[]))
                    (bitsleft (Pair_t (register_t, operand_t)) op2
                      (seq register_t operand_t reg (imm_op opsize_override))))))
              (fun p ->
              let (r2, imm) = Obj.magic p in
              Obj.magic instCon true (Reg_op r2) imm))
            (alt instruction_t
              (map byte_t instruction_t
                (bitsleft byte_t op1
                  (bitsleft byte_t ('1'::('0'::('0'::[]))) byte)) (fun imm ->
                Obj.magic instCon false (Reg_op EAX) (Imm_op
                  (zero_extend8_32 (Obj.magic imm)))))
              (alt instruction_t
                (map operand_t instruction_t
                  (bitsleft operand_t op1
                    (bitsleft operand_t ('1'::('0'::('1'::[])))
                      (imm_op opsize_override))) (fun imm ->
                  Obj.magic instCon true (Reg_op EAX) imm))
                (alt instruction_t
                  (map (Pair_t (operand_t, byte_t)) instruction_t
                    (bitsleft (Pair_t (operand_t, byte_t))
                      ('1'::('0'::('0'::('0'::[]))))
                      (bitsleft (Pair_t (operand_t, byte_t))
                        ('0'::('0'::('0'::('0'::[]))))
                        (seq operand_t byte_t (ext_op_modrm op2) byte)))
                    (fun p ->
                    let (op, imm) = Obj.magic p in
                    Obj.magic instCon false op (Imm_op (zero_extend8_32 imm))))
                  (alt instruction_t
                    (map (Pair_t (operand_t, byte_t)) instruction_t
                      (bitsleft (Pair_t (operand_t, byte_t))
                        ('1'::('0'::('0'::('0'::[]))))
                        (bitsleft (Pair_t (operand_t, byte_t))
                          ('0'::('0'::('1'::('1'::[]))))
                          (seq operand_t byte_t (ext_op_modrm op2) byte)))
                      (fun p ->
                      let (op, imm) = Obj.magic p in
                      Obj.magic instCon true op (Imm_op
                        (sign_extend8_32 imm))))
                    (map (Pair_t (operand_t, operand_t)) instruction_t
                      (bitsleft (Pair_t (operand_t, operand_t))
                        ('1'::('0'::('0'::('0'::[]))))
                        (bitsleft (Pair_t (operand_t, operand_t))
                          ('0'::('0'::('0'::('1'::[]))))
                          (seq operand_t operand_t (ext_op_modrm op2)
                            (imm_op opsize_override)))) (fun p ->
                      let (op, imm) = Obj.magic p in
                      Obj.magic instCon true op imm)))))))))
  
  (** val coq_ADC_p : bool -> grammar **)
  
  let coq_ADC_p s =
    logic_or_arith_p s ('0'::('0'::('0'::('1'::('0'::[])))))
      ('0'::('1'::('0'::[]))) (fun x x0 x1 -> ADC (x, x0, x1))
  
  (** val coq_ADD_p : bool -> grammar **)
  
  let coq_ADD_p s =
    logic_or_arith_p s ('0'::('0'::('0'::('0'::('0'::[])))))
      ('0'::('0'::('0'::[]))) (fun x x0 x1 -> ADD (x, x0, x1))
  
  (** val coq_AND_p : bool -> grammar **)
  
  let coq_AND_p s =
    logic_or_arith_p s ('0'::('0'::('1'::('0'::('0'::[])))))
      ('1'::('0'::('0'::[]))) (fun x x0 x1 -> AND (x, x0, x1))
  
  (** val coq_CMP_p : bool -> grammar **)
  
  let coq_CMP_p s =
    logic_or_arith_p s ('0'::('0'::('1'::('1'::('1'::[])))))
      ('1'::('1'::('1'::[]))) (fun x x0 x1 -> CMP (x, x0, x1))
  
  (** val coq_OR_p : bool -> grammar **)
  
  let coq_OR_p s =
    logic_or_arith_p s ('0'::('0'::('0'::('0'::('1'::[])))))
      ('0'::('0'::('1'::[]))) (fun x x0 x1 -> OR (x, x0, x1))
  
  (** val coq_SBB_p : bool -> grammar **)
  
  let coq_SBB_p s =
    logic_or_arith_p s ('0'::('0'::('0'::('1'::('1'::[])))))
      ('0'::('1'::('1'::[]))) (fun x x0 x1 -> SBB (x, x0, x1))
  
  (** val coq_SUB_p : bool -> grammar **)
  
  let coq_SUB_p s =
    logic_or_arith_p s ('0'::('0'::('1'::('0'::('1'::[])))))
      ('1'::('0'::('1'::[]))) (fun x x0 x1 -> SUB (x, x0, x1))
  
  (** val coq_XOR_p : bool -> grammar **)
  
  let coq_XOR_p s =
    logic_or_arith_p s ('0'::('0'::('1'::('1'::('0'::[])))))
      ('1'::('1'::('0'::[]))) (fun x x0 x1 -> XOR (x, x0, x1))
  
  (** val coq_ARPL_p : grammar **)
  
  let coq_ARPL_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('0'::('1'::('1'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('0'::('0'::('1'::('1'::[])))) modrm)) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (ARPL (op1, op2)))
  
  (** val coq_BOUND_p : grammar **)
  
  let coq_BOUND_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('0'::('1'::('1'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('0'::('0'::('1'::('0'::[])))) modrm)) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (BOUND (op1, op2)))
  
  (** val coq_BSF_p : grammar **)
  
  let coq_BSF_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (operand_t, operand_t))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (operand_t, operand_t))
              ('1'::('1'::('0'::('0'::[])))) modrm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (BSF (op1, op2)))
  
  (** val coq_BSR_p : grammar **)
  
  let coq_BSR_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (operand_t, operand_t))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (operand_t, operand_t))
              ('1'::('1'::('0'::('1'::[])))) modrm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (BSR (op1, op2)))
  
  (** val coq_BSWAP_p : grammar **)
  
  let coq_BSWAP_p =
    map register_t instruction_t
      (bitsleft register_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft register_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft register_t ('1'::('1'::('0'::('0'::[]))))
            (bitsleft register_t ('1'::[]) reg)))) (fun x ->
      Obj.magic (BSWAP (Obj.magic x)))
  
  (** val bit_test_p :
      char list -> char list -> (operand -> operand -> instr) -> grammar **)
  
  let bit_test_p opcode1 opcode2 instr0 =
    alt instruction_t
      (map (Pair_t (register_t, byte_t)) instruction_t
        (bitsleft (Pair_t (register_t, byte_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (register_t, byte_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (register_t, byte_t))
              ('1'::('0'::('1'::('1'::[]))))
              (bitsleft (Pair_t (register_t, byte_t))
                ('1'::('0'::('1'::('0'::[]))))
                (bitsleft (Pair_t (register_t, byte_t)) ('1'::('1'::[]))
                  (bitsleft (Pair_t (register_t, byte_t)) opcode1
                    (seq register_t byte_t reg byte))))))) (fun p ->
        let (r2, imm) = Obj.magic p in
        Obj.magic instr0 (Reg_op r2) (Imm_op (zero_extend8_32 imm))))
      (alt instruction_t
        (map (Pair_t (operand_t, byte_t)) instruction_t
          (bitsleft (Pair_t (operand_t, byte_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (operand_t, byte_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (operand_t, byte_t))
                ('1'::('0'::('1'::('1'::[]))))
                (bitsleft (Pair_t (operand_t, byte_t))
                  ('1'::('0'::('1'::('0'::[]))))
                  (seq operand_t byte_t (ext_op_modrm opcode1) byte)))))
          (fun p ->
          let (op1, imm) = Obj.magic p in
          Obj.magic instr0 op1 (Imm_op (zero_extend8_32 imm))))
        (map (Pair_t (operand_t, operand_t)) instruction_t
          (bitsleft (Pair_t (operand_t, operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (operand_t, operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (operand_t, operand_t))
                ('1'::('0'::('1'::[])))
                (bitsleft (Pair_t (operand_t, operand_t)) opcode2
                  (bitsleft (Pair_t (operand_t, operand_t))
                    ('0'::('1'::('1'::[]))) modrm))))) (fun p ->
          let (op2, op1) = Obj.magic p in Obj.magic instr0 op1 op2)))
  
  (** val coq_BT_p : grammar **)
  
  let coq_BT_p =
    bit_test_p ('1'::('0'::('0'::[]))) ('0'::('0'::[])) (fun x x0 -> BT (x,
      x0))
  
  (** val coq_BTC_p : grammar **)
  
  let coq_BTC_p =
    bit_test_p ('1'::('1'::('1'::[]))) ('1'::('1'::[])) (fun x x0 -> BTC (x,
      x0))
  
  (** val coq_BTR_p : grammar **)
  
  let coq_BTR_p =
    bit_test_p ('1'::('1'::('0'::[]))) ('1'::('0'::[])) (fun x x0 -> BTR (x,
      x0))
  
  (** val coq_BTS_p : grammar **)
  
  let coq_BTS_p =
    bit_test_p ('1'::('0'::('1'::[]))) ('0'::('1'::[])) (fun x x0 -> BTS (x,
      x0))
  
  (** val coq_CALL_p : grammar **)
  
  let coq_CALL_p =
    alt instruction_t
      (map word_t instruction_t
        (bitsleft word_t ('1'::('1'::('1'::('0'::[]))))
          (bitsleft word_t ('1'::('0'::('0'::('0'::[])))) word)) (fun w ->
        Obj.magic (CALL (true, false, (Imm_op (Obj.magic w)), None))))
      (alt instruction_t
        (map operand_t instruction_t
          (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
            (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
              (ext_op_modrm2 ('0'::('1'::('0'::[])))))) (fun op ->
          Obj.magic (CALL (true, true, (Obj.magic op), None))))
        (alt instruction_t
          (map (Pair_t (word_t, half_t)) instruction_t
            (bitsleft (Pair_t (word_t, half_t))
              ('1'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (word_t, half_t))
                ('1'::('0'::('1'::('0'::[]))))
                (seq word_t half_t word halfword))) (fun p ->
            Obj.magic (CALL (false, true, (Imm_op (fst (Obj.magic p))), (Some
              (snd (Obj.magic p)))))))
          (map operand_t instruction_t
            (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
              (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
                (ext_op_modrm2 ('0'::('1'::('1'::[])))))) (fun op ->
            Obj.magic (CALL (false, true, (Obj.magic op), None))))))
  
  (** val coq_CDQ_p : grammar **)
  
  let coq_CDQ_p =
    map (bits_n (length0 ('1'::('0'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
        ('1'::('0'::('0'::('1'::[])))) (bits ('1'::('0'::('0'::('1'::[]))))))
      (fun x -> Obj.magic CDQ)
  
  (** val coq_CLC_p : grammar **)
  
  let coq_CLC_p =
    map (bits_n (length0 ('1'::('0'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('1'::('0'::('0'::('0'::[]))))))
      (fun x -> Obj.magic CLC)
  
  (** val coq_CLD_p : grammar **)
  
  let coq_CLD_p =
    map (bits_n (length0 ('1'::('1'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('0'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('1'::('1'::('0'::('0'::[]))))))
      (fun x -> Obj.magic CLD)
  
  (** val coq_CLI_p : grammar **)
  
  let coq_CLI_p =
    map (bits_n (length0 ('1'::('0'::('1'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('0'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('1'::('0'::('1'::('0'::[]))))))
      (fun x -> Obj.magic CLI)
  
  (** val coq_CLTS_p : grammar **)
  
  let coq_CLTS_p =
    map (bits_n (length0 ('0'::('1'::('1'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
            ('0'::('0'::('0'::('0'::[]))))
            (bits ('0'::('1'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic CLTS)
  
  (** val coq_CMC_p : grammar **)
  
  let coq_CMC_p =
    map (bits_n (length0 ('0'::('1'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('1'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('0'::('1'::('0'::('1'::[]))))))
      (fun x -> Obj.magic CMC)
  
  (** val coq_CMPS_p : grammar **)
  
  let coq_CMPS_p =
    map Char_t instruction_t
      (bitsleft Char_t ('1'::('0'::('1'::('0'::[]))))
        (bitsleft Char_t ('0'::('1'::('1'::[]))) anybit)) (fun x ->
      Obj.magic (CMPS (Obj.magic x)))
  
  (** val coq_CMPXCHG_p : grammar **)
  
  let coq_CMPXCHG_p =
    map (Pair_t (Char_t, (Pair_t (operand_t, operand_t)))) instruction_t
      (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
              ('0'::('0'::('0'::[])))
              (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm)))))
      (fun p ->
      let (w, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (CMPXCHG (w, op2, op1)))
  
  (** val coq_CPUID_p : grammar **)
  
  let coq_CPUID_p =
    map (bits_n (length0 ('0'::('0'::('1'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::[]))))))
            ('1'::('0'::('1'::('0'::[]))))
            (bits ('0'::('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic CPUID)
  
  (** val coq_CWDE_p : grammar **)
  
  let coq_CWDE_p =
    map (bits_n (length0 ('1'::('0'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
        ('1'::('0'::('0'::('1'::[])))) (bits ('1'::('0'::('0'::('0'::[]))))))
      (fun x -> Obj.magic CWDE)
  
  (** val coq_DAA_p : grammar **)
  
  let coq_DAA_p =
    map (bits_n (length0 ('0'::('1'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::[]))))))
        ('0'::('0'::('1'::('0'::[])))) (bits ('0'::('1'::('1'::('1'::[]))))))
      (fun x -> Obj.magic DAA)
  
  (** val coq_DAS_p : grammar **)
  
  let coq_DAS_p =
    map (bits_n (length0 ('1'::('1'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::[]))))))
        ('0'::('0'::('1'::('0'::[])))) (bits ('1'::('1'::('1'::('1'::[]))))))
      (fun x -> Obj.magic DAS)
  
  (** val coq_DEC_p : grammar **)
  
  let coq_DEC_p =
    alt instruction_t
      (map (Pair_t (Char_t, register_t)) instruction_t
        (bitsleft (Pair_t (Char_t, register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, register_t)) ('1'::('1'::('1'::[])))
            (seq Char_t register_t anybit
              (bitsleft register_t ('1'::('1'::('0'::('0'::('1'::[]))))) reg))))
        (fun p ->
        let (w, r2) = Obj.magic p in Obj.magic (DEC (w, (Reg_op r2)))))
      (alt instruction_t
        (map register_t instruction_t
          (bitsleft register_t ('0'::('1'::('0'::('0'::[]))))
            (bitsleft register_t ('1'::[]) reg)) (fun r2 ->
          Obj.magic (DEC (true, (Reg_op (Obj.magic r2))))))
        (map (Pair_t (Char_t, operand_t)) instruction_t
          (bitsleft (Pair_t (Char_t, operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (Char_t, operand_t)) ('1'::('1'::('1'::[])))
              (seq Char_t operand_t anybit
                (ext_op_modrm ('0'::('0'::('1'::[]))))))) (fun p ->
          let (w, op1) = Obj.magic p in Obj.magic (DEC (w, op1)))))
  
  (** val coq_DIV_p : grammar **)
  
  let coq_DIV_p =
    alt instruction_t
      (map (Pair_t (Char_t, register_t)) instruction_t
        (bitsleft (Pair_t (Char_t, register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, register_t)) ('0'::('1'::('1'::[])))
            (seq Char_t register_t anybit
              (bitsleft register_t ('1'::('1'::('1'::('1'::('0'::[]))))) reg))))
        (fun p ->
        let (w, r2) = Obj.magic p in Obj.magic (DIV (w, (Reg_op r2)))))
      (map (Pair_t (Char_t, operand_t)) instruction_t
        (bitsleft (Pair_t (Char_t, operand_t)) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, operand_t)) ('0'::('1'::('1'::[])))
            (seq Char_t operand_t anybit
              (ext_op_modrm ('1'::('1'::('0'::[]))))))) (fun p ->
        let (w, op1) = Obj.magic p in Obj.magic (DIV (w, op1))))
  
  (** val coq_HLT_p : grammar **)
  
  let coq_HLT_p =
    map (bits_n (length0 ('0'::('1'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('0'::('1'::('0'::('0'::[]))))))
      (fun x -> Obj.magic HLT)
  
  (** val coq_IDIV_p : grammar **)
  
  let coq_IDIV_p =
    alt instruction_t
      (map (Pair_t (Char_t, register_t)) instruction_t
        (bitsleft (Pair_t (Char_t, register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, register_t)) ('0'::('1'::('1'::[])))
            (seq Char_t register_t anybit
              (bitsleft register_t ('1'::('1'::('1'::('1'::('1'::[]))))) reg))))
        (fun p ->
        let (w, r2) = Obj.magic p in Obj.magic (IDIV (w, (Reg_op r2)))))
      (map (Pair_t (Char_t, operand_t)) instruction_t
        (bitsleft (Pair_t (Char_t, operand_t)) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, operand_t)) ('0'::('1'::('1'::[])))
            (seq Char_t operand_t anybit
              (ext_op_modrm ('1'::('1'::('1'::[]))))))) (fun p ->
        let (w, op1) = Obj.magic p in Obj.magic (IDIV (w, op1))))
  
  (** val coq_IMUL_p : bool -> grammar **)
  
  let coq_IMUL_p opsize_override =
    alt instruction_t
      (map (Pair_t (Char_t, operand_t)) instruction_t
        (bitsleft (Pair_t (Char_t, operand_t)) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, operand_t)) ('0'::('1'::('1'::[])))
            (seq Char_t operand_t anybit
              (ext_op_modrm2 ('1'::('0'::('1'::[]))))))) (fun p ->
        let (w, op1) = Obj.magic p in Obj.magic (IMUL (w, op1, None, None))))
      (alt instruction_t
        (map (Pair_t (operand_t, operand_t)) instruction_t
          (bitsleft (Pair_t (operand_t, operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (operand_t, operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (operand_t, operand_t))
                ('1'::('0'::('1'::('0'::[]))))
                (bitsleft (Pair_t (operand_t, operand_t))
                  ('1'::('1'::('1'::('1'::[])))) modrm)))) (fun p ->
          let (op1, op2) = Obj.magic p in
          Obj.magic (IMUL (false, op1, (Some op2), None))))
        (alt instruction_t
          (map (Pair_t ((Pair_t (operand_t, operand_t)), byte_t))
            instruction_t
            (bitsleft (Pair_t ((Pair_t (operand_t, operand_t)), byte_t))
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t ((Pair_t (operand_t, operand_t)), byte_t))
                ('1'::('0'::('1'::('1'::[]))))
                (seq (Pair_t (operand_t, operand_t)) byte_t modrm byte)))
            (fun p ->
            let (i, imm) = Obj.magic p in
            let (op1, op2) = i in
            Obj.magic (IMUL (true, op1, (Some op2), (Some
              (sign_extend8_32 imm))))))
          (if opsize_override
           then map (Pair_t ((Pair_t (operand_t, operand_t)), half_t))
                  instruction_t
                  (bitsleft (Pair_t ((Pair_t (operand_t, operand_t)),
                    half_t)) ('0'::('1'::('1'::('0'::[]))))
                    (bitsleft (Pair_t ((Pair_t (operand_t, operand_t)),
                      half_t)) ('1'::('0'::('0'::('1'::[]))))
                      (seq (Pair_t (operand_t, operand_t)) half_t modrm
                        halfword))) (fun p ->
                  let (i, imm) = Obj.magic p in
                  let (op1, op2) = i in
                  Obj.magic (IMUL (false, op1, (Some op2), (Some
                    (sign_extend16_32 imm)))))
           else map (Pair_t ((Pair_t (operand_t, operand_t)), word_t))
                  instruction_t
                  (bitsleft (Pair_t ((Pair_t (operand_t, operand_t)),
                    word_t)) ('0'::('1'::('1'::('0'::[]))))
                    (bitsleft (Pair_t ((Pair_t (operand_t, operand_t)),
                      word_t)) ('1'::('0'::('0'::('1'::[]))))
                      (seq (Pair_t (operand_t, operand_t)) word_t modrm word)))
                  (fun p ->
                  let (i, imm) = Obj.magic p in
                  let (op1, op2) = i in
                  Obj.magic (IMUL (true, op1, (Some op2), (Some imm)))))))
  
  (** val coq_IN_p : grammar **)
  
  let coq_IN_p =
    alt instruction_t
      (map (Pair_t (Char_t, byte_t)) instruction_t
        (bitsleft (Pair_t (Char_t, byte_t)) ('1'::('1'::('1'::('0'::[]))))
          (bitsleft (Pair_t (Char_t, byte_t)) ('0'::('1'::('0'::[])))
            (seq Char_t byte_t anybit byte))) (fun p ->
        let (w, pt) = Obj.magic p in Obj.magic (IN (w, (Some pt)))))
      (map Char_t instruction_t
        (bitsleft Char_t ('1'::('1'::('1'::('0'::[]))))
          (bitsleft Char_t ('1'::('1'::('0'::[]))) anybit)) (fun w ->
        Obj.magic (IN ((Obj.magic w), None))))
  
  (** val coq_INC_p : grammar **)
  
  let coq_INC_p =
    alt instruction_t
      (map (Pair_t (Char_t, register_t)) instruction_t
        (bitsleft (Pair_t (Char_t, register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, register_t)) ('1'::('1'::('1'::[])))
            (seq Char_t register_t anybit
              (bitsleft register_t ('1'::('1'::('0'::('0'::('0'::[]))))) reg))))
        (fun p ->
        let (w, r2) = Obj.magic p in Obj.magic (INC (w, (Reg_op r2)))))
      (alt instruction_t
        (map register_t instruction_t
          (bitsleft register_t ('0'::('1'::('0'::('0'::[]))))
            (bitsleft register_t ('0'::[]) reg)) (fun r2 ->
          Obj.magic (INC (true, (Reg_op (Obj.magic r2))))))
        (map (Pair_t (Char_t, operand_t)) instruction_t
          (bitsleft (Pair_t (Char_t, operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (Char_t, operand_t)) ('1'::('1'::('1'::[])))
              (seq Char_t operand_t anybit
                (ext_op_modrm ('0'::('0'::('0'::[]))))))) (fun p ->
          let (w, op1) = Obj.magic p in Obj.magic (INC (w, op1)))))
  
  (** val coq_INS_p : grammar **)
  
  let coq_INS_p =
    map Char_t instruction_t
      (bitsleft Char_t ('0'::('1'::('1'::('0'::[]))))
        (bitsleft Char_t ('1'::('1'::('0'::[]))) anybit)) (fun x ->
      Obj.magic (INS (Obj.magic x)))
  
  (** val coq_INTn_p : grammar **)
  
  let coq_INTn_p =
    map byte_t instruction_t
      (bitsleft byte_t ('1'::('1'::('0'::('0'::[]))))
        (bitsleft byte_t ('1'::('1'::('0'::('1'::[])))) byte)) (fun x ->
      Obj.magic (INTn (Obj.magic x)))
  
  (** val coq_INT_p : grammar **)
  
  let coq_INT_p =
    map (bits_n (length0 ('1'::('1'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('0'::[]))))))
        ('1'::('1'::('0'::('0'::[])))) (bits ('1'::('1'::('0'::('0'::[]))))))
      (fun x -> Obj.magic INT)
  
  (** val coq_INTO_p : grammar **)
  
  let coq_INTO_p =
    map (bits_n (length0 ('1'::('1'::('1'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::[]))))))
        ('1'::('1'::('0'::('0'::[])))) (bits ('1'::('1'::('1'::('0'::[]))))))
      (fun x -> Obj.magic INTO)
  
  (** val coq_INVD_p : grammar **)
  
  let coq_INVD_p =
    map (bits_n (length0 ('1'::('0'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
            ('0'::('0'::('0'::('0'::[]))))
            (bits ('1'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic INVD)
  
  (** val coq_INVLPG_p : grammar **)
  
  let coq_INVLPG_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm ('1'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic (INVLPG (Obj.magic x)))
  
  (** val coq_IRET_p : grammar **)
  
  let coq_IRET_p =
    map (bits_n (length0 ('1'::('1'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::[]))))))
        ('1'::('1'::('0'::('0'::[])))) (bits ('1'::('1'::('1'::('1'::[]))))))
      (fun x -> Obj.magic IRET)
  
  (** val coq_Jcc_p : grammar **)
  
  let coq_Jcc_p =
    alt instruction_t
      (map (Pair_t (condition_t, byte_t)) instruction_t
        (bitsleft (Pair_t (condition_t, byte_t))
          ('0'::('1'::('1'::('1'::[])))) (seq condition_t byte_t tttn byte))
        (fun p ->
        let (ct, imm) = Obj.magic p in
        Obj.magic (Jcc (ct, (sign_extend8_32 imm)))))
      (map (Pair_t (condition_t, word_t)) instruction_t
        (bitsleft (Pair_t (condition_t, word_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (condition_t, word_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (condition_t, word_t))
              ('1'::('0'::('0'::('0'::[]))))
              (seq condition_t word_t tttn word)))) (fun p ->
        let (ct, imm) = Obj.magic p in Obj.magic (Jcc (ct, imm))))
  
  (** val coq_JCXZ_p : grammar **)
  
  let coq_JCXZ_p =
    map byte_t instruction_t
      (bitsleft byte_t ('1'::('1'::('1'::('0'::[]))))
        (bitsleft byte_t ('0'::('0'::('1'::('1'::[])))) byte)) (fun x ->
      Obj.magic (JCXZ (Obj.magic x)))
  
  (** val coq_JMP_p : grammar **)
  
  let coq_JMP_p =
    alt instruction_t
      (map byte_t instruction_t
        (bitsleft byte_t ('1'::('1'::('1'::('0'::[]))))
          (bitsleft byte_t ('1'::('0'::('1'::('1'::[])))) byte)) (fun b ->
        Obj.magic (JMP (true, false, (Imm_op
          (sign_extend8_32 (Obj.magic b))), None))))
      (alt instruction_t
        (map word_t instruction_t
          (bitsleft word_t ('1'::('1'::('1'::('0'::[]))))
            (bitsleft word_t ('1'::('0'::('0'::('1'::[])))) word)) (fun w ->
          Obj.magic (JMP (true, false, (Imm_op (Obj.magic w)), None))))
        (alt instruction_t
          (map operand_t instruction_t
            (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
              (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
                (ext_op_modrm2 ('1'::('0'::('0'::[])))))) (fun op ->
            Obj.magic (JMP (true, true, (Obj.magic op), None))))
          (alt instruction_t
            (map (Pair_t (word_t, half_t)) instruction_t
              (bitsleft (Pair_t (word_t, half_t))
                ('1'::('1'::('1'::('0'::[]))))
                (bitsleft (Pair_t (word_t, half_t))
                  ('1'::('0'::('1'::('0'::[]))))
                  (seq word_t half_t word halfword))) (fun p ->
              Obj.magic (JMP (false, true, (Imm_op (fst (Obj.magic p))),
                (Some (snd (Obj.magic p)))))))
            (map operand_t instruction_t
              (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
                (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
                  (ext_op_modrm2 ('1'::('0'::('1'::[])))))) (fun op ->
              Obj.magic (JMP (false, true, (Obj.magic op), None)))))))
  
  (** val coq_LAHF_p : grammar **)
  
  let coq_LAHF_p =
    map (bits_n (length0 ('1'::('1'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::[]))))))
        ('1'::('0'::('0'::('1'::[])))) (bits ('1'::('1'::('1'::('1'::[]))))))
      (fun x -> Obj.magic LAHF)
  
  (** val coq_LAR_p : grammar **)
  
  let coq_LAR_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (operand_t, operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (operand_t, operand_t))
              ('0'::('0'::('1'::('0'::[])))) modrm)))) (fun p ->
      Obj.magic (LAR ((fst (Obj.magic p)), (snd (Obj.magic p)))))
  
  (** val coq_LDS_p : grammar **)
  
  let coq_LDS_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('1'::('1'::('0'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('0'::('1'::('0'::('1'::[])))) modrm)) (fun p ->
      Obj.magic (LDS ((fst (Obj.magic p)), (snd (Obj.magic p)))))
  
  (** val coq_LEA_p : grammar **)
  
  let coq_LEA_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('1'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('1'::('1'::('0'::('1'::[])))) modrm)) (fun p ->
      Obj.magic (LEA ((fst (Obj.magic p)), (snd (Obj.magic p)))))
  
  (** val coq_LEAVE_p : grammar **)
  
  let coq_LEAVE_p =
    map (bits_n (length0 ('1'::('0'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
        ('1'::('1'::('0'::('0'::[])))) (bits ('1'::('0'::('0'::('1'::[]))))))
      (fun x -> Obj.magic LEAVE)
  
  (** val coq_LES_p : grammar **)
  
  let coq_LES_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('1'::('1'::('0'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('0'::('1'::('0'::('0'::[])))) modrm)) (fun p ->
      Obj.magic (LES ((fst (Obj.magic p)), (snd (Obj.magic p)))))
  
  (** val coq_LFS_p : grammar **)
  
  let coq_LFS_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (operand_t, operand_t))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (operand_t, operand_t))
              ('0'::('1'::('0'::('0'::[])))) modrm)))) (fun p ->
      Obj.magic (LFS ((fst (Obj.magic p)), (snd (Obj.magic p)))))
  
  (** val coq_LGDT_p : grammar **)
  
  let coq_LGDT_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm ('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic (LGDT (Obj.magic x)))
  
  (** val coq_LGS_p : grammar **)
  
  let coq_LGS_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (operand_t, operand_t))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (operand_t, operand_t))
              ('0'::('1'::('0'::('1'::[])))) modrm)))) (fun p ->
      Obj.magic (LGS ((fst (Obj.magic p)), (snd (Obj.magic p)))))
  
  (** val coq_LIDT_p : grammar **)
  
  let coq_LIDT_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm ('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic (LIDT (Obj.magic x)))
  
  (** val coq_LLDT_p : grammar **)
  
  let coq_LLDT_p =
    alt instruction_t
      (map register_t instruction_t
        (bitsleft register_t ('0'::('0'::('0'::('0'::[]))))
          (bitsleft register_t ('1'::('1'::('1'::('1'::[]))))
            (bitsleft register_t ('0'::('0'::('0'::('0'::[]))))
              (bitsleft register_t ('0'::('0'::('0'::('0'::[]))))
                (bitsleft register_t ('1'::('1'::[]))
                  (bitsleft register_t ('0'::('1'::('0'::[]))) reg))))))
        (fun r2 -> Obj.magic (LLDT (Reg_op (Obj.magic r2)))))
      (map operand_t instruction_t
        (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
          (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
              (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
                (ext_op_modrm ('0'::('1'::('0'::[])))))))) (fun x ->
        Obj.magic (LLDT (Obj.magic x))))
  
  (** val coq_LMSW_p : grammar **)
  
  let coq_LMSW_p =
    alt instruction_t
      (map register_t instruction_t
        (bitsleft register_t ('0'::('0'::('0'::('0'::[]))))
          (bitsleft register_t ('1'::('1'::('1'::('1'::[]))))
            (bitsleft register_t ('0'::('0'::('0'::('0'::[]))))
              (bitsleft register_t ('0'::('0'::('0'::('1'::[]))))
                (bitsleft register_t ('1'::('1'::[]))
                  (bitsleft register_t ('1'::('1'::('0'::[]))) reg))))))
        (fun r2 -> Obj.magic (LMSW (Reg_op (Obj.magic r2)))))
      (map operand_t instruction_t
        (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
          (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
              (bitsleft operand_t ('0'::('0'::('0'::('1'::[]))))
                (bitsleft operand_t ('1'::('1'::[]))
                  (ext_op_modrm ('1'::('1'::('0'::[]))))))))) (fun x ->
        Obj.magic (LMSW (Obj.magic x))))
  
  (** val coq_LODS_p : grammar **)
  
  let coq_LODS_p =
    map Char_t instruction_t
      (bitsleft Char_t ('1'::('0'::('1'::('0'::[]))))
        (bitsleft Char_t ('1'::('1'::('0'::[]))) anybit)) (fun x ->
      Obj.magic (LODS (Obj.magic x)))
  
  (** val coq_LOOP_p : grammar **)
  
  let coq_LOOP_p =
    map byte_t instruction_t
      (bitsleft byte_t ('1'::('1'::('1'::('0'::[]))))
        (bitsleft byte_t ('0'::('0'::('1'::('0'::[])))) byte)) (fun x ->
      Obj.magic (LOOP (Obj.magic x)))
  
  (** val coq_LOOPZ_p : grammar **)
  
  let coq_LOOPZ_p =
    map byte_t instruction_t
      (bitsleft byte_t ('1'::('1'::('1'::('0'::[]))))
        (bitsleft byte_t ('0'::('0'::('0'::('1'::[])))) byte)) (fun x ->
      Obj.magic (LOOPZ (Obj.magic x)))
  
  (** val coq_LOOPNZ_p : grammar **)
  
  let coq_LOOPNZ_p =
    map byte_t instruction_t
      (bitsleft byte_t ('1'::('1'::('1'::('0'::[]))))
        (bitsleft byte_t ('0'::('0'::('0'::('0'::[])))) byte)) (fun x ->
      Obj.magic (LOOPNZ (Obj.magic x)))
  
  (** val coq_LSL_p : grammar **)
  
  let coq_LSL_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (operand_t, operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (operand_t, operand_t))
              ('0'::('0'::('1'::('1'::[])))) modrm)))) (fun p ->
      Obj.magic (LSL ((fst (Obj.magic p)), (snd (Obj.magic p)))))
  
  (** val coq_LSS_p : grammar **)
  
  let coq_LSS_p =
    map (Pair_t (operand_t, operand_t)) instruction_t
      (bitsleft (Pair_t (operand_t, operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (operand_t, operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (operand_t, operand_t))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (operand_t, operand_t))
              ('0'::('0'::('1'::('0'::[])))) modrm)))) (fun p ->
      Obj.magic (LSS ((fst (Obj.magic p)), (snd (Obj.magic p)))))
  
  (** val coq_LTR_p : grammar **)
  
  let coq_LTR_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
              (ext_op_modrm2 ('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic (LTR (Obj.magic x)))
  
  (** val coq_CMOVcc_p : grammar **)
  
  let coq_CMOVcc_p =
    map (Pair_t (condition_t, (Pair_t (operand_t, operand_t)))) instruction_t
      (bitsleft (Pair_t (condition_t, (Pair_t (operand_t, operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (condition_t, (Pair_t (operand_t, operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (condition_t, (Pair_t (operand_t, operand_t))))
            ('0'::('1'::('0'::('0'::[]))))
            (seq condition_t (Pair_t (operand_t, operand_t)) tttn modrm))))
      (fun p ->
      let (tttn0, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (CMOVcc (tttn0, op1, op2)))
  
  (** val coq_MOV_p : bool -> grammar **)
  
  let coq_MOV_p opsize_override =
    alt instruction_t
      (map (Pair_t (Char_t, (Pair_t (operand_t, operand_t)))) instruction_t
        (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
          ('1'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
            ('1'::('0'::('1'::[])))
            (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm)))
        (fun p ->
        let (w, i) = Obj.magic p in
        let (op1, op2) = i in Obj.magic (MOV (w, op1, op2))))
      (alt instruction_t
        (map (Pair_t (Char_t, (Pair_t (operand_t, operand_t)))) instruction_t
          (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
            ('1'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
              ('1'::('0'::('0'::[])))
              (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm)))
          (fun p ->
          let (w, i) = Obj.magic p in
          let (op1, op2) = i in Obj.magic (MOV (w, op2, op1))))
        (alt instruction_t
          (map (Pair_t (register_t, operand_t)) instruction_t
            (bitsleft (Pair_t (register_t, operand_t))
              ('1'::('1'::('0'::('0'::[]))))
              (bitsleft (Pair_t (register_t, operand_t))
                ('0'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (register_t, operand_t)) ('1'::('1'::[]))
                  (bitsleft (Pair_t (register_t, operand_t))
                    ('0'::('0'::('0'::[])))
                    (seq register_t operand_t reg (imm_op opsize_override))))))
            (fun p ->
            let (r2, w) = Obj.magic p in
            Obj.magic (MOV (true, (Reg_op r2), w))))
          (alt instruction_t
            (map (Pair_t (register_t, byte_t)) instruction_t
              (bitsleft (Pair_t (register_t, byte_t))
                ('1'::('1'::('0'::('0'::[]))))
                (bitsleft (Pair_t (register_t, byte_t))
                  ('0'::('1'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (register_t, byte_t)) ('1'::('1'::[]))
                    (bitsleft (Pair_t (register_t, byte_t))
                      ('0'::('0'::('0'::[])))
                      (seq register_t byte_t reg byte))))) (fun p ->
              let (r2, b) = Obj.magic p in
              Obj.magic (MOV (false, (Reg_op r2), (Imm_op
                (zero_extend8_32 b))))))
            (alt instruction_t
              (map (Pair_t (register_t, operand_t)) instruction_t
                (bitsleft (Pair_t (register_t, operand_t))
                  ('1'::('0'::('1'::('1'::[]))))
                  (bitsleft (Pair_t (register_t, operand_t)) ('1'::[])
                    (seq register_t operand_t reg (imm_op opsize_override))))
                (fun p ->
                let (r2, w) = Obj.magic p in
                Obj.magic (MOV (true, (Reg_op r2), w))))
              (alt instruction_t
                (map (Pair_t (register_t, byte_t)) instruction_t
                  (bitsleft (Pair_t (register_t, byte_t))
                    ('1'::('0'::('1'::('1'::[]))))
                    (bitsleft (Pair_t (register_t, byte_t)) ('0'::[])
                      (seq register_t byte_t reg byte))) (fun p ->
                  let (r2, b) = Obj.magic p in
                  Obj.magic (MOV (false, (Reg_op r2), (Imm_op
                    (zero_extend8_32 b))))))
                (alt instruction_t
                  (map (Pair_t (operand_t, operand_t)) instruction_t
                    (bitsleft (Pair_t (operand_t, operand_t))
                      ('1'::('1'::('0'::('0'::[]))))
                      (bitsleft (Pair_t (operand_t, operand_t))
                        ('0'::('1'::('1'::('1'::[]))))
                        (seq operand_t operand_t
                          (ext_op_modrm ('0'::('0'::('0'::[]))))
                          (imm_op opsize_override)))) (fun p ->
                    let (op, w) = Obj.magic p in
                    Obj.magic (MOV (true, op, w))))
                  (alt instruction_t
                    (map (Pair_t (operand_t, byte_t)) instruction_t
                      (bitsleft (Pair_t (operand_t, byte_t))
                        ('1'::('1'::('0'::('0'::[]))))
                        (bitsleft (Pair_t (operand_t, byte_t))
                          ('0'::('1'::('1'::('0'::[]))))
                          (seq operand_t byte_t
                            (ext_op_modrm ('0'::('0'::('0'::[])))) byte)))
                      (fun p ->
                      let (op, b) = Obj.magic p in
                      Obj.magic (MOV (false, op, (Imm_op
                        (zero_extend8_32 b))))))
                    (alt instruction_t
                      (map word_t instruction_t
                        (bitsleft word_t ('1'::('0'::('1'::('0'::[]))))
                          (bitsleft word_t ('0'::('0'::('0'::('1'::[]))))
                            word)) (fun w ->
                        Obj.magic (MOV (true, (Reg_op EAX), (Offset_op
                          (Obj.magic w))))))
                      (alt instruction_t
                        (map word_t instruction_t
                          (bitsleft word_t ('1'::('0'::('1'::('0'::[]))))
                            (bitsleft word_t ('0'::('0'::('0'::('0'::[]))))
                              word)) (fun w ->
                          Obj.magic (MOV (false, (Reg_op EAX), (Offset_op
                            (Obj.magic w))))))
                        (alt instruction_t
                          (map word_t instruction_t
                            (bitsleft word_t ('1'::('0'::('1'::('0'::[]))))
                              (bitsleft word_t ('0'::('0'::('1'::('1'::[]))))
                                word)) (fun w ->
                            Obj.magic (MOV (true, (Offset_op (Obj.magic w)),
                              (Reg_op EAX)))))
                          (map word_t instruction_t
                            (bitsleft word_t ('1'::('0'::('1'::('0'::[]))))
                              (bitsleft word_t ('0'::('0'::('1'::('0'::[]))))
                                word)) (fun w ->
                            Obj.magic (MOV (false, (Offset_op (Obj.magic w)),
                              (Reg_op EAX)))))))))))))))
  
  (** val control_reg_p : grammar **)
  
  let control_reg_p =
    alt control_register_t
      (map (bits_n (length0 ('0'::('0'::('0'::[]))))) control_register_t
        (bits ('0'::('0'::('0'::[])))) (fun x -> Obj.magic CR0))
      (alt control_register_t
        (map (bits_n (length0 ('0'::('1'::('0'::[]))))) control_register_t
          (bits ('0'::('1'::('0'::[])))) (fun x -> Obj.magic CR2))
        (alt control_register_t
          (map (bits_n (length0 ('0'::('1'::('1'::[]))))) control_register_t
            (bits ('0'::('1'::('1'::[])))) (fun x -> Obj.magic CR3))
          (map (bits_n (length0 ('1'::('0'::('0'::[]))))) control_register_t
            (bits ('1'::('0'::('0'::[])))) (fun x -> Obj.magic CR4))))
  
  (** val coq_MOVCR_p : grammar **)
  
  let coq_MOVCR_p =
    alt instruction_t
      (map (Pair_t (control_register_t, register_t)) instruction_t
        (bitsleft (Pair_t (control_register_t, register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (control_register_t, register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (control_register_t, register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (control_register_t, register_t))
                ('0'::('0'::('1'::('0'::[]))))
                (bitsleft (Pair_t (control_register_t, register_t))
                  ('1'::('1'::[]))
                  (seq control_register_t register_t control_reg_p reg))))))
        (fun p ->
        Obj.magic (MOVCR (true, (fst (Obj.magic p)), (snd (Obj.magic p))))))
      (map (Pair_t (control_register_t, register_t)) instruction_t
        (bitsleft (Pair_t (control_register_t, register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (control_register_t, register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (control_register_t, register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (control_register_t, register_t))
                ('0'::('0'::('0'::('0'::[]))))
                (bitsleft (Pair_t (control_register_t, register_t))
                  ('1'::('1'::[]))
                  (seq control_register_t register_t control_reg_p reg))))))
        (fun p ->
        Obj.magic (MOVCR (false, (fst (Obj.magic p)), (snd (Obj.magic p))))))
  
  (** val debug_reg_p : grammar **)
  
  let debug_reg_p =
    alt debug_register_t
      (map (bits_n (length0 ('0'::('0'::('0'::[]))))) debug_register_t
        (bits ('0'::('0'::('0'::[])))) (fun x -> Obj.magic DR0))
      (alt debug_register_t
        (map (bits_n (length0 ('0'::('0'::('1'::[]))))) debug_register_t
          (bits ('0'::('0'::('1'::[])))) (fun x -> Obj.magic DR1))
        (alt debug_register_t
          (map (bits_n (length0 ('0'::('1'::('0'::[]))))) debug_register_t
            (bits ('0'::('1'::('0'::[])))) (fun x -> Obj.magic DR2))
          (alt debug_register_t
            (map (bits_n (length0 ('0'::('1'::('1'::[]))))) debug_register_t
              (bits ('0'::('1'::('1'::[])))) (fun x -> Obj.magic DR3))
            (alt debug_register_t
              (map (bits_n (length0 ('1'::('1'::('0'::[])))))
                debug_register_t (bits ('1'::('1'::('0'::[])))) (fun x ->
                Obj.magic DR6))
              (map (bits_n (length0 ('1'::('1'::('1'::[])))))
                debug_register_t (bits ('1'::('1'::('1'::[])))) (fun x ->
                Obj.magic DR7))))))
  
  (** val coq_MOVDR_p : grammar **)
  
  let coq_MOVDR_p =
    alt instruction_t
      (map (Pair_t (debug_register_t, register_t)) instruction_t
        (bitsleft (Pair_t (debug_register_t, register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (debug_register_t, register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (debug_register_t, register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (debug_register_t, register_t))
                ('0'::('0'::('1'::('1'::[]))))
                (bitsleft (Pair_t (debug_register_t, register_t))
                  ('1'::('1'::[]))
                  (seq debug_register_t register_t debug_reg_p reg))))))
        (fun p ->
        Obj.magic (MOVDR (true, (fst (Obj.magic p)), (snd (Obj.magic p))))))
      (map (Pair_t (debug_register_t, register_t)) instruction_t
        (bitsleft (Pair_t (debug_register_t, register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (debug_register_t, register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (debug_register_t, register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (debug_register_t, register_t))
                ('0'::('0'::('0'::('1'::[]))))
                (bitsleft (Pair_t (debug_register_t, register_t))
                  ('1'::('1'::[]))
                  (seq debug_register_t register_t debug_reg_p reg))))))
        (fun p ->
        Obj.magic (MOVDR (false, (fst (Obj.magic p)), (snd (Obj.magic p))))))
  
  (** val segment_reg_p : grammar **)
  
  let segment_reg_p =
    alt segment_register_t
      (map (bits_n (length0 ('0'::('0'::('0'::[]))))) segment_register_t
        (bits ('0'::('0'::('0'::[])))) (fun x -> Obj.magic ES))
      (alt segment_register_t
        (map (bits_n (length0 ('0'::('0'::('1'::[]))))) segment_register_t
          (bits ('0'::('0'::('1'::[])))) (fun x -> Obj.magic CS))
        (alt segment_register_t
          (map (bits_n (length0 ('0'::('1'::('0'::[]))))) segment_register_t
            (bits ('0'::('1'::('0'::[])))) (fun x -> Obj.magic SS))
          (alt segment_register_t
            (map (bits_n (length0 ('0'::('1'::('1'::[])))))
              segment_register_t (bits ('0'::('1'::('1'::[])))) (fun x ->
              Obj.magic DS))
            (alt segment_register_t
              (map (bits_n (length0 ('1'::('0'::('0'::[])))))
                segment_register_t (bits ('1'::('0'::('0'::[])))) (fun x ->
                Obj.magic FS))
              (map (bits_n (length0 ('1'::('0'::('1'::[])))))
                segment_register_t (bits ('1'::('0'::('1'::[])))) (fun x ->
                Obj.magic GS))))))
  
  (** val seg_modrm : grammar **)
  
  let seg_modrm =
    alt (Pair_t (segment_register_t, operand_t))
      (map (Pair_t (segment_register_t, address_t)) (Pair_t
        (segment_register_t, operand_t))
        (alt (Pair_t (segment_register_t, address_t))
          (bitsleft (Pair_t (segment_register_t, address_t)) ('0'::('0'::[]))
            (seq segment_register_t address_t segment_reg_p rm00))
          (alt (Pair_t (segment_register_t, address_t))
            (bitsleft (Pair_t (segment_register_t, address_t))
              ('0'::('1'::[]))
              (seq segment_register_t address_t segment_reg_p rm01))
            (bitsleft (Pair_t (segment_register_t, address_t))
              ('1'::('0'::[]))
              (seq segment_register_t address_t segment_reg_p rm10))))
        (fun p ->
        let (sr, addr) = Obj.magic p in Obj.magic (sr, (Address_op addr))))
      (bitsleft (Pair_t (segment_register_t, operand_t)) ('1'::('1'::[]))
        (seq segment_register_t operand_t segment_reg_p reg_op))
  
  (** val coq_MOVSR_p : grammar **)
  
  let coq_MOVSR_p =
    alt instruction_t
      (map (Pair_t (segment_register_t, operand_t)) instruction_t
        (bitsleft (Pair_t (segment_register_t, operand_t))
          ('1'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (segment_register_t, operand_t))
            ('1'::('1'::('1'::('0'::[])))) seg_modrm)) (fun p ->
        Obj.magic (MOVSR (true, (fst (Obj.magic p)), (snd (Obj.magic p))))))
      (map (Pair_t (segment_register_t, operand_t)) instruction_t
        (bitsleft (Pair_t (segment_register_t, operand_t))
          ('1'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (segment_register_t, operand_t))
            ('1'::('1'::('0'::('0'::[])))) seg_modrm)) (fun p ->
        Obj.magic (MOVSR (false, (fst (Obj.magic p)), (snd (Obj.magic p))))))
  
  (** val coq_MOVBE_p : grammar **)
  
  let coq_MOVBE_p =
    alt instruction_t
      (map (Pair_t (operand_t, operand_t)) instruction_t
        (bitsleft (Pair_t (operand_t, operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (operand_t, operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (operand_t, operand_t))
              ('0'::('0'::('1'::('1'::[]))))
              (bitsleft (Pair_t (operand_t, operand_t))
                ('1'::('0'::('0'::('0'::[]))))
                (bitsleft (Pair_t (operand_t, operand_t))
                  ('1'::('1'::('1'::('1'::[]))))
                  (bitsleft (Pair_t (operand_t, operand_t))
                    ('0'::('0'::('0'::('1'::[])))) modrm)))))) (fun p ->
        Obj.magic (MOVBE ((snd (Obj.magic p)), (fst (Obj.magic p))))))
      (map (Pair_t (operand_t, operand_t)) instruction_t
        (bitsleft (Pair_t (operand_t, operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (operand_t, operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (operand_t, operand_t))
              ('0'::('0'::('1'::('1'::[]))))
              (bitsleft (Pair_t (operand_t, operand_t))
                ('1'::('0'::('0'::('0'::[]))))
                (bitsleft (Pair_t (operand_t, operand_t))
                  ('1'::('1'::('1'::('1'::[]))))
                  (bitsleft (Pair_t (operand_t, operand_t))
                    ('0'::('0'::('0'::('0'::[])))) modrm)))))) (fun p ->
        Obj.magic (MOVBE ((fst (Obj.magic p)), (snd (Obj.magic p))))))
  
  (** val coq_MOVS_p : grammar **)
  
  let coq_MOVS_p =
    map Char_t instruction_t
      (bitsleft Char_t ('1'::('0'::('1'::('0'::[]))))
        (bitsleft Char_t ('0'::('1'::('0'::[]))) anybit)) (fun x ->
      Obj.magic (MOVS (Obj.magic x)))
  
  (** val coq_MOVSX_p : grammar **)
  
  let coq_MOVSX_p =
    map (Pair_t (Char_t, (Pair_t (operand_t, operand_t)))) instruction_t
      (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
              ('1'::('1'::('1'::[])))
              (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm)))))
      (fun p ->
      let (w, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (MOVSX (w, op1, op2)))
  
  (** val coq_MOVZX_p : grammar **)
  
  let coq_MOVZX_p =
    map (Pair_t (Char_t, (Pair_t (operand_t, operand_t)))) instruction_t
      (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
            ('1'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
              ('0'::('1'::('1'::[])))
              (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm)))))
      (fun p ->
      let (w, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (MOVZX (w, op1, op2)))
  
  (** val coq_MUL_p : grammar **)
  
  let coq_MUL_p =
    map (Pair_t (Char_t, operand_t)) instruction_t
      (bitsleft (Pair_t (Char_t, operand_t)) ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (Char_t, operand_t)) ('0'::('1'::('1'::[])))
          (seq Char_t operand_t anybit
            (ext_op_modrm2 ('1'::('0'::('0'::[]))))))) (fun p ->
      Obj.magic (MUL ((fst (Obj.magic p)), (snd (Obj.magic p)))))
  
  (** val coq_NEG_p : grammar **)
  
  let coq_NEG_p =
    map (Pair_t (Char_t, operand_t)) instruction_t
      (bitsleft (Pair_t (Char_t, operand_t)) ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (Char_t, operand_t)) ('0'::('1'::('1'::[])))
          (seq Char_t operand_t anybit
            (ext_op_modrm2 ('0'::('1'::('1'::[]))))))) (fun p ->
      Obj.magic (NEG ((fst (Obj.magic p)), (snd (Obj.magic p)))))
  
  (** val coq_NOP_p : grammar **)
  
  let coq_NOP_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('1'::[]))))
            (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
              (ext_op_modrm2 ('0'::('0'::('0'::[])))))))) (fun op ->
      Obj.magic (NOP (Obj.magic op)))
  
  (** val coq_NOT_p : grammar **)
  
  let coq_NOT_p =
    map (Pair_t (Char_t, operand_t)) instruction_t
      (bitsleft (Pair_t (Char_t, operand_t)) ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (Char_t, operand_t)) ('0'::('1'::('1'::[])))
          (seq Char_t operand_t anybit
            (ext_op_modrm2 ('0'::('1'::('0'::[]))))))) (fun p ->
      Obj.magic (NOT ((fst (Obj.magic p)), (snd (Obj.magic p)))))
  
  (** val coq_OUT_p : grammar **)
  
  let coq_OUT_p =
    alt instruction_t
      (map (Pair_t (Char_t, byte_t)) instruction_t
        (bitsleft (Pair_t (Char_t, byte_t)) ('1'::('1'::('1'::('0'::[]))))
          (bitsleft (Pair_t (Char_t, byte_t)) ('0'::('1'::('1'::[])))
            (seq Char_t byte_t anybit byte))) (fun p ->
        Obj.magic (OUT ((fst (Obj.magic p)), (Some (snd (Obj.magic p)))))))
      (map Char_t instruction_t
        (bitsleft Char_t ('1'::('1'::('1'::('0'::[]))))
          (bitsleft Char_t ('1'::('1'::('1'::[]))) anybit)) (fun w ->
        Obj.magic (OUT ((Obj.magic w), None))))
  
  (** val coq_OUTS_p : grammar **)
  
  let coq_OUTS_p =
    map Char_t instruction_t
      (bitsleft Char_t ('0'::('1'::('1'::('0'::[]))))
        (bitsleft Char_t ('1'::('1'::('1'::[]))) anybit)) (fun x ->
      Obj.magic (OUTS (Obj.magic x)))
  
  (** val coq_POP_p : grammar **)
  
  let coq_POP_p =
    alt instruction_t
      (map operand_t instruction_t
        (bitsleft operand_t ('1'::('0'::('0'::('0'::[]))))
          (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
            (ext_op_modrm2 ('0'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (POP (Obj.magic x))))
      (map register_t instruction_t
        (bitsleft register_t ('0'::('1'::('0'::('1'::[]))))
          (bitsleft register_t ('1'::[]) reg)) (fun r2 ->
        Obj.magic (POP (Reg_op (Obj.magic r2)))))
  
  (** val coq_POPSR_p : grammar **)
  
  let coq_POPSR_p =
    alt instruction_t
      (map (bits_n (length0 ('1'::('1'::('1'::[]))))) instruction_t
        (bitsleft (bits_n (length0 ('1'::('1'::('1'::[])))))
          ('0'::('0'::('0'::[])))
          (bitsleft (bits_n (length0 ('1'::('1'::('1'::[])))))
            ('0'::('0'::[])) (bits ('1'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (POPSR ES)))
      (alt instruction_t
        (map (bits_n (length0 ('1'::('1'::('1'::[]))))) instruction_t
          (bitsleft (bits_n (length0 ('1'::('1'::('1'::[])))))
            ('0'::('0'::('0'::[])))
            (bitsleft (bits_n (length0 ('1'::('1'::('1'::[])))))
              ('1'::('0'::[])) (bits ('1'::('1'::('1'::[])))))) (fun x ->
          Obj.magic (POPSR SS)))
        (alt instruction_t
          (map (bits_n (length0 ('1'::('1'::('1'::[]))))) instruction_t
            (bitsleft (bits_n (length0 ('1'::('1'::('1'::[])))))
              ('0'::('0'::('0'::[])))
              (bitsleft (bits_n (length0 ('1'::('1'::('1'::[])))))
                ('1'::('1'::[])) (bits ('1'::('1'::('1'::[])))))) (fun x ->
            Obj.magic (POPSR DS)))
          (alt instruction_t
            (map (bits_n (length0 ('0'::('0'::('1'::[]))))) instruction_t
              (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
                ('0'::('0'::('0'::('0'::[]))))
                (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
                  ('1'::('1'::('1'::('1'::[]))))
                  (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
                    ('1'::('0'::[]))
                    (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
                      ('1'::('0'::('0'::[]))) (bits ('0'::('0'::('1'::[]))))))))
              (fun x -> Obj.magic (POPSR FS)))
            (map (bits_n (length0 ('0'::('0'::('1'::[]))))) instruction_t
              (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
                ('0'::('0'::('0'::('0'::[]))))
                (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
                  ('1'::('1'::('1'::('1'::[]))))
                  (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
                    ('1'::('0'::[]))
                    (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
                      ('1'::('0'::('1'::[]))) (bits ('0'::('0'::('1'::[]))))))))
              (fun x -> Obj.magic (POPSR GS))))))
  
  (** val coq_POPA_p : grammar **)
  
  let coq_POPA_p =
    map (bits_n (length0 ('0'::('0'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::[]))))))
        ('0'::('1'::('1'::('0'::[])))) (bits ('0'::('0'::('0'::('1'::[]))))))
      (fun x -> Obj.magic POPA)
  
  (** val coq_POPF_p : grammar **)
  
  let coq_POPF_p =
    map (bits_n (length0 ('1'::('1'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('1'::[]))))))
        ('1'::('0'::('0'::('1'::[])))) (bits ('1'::('1'::('0'::('1'::[]))))))
      (fun x -> Obj.magic POPF)
  
  (** val coq_PUSH_p : grammar **)
  
  let coq_PUSH_p =
    alt instruction_t
      (map operand_t instruction_t
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
            (ext_op_modrm ('1'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (PUSH (true, (Obj.magic x)))))
      (alt instruction_t
        (map register_t instruction_t
          (bitsleft register_t ('0'::('1'::('0'::('1'::[]))))
            (bitsleft register_t ('0'::[]) reg)) (fun r2 ->
          Obj.magic (PUSH (true, (Reg_op (Obj.magic r2))))))
        (alt instruction_t
          (map byte_t instruction_t
            (bitsleft byte_t ('0'::('1'::('1'::('0'::[]))))
              (bitsleft byte_t ('1'::('0'::('1'::('0'::[])))) byte))
            (fun b ->
            Obj.magic (PUSH (false, (Imm_op
              (sign_extend8_32 (Obj.magic b)))))))
          (map word_t instruction_t
            (bitsleft word_t ('0'::('1'::('1'::('0'::[]))))
              (bitsleft word_t ('1'::('0'::('0'::('0'::[])))) word))
            (fun w -> Obj.magic (PUSH (true, (Imm_op (Obj.magic w))))))))
  
  (** val segment_reg2_p : grammar **)
  
  let segment_reg2_p =
    alt segment_register_t
      (map (bits_n (length0 ('0'::('0'::[])))) segment_register_t
        (bits ('0'::('0'::[]))) (fun x -> Obj.magic ES))
      (alt segment_register_t
        (map (bits_n (length0 ('0'::('1'::[])))) segment_register_t
          (bits ('0'::('1'::[]))) (fun x -> Obj.magic CS))
        (alt segment_register_t
          (map (bits_n (length0 ('1'::('0'::[])))) segment_register_t
            (bits ('1'::('0'::[]))) (fun x -> Obj.magic SS))
          (map (bits_n (length0 ('1'::('1'::[])))) segment_register_t
            (bits ('1'::('1'::[]))) (fun x -> Obj.magic DS))))
  
  (** val coq_PUSHSR_p : grammar **)
  
  let coq_PUSHSR_p =
    alt instruction_t
      (map (Pair_t (segment_register_t,
        (bits_n (length0 ('1'::('1'::('0'::[]))))))) instruction_t
        (bitsleft (Pair_t (segment_register_t,
          (bits_n (length0 ('1'::('1'::('0'::[])))))))
          ('0'::('0'::('0'::[])))
          (seq segment_register_t (bits_n (length0 ('1'::('1'::('0'::[])))))
            segment_reg2_p (bits ('1'::('1'::('0'::[])))))) (fun p ->
        Obj.magic (PUSHSR (fst (Obj.magic p)))))
      (alt instruction_t
        (map (bits_n (length0 ('0'::('0'::('0'::[]))))) instruction_t
          (bitsleft (bits_n (length0 ('0'::('0'::('0'::[])))))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (bits_n (length0 ('0'::('0'::('0'::[])))))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (bits_n (length0 ('0'::('0'::('0'::[])))))
                ('1'::('0'::[]))
                (bitsleft (bits_n (length0 ('0'::('0'::('0'::[])))))
                  ('1'::('0'::('0'::[]))) (bits ('0'::('0'::('0'::[]))))))))
          (fun x -> Obj.magic (PUSHSR FS)))
        (map (bits_n (length0 ('0'::('0'::('0'::[]))))) instruction_t
          (bitsleft (bits_n (length0 ('0'::('0'::('0'::[])))))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (bits_n (length0 ('0'::('0'::('0'::[])))))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (bits_n (length0 ('0'::('0'::('0'::[])))))
                ('1'::('0'::[]))
                (bitsleft (bits_n (length0 ('0'::('0'::('0'::[])))))
                  ('1'::('0'::('1'::[]))) (bits ('0'::('0'::('0'::[]))))))))
          (fun x -> Obj.magic (PUSHSR GS))))
  
  (** val coq_PUSHA_p : grammar **)
  
  let coq_PUSHA_p =
    map (bits_n (length0 ('0'::('0'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::[]))))))
        ('0'::('1'::('1'::('0'::[])))) (bits ('0'::('0'::('0'::('0'::[]))))))
      (fun x -> Obj.magic PUSHA)
  
  (** val coq_PUSHF_p : grammar **)
  
  let coq_PUSHF_p =
    map (bits_n (length0 ('1'::('1'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('0'::[]))))))
        ('1'::('0'::('0'::('1'::[])))) (bits ('1'::('1'::('0'::('0'::[]))))))
      (fun x -> Obj.magic PUSHF)
  
  (** val rotate_p :
      char list -> (bool -> operand -> reg_or_immed -> instr) -> grammar **)
  
  let rotate_p extop inst =
    alt instruction_t
      (map (Pair_t (Char_t, operand_t)) instruction_t
        (bitsleft (Pair_t (Char_t, operand_t)) ('1'::('1'::('0'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, operand_t)) ('0'::('0'::('0'::[])))
            (seq Char_t operand_t anybit (ext_op_modrm2 extop)))) (fun p ->
        Obj.magic inst (fst (Obj.magic p)) (snd (Obj.magic p)) (Imm_ri
          (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero))))))) Big.one))))
      (alt instruction_t
        (map (Pair_t (Char_t, operand_t)) instruction_t
          (bitsleft (Pair_t (Char_t, operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (Char_t, operand_t)) ('0'::('0'::('1'::[])))
              (seq Char_t operand_t anybit (ext_op_modrm2 extop)))) (fun p ->
          Obj.magic inst (fst (Obj.magic p)) (snd (Obj.magic p)) (Reg_ri ECX)))
        (map (Pair_t (Char_t, (Pair_t (operand_t, byte_t)))) instruction_t
          (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, byte_t))))
            ('1'::('1'::('0'::('0'::[]))))
            (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, byte_t))))
              ('0'::('0'::('0'::[])))
              (seq Char_t (Pair_t (operand_t, byte_t)) anybit
                (seq operand_t byte_t (ext_op_modrm2 extop) byte))))
          (fun p ->
          let (w, i) = Obj.magic p in
          let (op, b) = i in Obj.magic inst w op (Imm_ri b))))
  
  (** val coq_RCL_p : grammar **)
  
  let coq_RCL_p =
    rotate_p ('0'::('1'::('0'::[]))) (fun x x0 x1 -> RCL (x, x0, x1))
  
  (** val coq_RCR_p : grammar **)
  
  let coq_RCR_p =
    rotate_p ('0'::('1'::('1'::[]))) (fun x x0 x1 -> RCR (x, x0, x1))
  
  (** val coq_RDMSR_p : grammar **)
  
  let coq_RDMSR_p =
    map (bits_n (length0 ('0'::('0'::('1'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::[]))))))
            ('0'::('0'::('1'::('1'::[]))))
            (bits ('0'::('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic RDMSR)
  
  (** val coq_RDPMC_p : grammar **)
  
  let coq_RDPMC_p =
    map (bits_n (length0 ('0'::('0'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('1'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('0'::('0'::('1'::('1'::[]))))))
            ('0'::('0'::('1'::('1'::[]))))
            (bits ('0'::('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic RDPMC)
  
  (** val coq_RDTSC_p : grammar **)
  
  let coq_RDTSC_p =
    map (bits_n (length0 ('0'::('0'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::[]))))))
            ('0'::('0'::('1'::('1'::[]))))
            (bits ('0'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic RDTSC)
  
  (** val coq_RDTSCP_p : grammar **)
  
  let coq_RDTSCP_p =
    map (bits_n (length0 ('1'::('0'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
                ('1'::('1'::('1'::('1'::[]))))
                (bits ('1'::('0'::('0'::('1'::[])))))))))) (fun x ->
      Obj.magic RDTSCP)
  
  (** val coq_RET_p : grammar **)
  
  let coq_RET_p =
    alt instruction_t
      (map (bits_n (length0 ('0'::('0'::('1'::('1'::[])))))) instruction_t
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('1'::[]))))))
          ('1'::('1'::('0'::('0'::[]))))
          (bits ('0'::('0'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (RET (true, None))))
      (alt instruction_t
        (map half_t instruction_t
          (bitsleft half_t ('1'::('1'::('0'::('0'::[]))))
            (bitsleft half_t ('0'::('0'::('1'::('0'::[])))) halfword))
          (fun h -> Obj.magic (RET (true, (Some (Obj.magic h))))))
        (alt instruction_t
          (map (bits_n (length0 ('1'::('0'::('1'::('1'::[]))))))
            instruction_t
            (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::[]))))))
              ('1'::('1'::('0'::('0'::[]))))
              (bits ('1'::('0'::('1'::('1'::[])))))) (fun x ->
            Obj.magic (RET (false, None))))
          (map half_t instruction_t
            (bitsleft half_t ('1'::('1'::('0'::('0'::[]))))
              (bitsleft half_t ('1'::('0'::('1'::('0'::[])))) halfword))
            (fun h -> Obj.magic (RET (false, (Some (Obj.magic h))))))))
  
  (** val coq_ROL_p : grammar **)
  
  let coq_ROL_p =
    rotate_p ('0'::('0'::('0'::[]))) (fun x x0 x1 -> ROL (x, x0, x1))
  
  (** val coq_ROR_p : grammar **)
  
  let coq_ROR_p =
    rotate_p ('0'::('0'::('1'::[]))) (fun x x0 x1 -> ROR (x, x0, x1))
  
  (** val coq_RSM_p : grammar **)
  
  let coq_RSM_p =
    map (bits_n (length0 ('1'::('0'::('1'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('1'::('0'::('1'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('1'::('0'::('1'::('0'::[]))))))
            ('1'::('0'::('1'::('0'::[]))))
            (bits ('1'::('0'::('1'::('0'::[])))))))) (fun x -> Obj.magic RSM)
  
  (** val coq_SAHF_p : grammar **)
  
  let coq_SAHF_p =
    map (bits_n (length0 ('1'::('1'::('1'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::[]))))))
        ('1'::('0'::('0'::('1'::[])))) (bits ('1'::('1'::('1'::('0'::[]))))))
      (fun x -> Obj.magic SAHF)
  
  (** val coq_SAR_p : grammar **)
  
  let coq_SAR_p =
    rotate_p ('1'::('1'::('1'::[]))) (fun x x0 x1 -> SAR (x, x0, x1))
  
  (** val coq_SCAS_p : grammar **)
  
  let coq_SCAS_p =
    map Char_t instruction_t
      (bitsleft Char_t ('1'::('0'::('1'::('0'::[]))))
        (bitsleft Char_t ('1'::('1'::('1'::[]))) anybit)) (fun x ->
      Obj.magic (SCAS (Obj.magic x)))
  
  (** val coq_SETcc_p : grammar **)
  
  let coq_SETcc_p =
    map (Pair_t (condition_t, (Pair_t (operand_t, operand_t)))) instruction_t
      (bitsleft (Pair_t (condition_t, (Pair_t (operand_t, operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (condition_t, (Pair_t (operand_t, operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (condition_t, (Pair_t (operand_t, operand_t))))
            ('1'::('0'::('0'::('1'::[]))))
            (seq condition_t (Pair_t (operand_t, operand_t)) tttn modrm))))
      (fun p ->
      Obj.magic (SETcc ((fst (Obj.magic p)), (snd (snd (Obj.magic p))))))
  
  (** val coq_SGDT_p : grammar **)
  
  let coq_SGDT_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm ('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic (SGDT (Obj.magic x)))
  
  (** val coq_SHL_p : grammar **)
  
  let coq_SHL_p =
    rotate_p ('1'::('0'::('0'::[]))) (fun x x0 x1 -> SHL (x, x0, x1))
  
  (** val shiftdouble_p :
      char list -> (operand -> register -> reg_or_immed -> interp) -> grammar **)
  
  let shiftdouble_p opcode inst =
    alt instruction_t
      (map (Pair_t (register_t, (Pair_t (register_t, byte_t)))) instruction_t
        (bitsleft (Pair_t (register_t, (Pair_t (register_t, byte_t))))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (register_t, (Pair_t (register_t, byte_t))))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (register_t, (Pair_t (register_t, byte_t))))
              ('1'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (register_t, (Pair_t (register_t, byte_t))))
                opcode
                (bitsleft (Pair_t (register_t, (Pair_t (register_t,
                  byte_t)))) ('0'::('0'::[]))
                  (bitsleft (Pair_t (register_t, (Pair_t (register_t,
                    byte_t)))) ('1'::('1'::[]))
                    (seq register_t (Pair_t (register_t, byte_t)) reg
                      (seq register_t byte_t reg byte)))))))) (fun p ->
        let (r2, i) = Obj.magic p in
        let (r3, b) = i in inst (Reg_op r3) r2 (Imm_ri b)))
      (alt instruction_t
        (map (Pair_t ((Pair_t (register_t, operand_t)), byte_t))
          instruction_t
          (bitsleft (Pair_t ((Pair_t (register_t, operand_t)), byte_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t ((Pair_t (register_t, operand_t)), byte_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t ((Pair_t (register_t, operand_t)), byte_t))
                ('1'::('0'::('1'::('0'::[]))))
                (bitsleft (Pair_t ((Pair_t (register_t, operand_t)), byte_t))
                  opcode
                  (bitsleft (Pair_t ((Pair_t (register_t, operand_t)),
                    byte_t)) ('0'::('0'::[]))
                    (seq (Pair_t (register_t, operand_t)) byte_t modrm_noreg
                      byte)))))) (fun p ->
          let (i, b) = Obj.magic p in
          let (r2, op) = i in inst op r2 (Imm_ri b)))
        (alt instruction_t
          (map (Pair_t (register_t, register_t)) instruction_t
            (bitsleft (Pair_t (register_t, register_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (register_t, register_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (register_t, register_t))
                  ('1'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (register_t, register_t)) opcode
                    (bitsleft (Pair_t (register_t, register_t))
                      ('0'::('1'::[]))
                      (bitsleft (Pair_t (register_t, register_t))
                        ('1'::('1'::[])) (seq register_t register_t reg reg)))))))
            (fun p ->
            let (r2, r3) = Obj.magic p in inst (Reg_op r3) r2 (Reg_ri ECX)))
          (map (Pair_t (register_t, operand_t)) instruction_t
            (bitsleft (Pair_t (register_t, operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (register_t, operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (register_t, operand_t))
                  ('1'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (register_t, operand_t)) opcode
                    (bitsleft (Pair_t (register_t, operand_t))
                      ('0'::('1'::[])) modrm_noreg))))) (fun p ->
            let (r2, op) = Obj.magic p in inst op r2 (Reg_ri ECX)))))
  
  (** val coq_SHLD_p : grammar **)
  
  let coq_SHLD_p =
    shiftdouble_p ('0'::('1'::[]))
      (Obj.magic (fun x x0 x1 -> SHLD (x, x0, x1)))
  
  (** val coq_SHR_p : grammar **)
  
  let coq_SHR_p =
    rotate_p ('1'::('0'::('1'::[]))) (fun x x0 x1 -> SHR (x, x0, x1))
  
  (** val coq_SHRD_p : grammar **)
  
  let coq_SHRD_p =
    shiftdouble_p ('1'::('1'::[]))
      (Obj.magic (fun x x0 x1 -> SHRD (x, x0, x1)))
  
  (** val coq_SIDT_p : grammar **)
  
  let coq_SIDT_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm ('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic (SIDT (Obj.magic x)))
  
  (** val coq_SLDT_p : grammar **)
  
  let coq_SLDT_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
              (ext_op_modrm2 ('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic (SLDT (Obj.magic x)))
  
  (** val coq_SMSW_p : grammar **)
  
  let coq_SMSW_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('1'::[]))))
              (ext_op_modrm2 ('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic (SMSW (Obj.magic x)))
  
  (** val coq_STC_p : grammar **)
  
  let coq_STC_p =
    map (bits_n (length0 ('1'::('0'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('1'::('0'::('0'::('1'::[]))))))
      (fun x -> Obj.magic STC)
  
  (** val coq_STD_p : grammar **)
  
  let coq_STD_p =
    map (bits_n (length0 ('1'::('1'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('1'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('1'::('1'::('0'::('1'::[]))))))
      (fun x -> Obj.magic STD)
  
  (** val coq_STI_p : grammar **)
  
  let coq_STI_p =
    map (bits_n (length0 ('1'::('0'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('1'::('0'::('1'::('1'::[]))))))
      (fun x -> Obj.magic STI)
  
  (** val coq_STOS_p : grammar **)
  
  let coq_STOS_p =
    map Char_t instruction_t
      (bitsleft Char_t ('1'::('0'::('1'::('0'::[]))))
        (bitsleft Char_t ('1'::('0'::('1'::[]))) anybit)) (fun x ->
      Obj.magic (STOS (Obj.magic x)))
  
  (** val coq_STR_p : grammar **)
  
  let coq_STR_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
              (ext_op_modrm2 ('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic (STR (Obj.magic x)))
  
  (** val coq_TEST_p : bool -> grammar **)
  
  let coq_TEST_p opsize_override =
    alt instruction_t
      (map (Pair_t (operand_t, operand_t)) instruction_t
        (bitsleft (Pair_t (operand_t, operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (operand_t, operand_t))
            ('0'::('1'::('1'::('1'::[]))))
            (seq operand_t operand_t (ext_op_modrm2 ('0'::('0'::('0'::[]))))
              (imm_op opsize_override)))) (fun p ->
        Obj.magic (TEST (true, (fst (Obj.magic p)), (snd (Obj.magic p))))))
      (alt instruction_t
        (map (Pair_t (operand_t, byte_t)) instruction_t
          (bitsleft (Pair_t (operand_t, byte_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (operand_t, byte_t))
              ('0'::('1'::('1'::('0'::[]))))
              (seq operand_t byte_t (ext_op_modrm2 ('0'::('0'::('0'::[]))))
                byte))) (fun p ->
          Obj.magic (TEST (false, (fst (Obj.magic p)), (Imm_op
            (zero_extend8_32 (snd (Obj.magic p))))))))
        (alt instruction_t
          (map (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
            instruction_t
            (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
              ('1'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
                ('0'::('1'::('0'::[])))
                (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm)))
            (fun p ->
            let (w, i) = Obj.magic p in
            let (op1, op2) = i in Obj.magic (TEST (w, op1, op2))))
          (alt instruction_t
            (map operand_t instruction_t
              (bitsleft operand_t ('1'::('0'::('1'::('0'::[]))))
                (bitsleft operand_t ('1'::('0'::('0'::('1'::[]))))
                  (imm_op opsize_override))) (fun w ->
              Obj.magic (TEST (true, (Obj.magic w), (Reg_op EAX)))))
            (map byte_t instruction_t
              (bitsleft byte_t ('1'::('0'::('1'::('0'::[]))))
                (bitsleft byte_t ('1'::('0'::('0'::('0'::[])))) byte))
              (fun b ->
              Obj.magic (TEST (true, (Reg_op EAX), (Imm_op
                (zero_extend8_32 (Obj.magic b))))))))))
  
  (** val coq_UD2_p : grammar **)
  
  let coq_UD2_p =
    map (bits_n (length0 ('1'::('0'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::[]))))))
            ('0'::('0'::('0'::('0'::[]))))
            (bits ('1'::('0'::('1'::('1'::[])))))))) (fun x -> Obj.magic UD2)
  
  (** val coq_VERR_p : grammar **)
  
  let coq_VERR_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
              (ext_op_modrm2 ('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic (VERR (Obj.magic x)))
  
  (** val coq_VERW_p : grammar **)
  
  let coq_VERW_p =
    map operand_t instruction_t
      (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
            (bitsleft operand_t ('0'::('0'::('0'::('0'::[]))))
              (ext_op_modrm2 ('1'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic (VERW (Obj.magic x)))
  
  (** val coq_WBINVD_p : grammar **)
  
  let coq_WBINVD_p =
    map (bits_n (length0 ('1'::('0'::('0'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::[]))))))
            ('0'::('0'::('0'::('0'::[]))))
            (bits ('1'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic WBINVD)
  
  (** val coq_WRMSR_p : grammar **)
  
  let coq_WRMSR_p =
    map (bits_n (length0 ('0'::('0'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::[]))))))
            ('0'::('0'::('1'::('1'::[]))))
            (bits ('0'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic WRMSR)
  
  (** val coq_XADD_p : grammar **)
  
  let coq_XADD_p =
    map (Pair_t (Char_t, (Pair_t (operand_t, operand_t)))) instruction_t
      (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
            ('1'::('1'::('0'::('0'::[]))))
            (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
              ('0'::('0'::('0'::[])))
              (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm)))))
      (fun p ->
      let (w, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (XADD (w, op2, op1)))
  
  (** val coq_XCHG_p : grammar **)
  
  let coq_XCHG_p =
    alt instruction_t
      (map (Pair_t (Char_t, (Pair_t (operand_t, operand_t)))) instruction_t
        (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
          ('1'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (Char_t, (Pair_t (operand_t, operand_t))))
            ('0'::('1'::('1'::[])))
            (seq Char_t (Pair_t (operand_t, operand_t)) anybit modrm)))
        (fun p ->
        let (w, i) = Obj.magic p in
        let (op1, op2) = i in Obj.magic (XCHG (w, op2, op1))))
      (map register_t instruction_t
        (bitsleft register_t ('1'::('0'::('0'::('1'::[]))))
          (bitsleft register_t ('0'::[]) reg)) (fun r2 ->
        Obj.magic (XCHG (false, (Reg_op EAX), (Reg_op (Obj.magic r2))))))
  
  (** val coq_XLAT_p : grammar **)
  
  let coq_XLAT_p =
    map (bits_n (length0 ('0'::('1'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::[]))))))
        ('1'::('1'::('0'::('1'::[])))) (bits ('0'::('1'::('1'::('1'::[]))))))
      (fun x -> Obj.magic XLAT)
  
  (** val coq_F2XM1_p : grammar **)
  
  let coq_F2XM1_p =
    map (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic F2XM1)
  
  (** val coq_FABS_p : grammar **)
  
  let coq_FABS_p =
    map (bits_n (length0 ('0'::('0'::('0'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FABS)
  
  (** val coq_FADD_p : grammar **)
  
  let coq_FADD_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FADD (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('0'::('0'::('0'::[])))))) (fun x ->
          Obj.magic (FADD (true, (Obj.magic x)))))
        (map (Pair_t (Char_t, fpu_register_t)) instruction_t
          (bitsleft (Pair_t (Char_t, fpu_register_t))
            ('1'::('1'::('0'::('1'::('1'::[])))))
            (seq Char_t fpu_register_t anybit
              (bitsleft fpu_register_t
                ('0'::('0'::('1'::('1'::('0'::('0'::('0'::[]))))))) fpu_reg)))
          (fun p ->
          let (d, s) = Obj.magic p in Obj.magic (FADD (d, (FPS_op s))))))
  
  (** val coq_FADDP_p : grammar **)
  
  let coq_FADDP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('0'::('0'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FADDP (FPS_op (Obj.magic x))))
  
  (** val coq_FBLD_p : grammar **)
  
  let coq_FBLD_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
          (ext_op_modrm_FPM64 ('1'::('0'::('0'::[])))))) (fun x ->
      Obj.magic (FBLD (Obj.magic x)))
  
  (** val coq_FBSTP_p : grammar **)
  
  let coq_FBSTP_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
          (ext_op_modrm_FPM64 ('1'::('1'::('0'::[])))))) (fun x ->
      Obj.magic (FBSTP (Obj.magic x)))
  
  (** val coq_FCHS_p : grammar **)
  
  let coq_FCHS_p =
    map (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FCHS)
  
  (** val coq_FCMOVcc_p : grammar **)
  
  let coq_FCMOVcc_p =
    map (Pair_t (Char_t, (Pair_t (Char_t, (Pair_t (Char_t,
      fpu_register_t)))))) instruction_t
      (bitsleft (Pair_t (Char_t, (Pair_t (Char_t, (Pair_t (Char_t,
        fpu_register_t)))))) ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (Pair_t (Char_t, (Pair_t (Char_t, (Pair_t (Char_t,
          fpu_register_t)))))) ('0'::('1'::[]))
          (seq Char_t (Pair_t (Char_t, (Pair_t (Char_t, fpu_register_t))))
            anybit
            (bitsleft (Pair_t (Char_t, (Pair_t (Char_t, fpu_register_t))))
              ('1'::('1'::('0'::[])))
              (seq Char_t (Pair_t (Char_t, fpu_register_t)) anybit
                (seq Char_t fpu_register_t anybit fpu_reg)))))) (fun p ->
      let (b2, i) = Obj.magic p in
      let (b1, i0) = i in
      let (b0, s) = i0 in
      let n =
        bits2int (Big.succ (Big.succ (Big.succ Big.zero)))
          (Obj.magic (b2, (b1, (b0, ()))))
      in
      Obj.magic (FCMOVcc ((z_to_fp_condition_type (Obj.magic n)), (FPS_op
        s))))
  
  (** val coq_FCOM_p : grammar **)
  
  let coq_FCOM_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FCOM (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('0'::('1'::('0'::[])))))) (fun x ->
          Obj.magic (FCOM (Obj.magic x))))
        (map fpu_register_t instruction_t
          (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fpu_register_t ('0'::('0'::('0'::[])))
              (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('0'::[])))))
                fpu_reg))) (fun x ->
          Obj.magic (FCOM (FPS_op (Obj.magic x))))))
  
  (** val coq_FCOMP_p : grammar **)
  
  let coq_FCOMP_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FCOMP (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('0'::('1'::('1'::[])))))) (fun x ->
          Obj.magic (FCOMP (Obj.magic x))))
        (map fpu_register_t instruction_t
          (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fpu_register_t ('0'::('0'::('0'::[])))
              (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
                fpu_reg))) (fun x ->
          Obj.magic (FCOMP (FPS_op (Obj.magic x))))))
  
  (** val coq_FCOMPP_p : grammar **)
  
  let coq_FCOMPP_p =
    map (bits_n (length0 ('0'::('0'::('1'::[]))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
          ('1'::('1'::('0'::[])))
          (bitsleft (bits_n (length0 ('0'::('0'::('1'::[])))))
            ('1'::('1'::('0'::('1'::('1'::[])))))
            (bits ('0'::('0'::('1'::[]))))))) (fun x -> Obj.magic FCOMPP)
  
  (** val coq_FCOMIP_p : grammar **)
  
  let coq_FCOMIP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('1'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FCOMIP (FPS_op (Obj.magic x))))
  
  (** val coq_FCOS_p : grammar **)
  
  let coq_FCOS_p =
    map (bits_n (length0 ('1'::('1'::('1'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::('1'::[])))))))
          ('0'::('0'::('1'::[])))
          (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::('1'::[])))))))
            ('1'::('1'::('1'::[])))
            (bits ('1'::('1'::('1'::('1'::('1'::[]))))))))) (fun x ->
      Obj.magic FCOS)
  
  (** val coq_FDECSTP_p : grammar **)
  
  let coq_FDECSTP_p =
    map (bits_n (length0 ('1'::('0'::('1'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::[])))
          (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::('0'::[])))))))
            ('1'::('1'::('1'::[])))
            (bits ('1'::('0'::('1'::('1'::('0'::[]))))))))) (fun x ->
      Obj.magic FDECSTP)
  
  (** val coq_FDIV_p : grammar **)
  
  let coq_FDIV_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FDIV (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('1'::('1'::('0'::[])))))) (fun x ->
          Obj.magic (FDIV (true, (Obj.magic x)))))
        (alt instruction_t
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('0'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::('1'::[]))))
                    (bitsleft fpu_register_t ('0'::[]) fpu_reg))))) (fun i ->
            Obj.magic (FDIV (true, (FPS_op (Obj.magic i))))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('1'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('1'::[])
                      (bitsleft fpu_register_t ('1'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FDIV (false, (FPS_op (Obj.magic i))))))))
  
  (** val coq_FDIVP_p : grammar **)
  
  let coq_FDIVP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('1'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FDIVP (FPS_op (Obj.magic x))))
  
  (** val coq_FDIVR_p : grammar **)
  
  let coq_FDIVR_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FDIVR (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('1'::('1'::('1'::[])))))) (fun x ->
          Obj.magic (FDIVR (true, (Obj.magic x)))))
        (alt instruction_t
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('0'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('1'::[])
                      (bitsleft fpu_register_t ('1'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FDIVR (true, (FPS_op (Obj.magic i))))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('1'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('1'::[])
                      (bitsleft fpu_register_t ('0'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FDIVR (false, (FPS_op (Obj.magic i))))))))
  
  (** val coq_FDIVRP_p : grammar **)
  
  let coq_FDIVRP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('1'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FDIVRP (FPS_op (Obj.magic x))))
  
  (** val coq_FFREE_p : grammar **)
  
  let coq_FFREE_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('0'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('0'::('0'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FFREE (FPS_op (Obj.magic x))))
  
  (** val coq_FIADD_p : grammar **)
  
  let coq_FIADD_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('0'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FIADD (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FIADD (Obj.magic x))))
  
  (** val coq_FICOM_p : grammar **)
  
  let coq_FICOM_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FICOM (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FICOM (Obj.magic x))))
  
  (** val coq_FICOMP_p : grammar **)
  
  let coq_FICOMP_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('0'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FICOMP (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FICOMP (Obj.magic x))))
  
  (** val coq_FIDIV_p : grammar **)
  
  let coq_FIDIV_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('1'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FIDIV (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FIDIV (Obj.magic x))))
  
  (** val coq_FIDIVR_p : grammar **)
  
  let coq_FIDIVR_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('1'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FIDIVR (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FIDIVR (Obj.magic x))))
  
  (** val coq_FILD_p : grammar **)
  
  let coq_FILD_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
            (ext_op_modrm_FPM16 ('0'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FILD (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('0'::('1'::('1'::[])))
              (ext_op_modrm_FPM32 ('0'::('0'::('0'::[])))))) (fun x ->
          Obj.magic (FILD (Obj.magic x))))
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
              (ext_op_modrm_FPM64 ('1'::('0'::('1'::[])))))) (fun x ->
          Obj.magic (FILD (Obj.magic x)))))
  
  (** val coq_FIMUL_p : grammar **)
  
  let coq_FIMUL_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('0'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FIMUL (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FIMUL (Obj.magic x))))
  
  (** val coq_FINCSTP_p : grammar **)
  
  let coq_FINCSTP_p =
    map (bits_n (length0 ('1'::('0'::('1'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('1'::('1'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('1'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic FINCSTP)
  
  (** val coq_FIST_p : grammar **)
  
  let coq_FIST_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
            (ext_op_modrm_FPM16 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FIST (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('1'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FIST (Obj.magic x))))
  
  (** val coq_FISTP_p : grammar **)
  
  let coq_FISTP_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
            (ext_op_modrm_FPM16 ('0'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FISTP (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('0'::('1'::('1'::[])))
              (ext_op_modrm_FPM32 ('0'::('1'::('1'::[])))))) (fun x ->
          Obj.magic (FISTP (Obj.magic x))))
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('1'::('1'::[])))
              (ext_op_modrm_FPM64 ('1'::('1'::('1'::[])))))) (fun x ->
          Obj.magic (FISTP (Obj.magic x)))))
  
  (** val coq_FISUB_p : grammar **)
  
  let coq_FISUB_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('1'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FISUB (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FISUB (Obj.magic x))))
  
  (** val coq_FISUBR_p : grammar **)
  
  let coq_FISUBR_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('1'::('0'::[])))
            (ext_op_modrm_FPM16 ('1'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FISUBR (Obj.magic x))))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('1'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FISUBR (Obj.magic x))))
  
  (** val coq_FLD_p : grammar **)
  
  let coq_FLD_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
            (ext_op_modrm_FPM32 ('0'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FLD (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('1'::[])))
              (ext_op_modrm_FPM64 ('0'::('0'::('0'::[])))))) (fun x ->
          Obj.magic (FLD (Obj.magic x))))
        (alt instruction_t
          (map fp_operand_t instruction_t
            (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fp_operand_t ('0'::('1'::('1'::[])))
                (ext_op_modrm_FPM80 ('1'::('0'::('1'::[])))))) (fun x ->
            Obj.magic (FLD (Obj.magic x))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('0'::('0'::('1'::[])))
                (bitsleft fpu_register_t
                  ('1'::('1'::('0'::('0'::('0'::[]))))) fpu_reg))) (fun x ->
            Obj.magic (FLD (FPS_op (Obj.magic x)))))))
  
  (** val coq_FLD1_p : grammar **)
  
  let coq_FLD1_p =
    map (bits_n (length0 ('0'::('1'::('0'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FLD1)
  
  (** val coq_FLDCW_p : grammar **)
  
  let coq_FLDCW_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
          (ext_op_modrm_FPM32 ('1'::('0'::('1'::[])))))) (fun x ->
      Obj.magic (FLDCW (Obj.magic x)))
  
  (** val coq_FLDENV_p : grammar **)
  
  let coq_FLDENV_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
          (ext_op_modrm_FPM32 ('1'::('0'::('0'::[])))))) (fun x ->
      Obj.magic (FLDENV (Obj.magic x)))
  
  (** val coq_FLDL2E_p : grammar **)
  
  let coq_FLDL2E_p =
    map (bits_n (length0 ('0'::('1'::('0'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FLDL2E)
  
  (** val coq_FLDL2T_p : grammar **)
  
  let coq_FLDL2T_p =
    map (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FLDL2T)
  
  (** val coq_FLDLG2_p : grammar **)
  
  let coq_FLDLG2_p =
    map (bits_n (length0 ('0'::('1'::('1'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FLDLG2)
  
  (** val coq_FLDLN2_p : grammar **)
  
  let coq_FLDLN2_p =
    map (bits_n (length0 ('0'::('1'::('1'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('1'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FLDLN2)
  
  (** val coq_FLDPI_p : grammar **)
  
  let coq_FLDPI_p =
    map (bits_n (length0 ('0'::('1'::('0'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('1'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic FLDPI)
  
  (** val coq_FLDZ_p : grammar **)
  
  let coq_FLDZ_p =
    map (bits_n (length0 ('0'::('1'::('1'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('1'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FLDZ)
  
  (** val coq_FMUL_p : grammar **)
  
  let coq_FMUL_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('0'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FMUL (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('0'::('0'::('1'::[])))))) (fun x ->
          Obj.magic (FMUL (true, (Obj.magic x)))))
        (map (Pair_t (Char_t, fpu_register_t)) instruction_t
          (bitsleft (Pair_t (Char_t, fpu_register_t))
            ('1'::('1'::('0'::('1'::('1'::[])))))
            (seq Char_t fpu_register_t anybit
              (bitsleft fpu_register_t ('0'::('0'::[]))
                (bitsleft fpu_register_t
                  ('1'::('1'::('0'::('0'::('1'::[]))))) fpu_reg)))) (fun p ->
          let (d, s) = Obj.magic p in Obj.magic (FMUL (d, (FPS_op s))))))
  
  (** val coq_FMULP_p : grammar **)
  
  let coq_FMULP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('0'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FMULP (FPS_op (Obj.magic x))))
  
  (** val coq_FNCLEX_p : grammar **)
  
  let coq_FNCLEX_p =
    map (bits_n (length0 ('0'::('0'::('0'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::('0'::[])))))))
          ('0'::('1'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FNCLEX)
  
  (** val coq_FNINIT_p : grammar **)
  
  let coq_FNINIT_p =
    map (bits_n (length0 ('0'::('0'::('0'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('1'::('1'::[])))))))
          ('0'::('1'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic FNINIT)
  
  (** val coq_FNOP_p : grammar **)
  
  let coq_FNOP_p =
    map (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('0'::[]))))))
          (bits ('1'::('0'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FNOP)
  
  (** val coq_FNSAVE_p : grammar **)
  
  let coq_FNSAVE_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t
        ('1'::('1'::('0'::('1'::('1'::('1'::('0'::('1'::[]))))))))
        (ext_op_modrm_FPM64 ('1'::('1'::('0'::[]))))) (fun x ->
      Obj.magic (FNSAVE (Obj.magic x)))
  
  (** val coq_FNSTCW_p : grammar **)
  
  let coq_FNSTCW_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
          (ext_op_modrm_FPM32 ('1'::('1'::('1'::[])))))) (fun x ->
      Obj.magic (FNSTCW (Obj.magic x)))
  
  (** val coq_FNSTSW_p : grammar **)
  
  let coq_FNSTSW_p =
    alt instruction_t
      (map (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
        instruction_t
        (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
          ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
            ('1'::('1'::('1'::[])))
            (bitsleft
              (bits_n (length0 ('0'::('0'::('0'::('0'::('0'::[])))))))
              ('1'::('1'::('1'::[])))
              (bits ('0'::('0'::('0'::('0'::('0'::[]))))))))) (fun x ->
        Obj.magic (FNSTSW None)))
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('1'::('0'::('1'::[])))
            (ext_op_modrm_FPM32 ('1'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FNSTSW (Some (Obj.magic x)))))
  
  (** val coq_FPATAN_p : grammar **)
  
  let coq_FPATAN_p =
    map (bits_n (length0 ('1'::('0'::('0'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic FPATAN)
  
  (** val coq_FPREM_p : grammar **)
  
  let coq_FPREM_p =
    map (bits_n (length0 ('1'::('1'::('0'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('0'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FPREM)
  
  (** val coq_FPREM1_p : grammar **)
  
  let coq_FPREM1_p =
    map (bits_n (length0 ('1'::('0'::('1'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('1'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('1'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('1'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FPREM1)
  
  (** val coq_FPTAN_p : grammar **)
  
  let coq_FPTAN_p =
    map (bits_n (length0 ('1'::('0'::('0'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FPTAN)
  
  (** val coq_FRNDINT_p : grammar **)
  
  let coq_FRNDINT_p =
    map (bits_n (length0 ('1'::('1'::('1'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FRNDINT)
  
  (** val coq_FRSTOR_p : grammar **)
  
  let coq_FRSTOR_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('1'::('0'::('1'::[])))
          (ext_op_modrm_FPM32 ('1'::('0'::('0'::[])))))) (fun x ->
      Obj.magic (FRSTOR (Obj.magic x)))
  
  (** val coq_FSCALE_p : grammar **)
  
  let coq_FSCALE_p =
    map (bits_n (length0 ('1'::('1'::('1'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('1'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FSCALE)
  
  (** val coq_FSIN_p : grammar **)
  
  let coq_FSIN_p =
    map (bits_n (length0 ('1'::('1'::('1'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('1'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('1'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FSIN)
  
  (** val coq_FSINCOS_p : grammar **)
  
  let coq_FSINCOS_p =
    map (bits_n (length0 ('1'::('1'::('0'::('1'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('1'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('0'::('1'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic FSINCOS)
  
  (** val coq_FSQRT_p : grammar **)
  
  let coq_FSQRT_p =
    map (bits_n (length0 ('1'::('1'::('0'::('1'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('1'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('0'::('1'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic FSQRT)
  
  (** val coq_FST_p : grammar **)
  
  let coq_FST_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('0'::[])))))) (fun x ->
        Obj.magic (FST (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('1'::[])))
              (ext_op_modrm_FPM64 ('0'::('1'::('0'::[])))))) (fun x ->
          Obj.magic (FST (Obj.magic x))))
        (map fpu_register_t instruction_t
          (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fpu_register_t ('1'::('0'::('1'::[])))
              (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('0'::[])))))
                fpu_reg))) (fun x -> Obj.magic (FST (FPS_op (Obj.magic x))))))
  
  (** val coq_FSTENV_p : grammar **)
  
  let coq_FSTENV_p =
    map fp_operand_t instruction_t
      (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
          (ext_op_modrm_FPM32 ('1'::('1'::('0'::[])))))) (fun x ->
      Obj.magic (FSTENV (Obj.magic x)))
  
  (** val coq_FSTP_p : grammar **)
  
  let coq_FSTP_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('1'::[])))
            (ext_op_modrm_FPM32 ('0'::('1'::('1'::[])))))) (fun x ->
        Obj.magic (FSTP (Obj.magic x))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('1'::[])))
              (ext_op_modrm_FPM64 ('0'::('1'::('1'::[])))))) (fun x ->
          Obj.magic (FSTP (Obj.magic x))))
        (alt instruction_t
          (map fp_operand_t instruction_t
            (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fp_operand_t ('0'::('1'::('1'::[])))
                (ext_op_modrm_FPM80 ('1'::('1'::('1'::[])))))) (fun x ->
            Obj.magic (FSTP (Obj.magic x))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('1'::('0'::('1'::[])))
                (bitsleft fpu_register_t
                  ('1'::('1'::('0'::('1'::('1'::[]))))) fpu_reg))) (fun x ->
            Obj.magic (FSTP (FPS_op (Obj.magic x)))))))
  
  (** val coq_FSUB_p : grammar **)
  
  let coq_FSUB_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('0'::('0'::[])))))) (fun x ->
        Obj.magic (FSUB (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('1'::('0'::('0'::[])))))) (fun x ->
          Obj.magic (FSUB (true, (Obj.magic x)))))
        (alt instruction_t
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('0'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('0'::[])
                      (bitsleft fpu_register_t ('0'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FSUB (true, (FPS_op (Obj.magic i))))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('1'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('0'::[])
                      (bitsleft fpu_register_t ('1'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FSUB (false, (FPS_op (Obj.magic i))))))))
  
  (** val coq_FSUBP_p : grammar **)
  
  let coq_FSUBP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FSUBP (FPS_op (Obj.magic x))))
  
  (** val coq_FSUBR_p : grammar **)
  
  let coq_FSUBR_p =
    alt instruction_t
      (map fp_operand_t instruction_t
        (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
          (bitsleft fp_operand_t ('0'::('0'::('0'::[])))
            (ext_op_modrm_FPM32 ('1'::('0'::('1'::[])))))) (fun x ->
        Obj.magic (FSUBR (true, (Obj.magic x)))))
      (alt instruction_t
        (map fp_operand_t instruction_t
          (bitsleft fp_operand_t ('1'::('1'::('0'::('1'::('1'::[])))))
            (bitsleft fp_operand_t ('1'::('0'::('0'::[])))
              (ext_op_modrm_FPM64 ('1'::('0'::('1'::[])))))) (fun x ->
          Obj.magic (FSUBR (true, (Obj.magic x)))))
        (alt instruction_t
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('0'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('0'::[])
                      (bitsleft fpu_register_t ('1'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FSUBR (true, (FPS_op (Obj.magic i))))))
          (map fpu_register_t instruction_t
            (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
              (bitsleft fpu_register_t ('1'::[])
                (bitsleft fpu_register_t ('0'::('0'::[]))
                  (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
                    (bitsleft fpu_register_t ('0'::[])
                      (bitsleft fpu_register_t ('0'::[]) fpu_reg))))))
            (fun i -> Obj.magic (FSUBR (false, (FPS_op (Obj.magic i))))))))
  
  (** val coq_FSUBRP_p : grammar **)
  
  let coq_FSUBRP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('0'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FSUBRP (FPS_op (Obj.magic x))))
  
  (** val coq_FTST_p : grammar **)
  
  let coq_FTST_p =
    map (bits_n (length0 ('0'::('0'::('1'::('0'::('0'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::('0'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::('0'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FTST)
  
  (** val coq_FUCOM_p : grammar **)
  
  let coq_FUCOM_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('0'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('0'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FUCOM (FPS_op (Obj.magic x))))
  
  (** val coq_FUCOMP_p : grammar **)
  
  let coq_FUCOMP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('0'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FUCOMP (FPS_op (Obj.magic x))))
  
  (** val coq_FUCOMPP_p : grammar **)
  
  let coq_FUCOMPP_p =
    map (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::('1'::[])))))))
          ('0'::('1'::('0'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('1'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FUCOMPP)
  
  (** val coq_FUCOMI_p : grammar **)
  
  let coq_FUCOMI_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('0'::('1'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FUCOMI (FPS_op (Obj.magic x))))
  
  (** val coq_FUCOMIP_p : grammar **)
  
  let coq_FUCOMIP_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('1'::('1'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('1'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FUCOMIP (FPS_op (Obj.magic x))))
  
  (** val coq_FXAM_p : grammar **)
  
  let coq_FXAM_p =
    map (bits_n (length0 ('0'::('0'::('1'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('0'::('0'::('1'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FXAM)
  
  (** val coq_FXCH_p : grammar **)
  
  let coq_FXCH_p =
    map fpu_register_t instruction_t
      (bitsleft fpu_register_t ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft fpu_register_t ('0'::('0'::('1'::[])))
          (bitsleft fpu_register_t ('1'::('1'::('0'::('0'::('1'::[])))))
            fpu_reg))) (fun x -> Obj.magic (FXCH (FPS_op (Obj.magic x))))
  
  (** val coq_FXTRACT_p : grammar **)
  
  let coq_FXTRACT_p =
    map (bits_n (length0 ('0'::('1'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::[]))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::[]))))))
          ('0'::('0'::('1'::[])))
          (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::[]))))))
            ('1'::('1'::('1'::('1'::[]))))
            (bits ('0'::('1'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic FXTRACT)
  
  (** val coq_FYL2X_p : grammar **)
  
  let coq_FYL2X_p =
    map (bits_n (length0 ('1'::('0'::('0'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('0'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FYL2X)
  
  (** val coq_FYL2XP1_p : grammar **)
  
  let coq_FYL2XP1_p =
    map (bits_n (length0 ('1'::('1'::('0'::('0'::('1'::[])))))))
      instruction_t
      (bitsleft (bits_n (length0 ('1'::('1'::('0'::('0'::('1'::[])))))))
        ('1'::('1'::('0'::('1'::('1'::[])))))
        (bitsleft (bits_n (length0 ('1'::('1'::('0'::('0'::('1'::[])))))))
          ('0'::('0'::('1'::('1'::('1'::('1'::[]))))))
          (bits ('1'::('1'::('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic FYL2XP1)
  
  (** val coq_FWAIT_p : grammar **)
  
  let coq_FWAIT_p =
    map
      (bits_n
        (length0 ('1'::('0'::('0'::('1'::('1'::('0'::('1'::('1'::[]))))))))))
      instruction_t
      (bits ('1'::('0'::('0'::('1'::('1'::('0'::('1'::('1'::[])))))))))
      (fun x -> Obj.magic FWAIT)
  
  (** val mmx_gg_p : bool -> bool -> bool -> bool -> grammar **)
  
  let mmx_gg_p byte0 twob fourb eightb =
    let byte_p =
      if byte0
      then map (bits_n (length0 ('0'::('0'::[])))) mmx_granularity_t
             (bits ('0'::('0'::[]))) (fun x -> Obj.magic MMX_8)
      else never mmx_granularity_t
    in
    let twobytes_p =
      if twob
      then map (bits_n (length0 ('0'::('1'::[])))) mmx_granularity_t
             (bits ('0'::('1'::[]))) (fun x -> Obj.magic MMX_16)
      else never mmx_granularity_t
    in
    let fourbytes_p =
      if fourb
      then map (bits_n (length0 ('1'::('0'::[])))) mmx_granularity_t
             (bits ('1'::('0'::[]))) (fun x -> Obj.magic MMX_32)
      else never mmx_granularity_t
    in
    let eightbytes_p =
      if eightb
      then map (bits_n (length0 ('1'::('1'::[])))) mmx_granularity_t
             (bits ('1'::('1'::[]))) (fun x -> Obj.magic MMX_64)
      else never mmx_granularity_t
    in
    alt mmx_granularity_t byte_p
      (alt mmx_granularity_t twobytes_p
        (alt mmx_granularity_t fourbytes_p eightbytes_p))
  
  (** val coq_EMMS_p : grammar **)
  
  let coq_EMMS_p =
    map (bits_n (length0 ('0'::('1'::('1'::('1'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::[]))))))
            ('0'::('1'::('1'::('1'::[]))))
            (bits ('0'::('1'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic EMMS)
  
  (** val coq_MOVD_p : grammar **)
  
  let coq_MOVD_p =
    alt instruction_t
      (map (Pair_t (mmx_register_t, register_t)) instruction_t
        (bitsleft (Pair_t (mmx_register_t, register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_register_t, register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_register_t, register_t))
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (mmx_register_t, register_t))
                ('1'::('1'::('1'::('0'::[]))))
                (bitsleft (Pair_t (mmx_register_t, register_t))
                  ('1'::('1'::[]))
                  (seq mmx_register_t register_t mmx_reg reg)))))) (fun p ->
        let (m, r2) = Obj.magic p in
        Obj.magic (MOVD ((GP_Reg_op r2), (MMX_Reg_op m)))))
      (alt instruction_t
        (map (Pair_t (mmx_register_t, register_t)) instruction_t
          (bitsleft (Pair_t (mmx_register_t, register_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (mmx_register_t, register_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_register_t, register_t))
                ('0'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (mmx_register_t, register_t))
                  ('1'::('1'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (mmx_register_t, register_t))
                    ('1'::('1'::[]))
                    (seq mmx_register_t register_t mmx_reg reg))))))
          (fun p ->
          let (m, r2) = Obj.magic p in
          Obj.magic (MOVD ((GP_Reg_op r2), (MMX_Reg_op m)))))
        (alt instruction_t
          (map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                  ('0'::('1'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                    ('1'::('1'::('1'::('0'::[])))) modrm_mmx)))) (fun p ->
            let (op1, op2) = Obj.magic p in Obj.magic (MOVD (op1, op2))))
          (map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                  ('0'::('1'::('1'::('1'::[]))))
                  (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                    ('1'::('1'::('1'::('0'::[])))) modrm_mmx)))) (fun p ->
            let (mem, mmx) = Obj.magic p in Obj.magic (MOVD (mmx, mem))))))
  
  (** val coq_MOVQ_p : grammar **)
  
  let coq_MOVQ_p =
    alt instruction_t
      (map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                ('1'::('1'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVQ (op1, op2))))
      (map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
                ('1'::('1'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVQ (op2, op1))))
  
  (** val coq_PACKSSDW_p : grammar **)
  
  let coq_PACKSSDW_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('1'::('0'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PACKSSDW (op1, op2)))
  
  (** val coq_PACKSSWB_p : grammar **)
  
  let coq_PACKSSWB_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('0'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PACKSSWB (op1, op2)))
  
  (** val coq_PACKUSWB_p : grammar **)
  
  let coq_PACKUSWB_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PACKUSWB (op1, op2)))
  
  (** val coq_PADD_p : grammar **)
  
  let coq_PADD_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PADD (gg, op1, op2)))
  
  (** val coq_PADDS_p : grammar **)
  
  let coq_PADDS_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true false false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PADDS (gg, op1, op2)))
  
  (** val coq_PADDUS_p : grammar **)
  
  let coq_PADDUS_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true false false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PADDUS (gg, op1, op2)))
  
  (** val coq_PAND_p : grammar **)
  
  let coq_PAND_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('1'::('0'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PAND (op1, op2)))
  
  (** val coq_PANDN_p : grammar **)
  
  let coq_PANDN_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('1'::('1'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PANDN (op1, op2)))
  
  (** val coq_PCMPEQ_p : grammar **)
  
  let coq_PCMPEQ_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('0'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('0'::('1'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PCMPEQ (gg, op1, op2)))
  
  (** val coq_PCMPGT_p : grammar **)
  
  let coq_PCMPGT_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('0'::('1'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PCMPGT (gg, op1, op2)))
  
  (** val coq_PMADDWD_p : grammar **)
  
  let coq_PMADDWD_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('0'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMADDWD (op1, op2)))
  
  (** val coq_PMULHUW_p : grammar **)
  
  let coq_PMULHUW_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('0'::('0'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMULHUW (op1, op2)))
  
  (** val coq_PMULHW_p : grammar **)
  
  let coq_PMULHW_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('0'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMULHW (op1, op2)))
  
  (** val coq_PMULLW_p : grammar **)
  
  let coq_PMULLW_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('0'::('1'::('0'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMULLW (op1, op2)))
  
  (** val coq_POR_p : grammar **)
  
  let coq_POR_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('1'::('0'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (POR (op1, op2)))
  
  (** val coq_PSLL_p : grammar **)
  
  let coq_PSLL_p =
    alt instruction_t
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
                mmx_operand_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_operand_t,
                  mmx_operand_t)) (mmx_gg_p false true true true) modrm_mmx)))))
        (fun p ->
        let (gg, i) = Obj.magic p in
        let (op1, op2) = i in Obj.magic (PSLL (gg, op1, op2))))
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t, byte_t))))
        instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
          byte_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
            byte_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
              byte_t)))) ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
                byte_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_register_t, byte_t))
                  (mmx_gg_p false true true true)
                  (bitsleft (Pair_t (mmx_register_t, byte_t))
                    ('1'::('1'::('1'::('1'::('0'::[])))))
                    (seq mmx_register_t byte_t mmx_reg byte))))))) (fun p ->
        let (gg, i) = Obj.magic p in
        let (r2, imm) = i in
        Obj.magic (PSLL (gg, (MMX_Reg_op r2), (MMX_Imm_op
          (zero_extend8_32 imm))))))
  
  (** val coq_PSRA_p : grammar **)
  
  let coq_PSRA_p =
    alt instruction_t
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
                mmx_operand_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_operand_t,
                  mmx_operand_t)) (mmx_gg_p false true true false) modrm_mmx)))))
        (fun p ->
        let (gg, i) = Obj.magic p in
        let (op1, op2) = i in Obj.magic (PSRA (gg, op1, op2))))
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t, byte_t))))
        instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
          byte_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
            byte_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
              byte_t)))) ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
                byte_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_register_t, byte_t))
                  (mmx_gg_p false true true false)
                  (bitsleft (Pair_t (mmx_register_t, byte_t))
                    ('1'::('1'::('1'::('0'::('0'::[])))))
                    (seq mmx_register_t byte_t mmx_reg byte))))))) (fun p ->
        let (gg, i) = Obj.magic p in
        let (r2, imm) = i in
        Obj.magic (PSRA (gg, (MMX_Reg_op r2), (MMX_Imm_op
          (zero_extend8_32 imm))))))
  
  (** val coq_PSRL_p : grammar **)
  
  let coq_PSRL_p =
    alt instruction_t
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('1'::('0'::('1'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
                mmx_operand_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_operand_t,
                  mmx_operand_t)) (mmx_gg_p false true true true) modrm_mmx)))))
        (fun p ->
        let (gg, i) = Obj.magic p in
        let (op1, op2) = i in Obj.magic (PSRL (gg, op1, op2))))
      (map (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t, byte_t))))
        instruction_t
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
          byte_t)))) ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
            byte_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
              byte_t)))) ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_register_t,
                byte_t)))) ('0'::('0'::[]))
                (seq mmx_granularity_t (Pair_t (mmx_register_t, byte_t))
                  (mmx_gg_p false true true true)
                  (bitsleft (Pair_t (mmx_register_t, byte_t))
                    ('1'::('1'::('0'::('1'::('0'::[])))))
                    (seq mmx_register_t byte_t mmx_reg byte))))))) (fun p ->
        let (gg, i) = Obj.magic p in
        let (r2, imm) = i in
        Obj.magic (PSRL (gg, (MMX_Reg_op r2), (MMX_Imm_op
          (zero_extend8_32 imm))))))
  
  (** val coq_PSUB_p : grammar **)
  
  let coq_PSUB_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('0'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PSUB (gg, op1, op2)))
  
  (** val coq_PSUBS_p : grammar **)
  
  let coq_PSUBS_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('0'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true false false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PSUBS (gg, op1, op2)))
  
  (** val coq_PSUBUS_p : grammar **)
  
  let coq_PSUBUS_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('0'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true false false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PSUBUS (gg, op1, op2)))
  
  (** val coq_PUNPCKH_p : grammar **)
  
  let coq_PUNPCKH_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('1'::('0'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PUNPCKH (gg, op1, op2)))
  
  (** val coq_PUNPCKL_p : grammar **)
  
  let coq_PUNPCKL_p =
    map (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t, mmx_operand_t))))
      instruction_t
      (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
        mmx_operand_t)))) ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
          mmx_operand_t)))) ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
            mmx_operand_t)))) ('0'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_granularity_t, (Pair_t (mmx_operand_t,
              mmx_operand_t)))) ('0'::('0'::[]))
              (seq mmx_granularity_t (Pair_t (mmx_operand_t, mmx_operand_t))
                (mmx_gg_p true true true false) modrm_mmx))))) (fun p ->
      let (gg, i) = Obj.magic p in
      let (op1, op2) = i in Obj.magic (PUNPCKL (gg, op1, op2)))
  
  (** val coq_PXOR_p : grammar **)
  
  let coq_PXOR_p =
    map (Pair_t (mmx_operand_t, mmx_operand_t)) instruction_t
      (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (mmx_operand_t, mmx_operand_t))
              ('1'::('1'::('1'::('1'::[])))) modrm_mmx)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PXOR (op1, op2)))
  
  (** val coq_ADDPS_p : grammar **)
  
  let coq_ADDPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (ADDPS (op1, op2)))
  
  (** val coq_ADDSS_p : grammar **)
  
  let coq_ADDSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('0'::('0'::('0'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (ADDSS (op1, op2)))
  
  (** val coq_ANDNPS_p : grammar **)
  
  let coq_ANDNPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (ANDNPS (op1, op2)))
  
  (** val coq_ANDPS_p : grammar **)
  
  let coq_ANDPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (ANDPS (op1, op2)))
  
  (** val coq_CMPPS_p : grammar **)
  
  let coq_CMPPS_p =
    map (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
      instruction_t
      (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
            byte_t)) ('1'::('1'::('0'::('0'::[]))))
            (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
              byte_t)) ('0'::('0'::('1'::('0'::[]))))
              (seq (Pair_t (sse_operand_t, sse_operand_t)) byte_t modrm_xmm
                byte))))) (fun p ->
      let (i, imm) = Obj.magic p in
      let (op1, op2) = i in
      Obj.magic (CMPPS (op1, op2, (SSE_Imm_op (zero_extend8_32 imm)))))
  
  (** val coq_CMPSS_p : grammar **)
  
  let coq_CMPSS_p =
    map (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
      instruction_t
      (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
            byte_t)) ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
              byte_t)) ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
                byte_t)) ('1'::('1'::('0'::('0'::[]))))
                (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
                  byte_t)) ('0'::('0'::('1'::('0'::[]))))
                  (seq (Pair_t (sse_operand_t, sse_operand_t)) byte_t
                    modrm_xmm byte))))))) (fun p ->
      let (i, imm) = Obj.magic p in
      let (op1, op2) = i in
      Obj.magic (CMPSS (op1, op2, (SSE_Imm_op (zero_extend8_32 imm)))))
  
  (** val coq_COMISS_p : grammar **)
  
  let coq_COMISS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (COMISS (op1, op2)))
  
  (** val coq_CVTPI2PS_p : grammar **)
  
  let coq_CVTPI2PS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('1'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (CVTPI2PS (op1, op2)))
  
  (** val coq_CVTPS2PI_p : grammar **)
  
  let coq_CVTPS2PI_p =
    alt instruction_t
      (map (Pair_t (sse_register_t, mmx_register_t)) instruction_t
        (bitsleft (Pair_t (sse_register_t, mmx_register_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_register_t, mmx_register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_register_t, mmx_register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_register_t, mmx_register_t))
                ('1'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_register_t, mmx_register_t))
                  ('1'::('1'::[]))
                  (seq sse_register_t mmx_register_t sse_reg mmx_reg))))))
        (fun p ->
        let (sr, mr) = Obj.magic p in
        Obj.magic (CVTPS2PI ((SSE_XMM_Reg_op sr), (SSE_MM_Reg_op mr)))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('0'::('1'::[])))) modrm_xmm_noreg)))) (fun p ->
        let (xmm, mem) = Obj.magic p in Obj.magic (CVTPS2PI (xmm, mem))))
  
  (** val coq_CVTSI2SS_p : grammar **)
  
  let coq_CVTSI2SS_p =
    alt instruction_t
      (map (Pair_t (sse_register_t, register_t)) instruction_t
        (bitsleft (Pair_t (sse_register_t, register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_register_t, register_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_register_t, register_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_register_t, register_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_register_t, register_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (sse_register_t, register_t))
                    ('1'::('0'::('1'::('0'::[]))))
                    (bitsleft (Pair_t (sse_register_t, register_t))
                      ('1'::('1'::[]))
                      (seq sse_register_t register_t sse_reg reg))))))))
        (fun p ->
        let (sr, r2) = Obj.magic p in
        Obj.magic (CVTSI2SS ((SSE_XMM_Reg_op sr), (SSE_GP_Reg_op r2)))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                    ('1'::('0'::('1'::('0'::[])))) modrm_xmm_noreg))))))
        (fun p ->
        let (xmm, mem) = Obj.magic p in Obj.magic (CVTSI2SS (xmm, mem))))
  
  (** val coq_CVTSS2SI_p : grammar **)
  
  let coq_CVTSS2SI_p =
    alt instruction_t
      (map (Pair_t (register_t, sse_register_t)) instruction_t
        (bitsleft (Pair_t (register_t, sse_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (register_t, sse_register_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (register_t, sse_register_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (register_t, sse_register_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (register_t, sse_register_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (register_t, sse_register_t))
                    ('1'::('1'::('0'::('1'::[]))))
                    (bitsleft (Pair_t (register_t, sse_register_t))
                      ('1'::('1'::[]))
                      (seq register_t sse_register_t reg sse_reg))))))))
        (fun p ->
        let (r2, sr) = Obj.magic p in
        Obj.magic (CVTSS2SI ((SSE_GP_Reg_op r2), (SSE_XMM_Reg_op sr)))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                    ('1'::('1'::('0'::('1'::[])))) modrm_xmm_gp_noreg))))))
        (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (CVTSS2SI (op1, mem))))
  
  (** val coq_CVTTPS2PI_p : grammar **)
  
  let coq_CVTTPS2PI_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (CVTTPS2PI (op1, op2)))
  
  (** val coq_CVTTSS2SI_p : grammar **)
  
  let coq_CVTTSS2SI_p =
    alt instruction_t
      (map (Pair_t (register_t, sse_register_t)) instruction_t
        (bitsleft (Pair_t (register_t, sse_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (register_t, sse_register_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (register_t, sse_register_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (register_t, sse_register_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (register_t, sse_register_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (register_t, sse_register_t))
                    ('1'::('1'::('0'::('0'::[]))))
                    (bitsleft (Pair_t (register_t, sse_register_t))
                      ('1'::('1'::[]))
                      (seq register_t sse_register_t reg sse_reg))))))))
        (fun p ->
        let (r2, sr) = Obj.magic p in
        Obj.magic (CVTTSS2SI ((SSE_GP_Reg_op r2), (SSE_XMM_Reg_op sr)))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('1'::('0'::[]))))
                  (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                    ('1'::('1'::('0'::('0'::[])))) modrm_xmm_gp_noreg))))))
        (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (CVTTSS2SI (op1, mem))))
  
  (** val coq_DIVPS_p : grammar **)
  
  let coq_DIVPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (DIVPS (op1, op2)))
  
  (** val coq_DIVSS_p : grammar **)
  
  let coq_DIVSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('1'::('1'::('0'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (DIVSS (op1, op2)))
  
  (** val coq_LDMXCSR_p : grammar **)
  
  let coq_LDMXCSR_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('1'::('0'::('1'::('0'::[]))))
            (bitsleft sse_operand_t ('1'::('1'::('1'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic (LDMXCSR (Obj.magic x)))
  
  (** val coq_MAXPS_p : grammar **)
  
  let coq_MAXPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MAXPS (op1, op2)))
  
  (** val coq_MAXSS_p : grammar **)
  
  let coq_MAXSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('1'::('1'::('1'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MAXSS (op1, op2)))
  
  (** val coq_MINPS_p : grammar **)
  
  let coq_MINPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MINPS (op1, op2)))
  
  (** val coq_MINSS_p : grammar **)
  
  let coq_MINSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('1'::('0'::('1'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MINSS (op1, op2)))
  
  (** val coq_MOVAPS_p : grammar **)
  
  let coq_MOVAPS_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('0'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVAPS (op1, op2))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('0'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVAPS (op1, op2))))
  
  (** val coq_MOVHLPS_p : grammar **)
  
  let coq_MOVHLPS_p =
    map (Pair_t (sse_register_t, sse_register_t)) instruction_t
      (bitsleft (Pair_t (sse_register_t, sse_register_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_register_t, sse_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_register_t, sse_register_t))
            ('0'::('0'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_register_t, sse_register_t))
              ('0'::('0'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_register_t, sse_register_t))
                ('1'::('1'::[]))
                (seq sse_register_t sse_register_t sse_reg sse_reg))))))
      (fun p ->
      let (sr1, sr2) = Obj.magic p in
      Obj.magic (MOVHLPS ((SSE_XMM_Reg_op sr1), (SSE_XMM_Reg_op sr2))))
  
  (** val coq_MOVHPS_p : grammar **)
  
  let coq_MOVHPS_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('1'::('0'::[])))) modrm_xmm_noreg)))) (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (MOVHPS (op1, mem))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('1'::('1'::[])))) modrm_xmm_noreg)))) (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (MOVHPS (mem, op1))))
  
  (** val coq_MOVLHPS_p : grammar **)
  
  let coq_MOVLHPS_p =
    map (Pair_t (sse_register_t, sse_register_t)) instruction_t
      (bitsleft (Pair_t (sse_register_t, sse_register_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_register_t, sse_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_register_t, sse_register_t))
            ('0'::('0'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_register_t, sse_register_t))
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_register_t, sse_register_t))
                ('1'::('1'::[]))
                (seq sse_register_t sse_register_t sse_reg sse_reg))))))
      (fun p ->
      let (sr1, sr2) = Obj.magic p in
      Obj.magic (MOVLHPS ((SSE_XMM_Reg_op sr1), (SSE_XMM_Reg_op sr2))))
  
  (** val coq_MOVLPS_p : grammar **)
  
  let coq_MOVLPS_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('1'::('0'::[])))) modrm_xmm_noreg)))) (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (MOVLPS (op1, mem))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('1'::('1'::[])))) modrm_xmm_noreg)))) (fun p ->
        let (op1, mem) = Obj.magic p in Obj.magic (MOVLPS (mem, op1))))
  
  (** val coq_MOVMSKPS_p : grammar **)
  
  let coq_MOVMSKPS_p =
    map (Pair_t (register_t, sse_register_t)) instruction_t
      (bitsleft (Pair_t (register_t, sse_register_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (register_t, sse_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (register_t, sse_register_t))
            ('0'::('0'::('0'::('1'::[]))))
            (bitsleft (Pair_t (register_t, sse_register_t))
              ('0'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (register_t, sse_register_t))
                ('1'::('1'::[])) (seq register_t sse_register_t reg sse_reg))))))
      (fun p ->
      let (r2, sr) = Obj.magic p in
      Obj.magic (MOVMSKPS ((SSE_GP_Reg_op r2), (SSE_XMM_Reg_op sr))))
  
  (** val coq_MOVSS_p : grammar **)
  
  let coq_MOVSS_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('0'::('1'::[]))))
                  (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                    ('0'::('0'::('0'::('0'::[])))) modrm_xmm)))))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVSS (op1, op2))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('1'::('1'::('1'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('0'::('1'::[]))))
                  (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                    ('0'::('0'::('0'::('1'::[])))) modrm_xmm)))))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVSS (op2, op1))))
  
  (** val coq_MOVUPS_p : grammar **)
  
  let coq_MOVUPS_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVUPS (op1, op2))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (MOVUPS (op2, op1))))
  
  (** val coq_MULPS_p : grammar **)
  
  let coq_MULPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MULPS (op1, op2)))
  
  (** val coq_MULSS_p : grammar **)
  
  let coq_MULSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('0'::('0'::('1'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (MULSS (op1, op2)))
  
  (** val coq_ORPS_p : grammar **)
  
  let coq_ORPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('1'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (ORPS (op1, op2)))
  
  (** val coq_RCPPS_p : grammar **)
  
  let coq_RCPPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('1'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (RCPPS (op1, op2)))
  
  (** val coq_RCPSS_p : grammar **)
  
  let coq_RCPSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('1'::('1'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (RCPSS (op1, op2)))
  
  (** val coq_RSQRTPS_p : grammar **)
  
  let coq_RSQRTPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('1'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (RSQRTPS (op1, op2)))
  
  (** val coq_RSQRTSS_p : grammar **)
  
  let coq_RSQRTSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('1'::('0'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (RSQRTSS (op1, op2)))
  
  (** val coq_SHUFPS_p : grammar **)
  
  let coq_SHUFPS_p =
    map (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
      instruction_t
      (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
            byte_t)) ('1'::('1'::('0'::('0'::[]))))
            (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
              byte_t)) ('0'::('1'::('1'::('0'::[]))))
              (seq (Pair_t (sse_operand_t, sse_operand_t)) byte_t modrm_xmm
                byte))))) (fun p ->
      let (i, imm) = Obj.magic p in
      let (op1, op2) = i in
      Obj.magic (SHUFPS (op1, op2, (SSE_Imm_op (zero_extend8_32 imm)))))
  
  (** val coq_SQRTPS_p : grammar **)
  
  let coq_SQRTPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('0'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (SQRTPS (op1, op2)))
  
  (** val coq_SQRTSS_p : grammar **)
  
  let coq_SQRTSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('0'::('0'::('0'::('1'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (SQRTSS (op1, op2)))
  
  (** val coq_STMXCSR_p : grammar **)
  
  let coq_STMXCSR_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('1'::('0'::('1'::('0'::[]))))
            (bitsleft sse_operand_t ('1'::('1'::('1'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic (STMXCSR (Obj.magic x)))
  
  (** val coq_SUBPS_p : grammar **)
  
  let coq_SUBPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (SUBPS (op1, op2)))
  
  (** val coq_SUBSS_p : grammar **)
  
  let coq_SUBSS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('1'::('1'::('1'::('1'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('1'::('0'::('1'::[]))))
                (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                  ('1'::('1'::('0'::('0'::[])))) modrm_xmm)))))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (SUBSS (op1, op2)))
  
  (** val coq_UCOMISS_p : grammar **)
  
  let coq_UCOMISS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (UCOMISS (op1, op2)))
  
  (** val coq_UNPCKHPS_p : grammar **)
  
  let coq_UNPCKHPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('0'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (UNPCKHPS (op1, op2)))
  
  (** val coq_UNPCKLPS_p : grammar **)
  
  let coq_UNPCKLPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('0'::('0'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (UNPCKLPS (op1, op2)))
  
  (** val coq_XORPS_p : grammar **)
  
  let coq_XORPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('1'::('1'::[])))) modrm_xmm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (XORPS (op1, op2)))
  
  (** val coq_PAVGB_p : grammar **)
  
  let coq_PAVGB_p =
    alt instruction_t
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('0'::('0'::[])))) modrm_mm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (PAVGB (op1, op2))))
      (map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[]))))
              (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
                ('0'::('0'::('1'::('1'::[])))) modrm_mm)))) (fun p ->
        let (op1, op2) = Obj.magic p in Obj.magic (PAVGB (op2, op1))))
  
  (** val coq_PEXTRW_p : grammar **)
  
  let coq_PEXTRW_p =
    map (Pair_t (register_t, (Pair_t (mmx_register_t, byte_t))))
      instruction_t
      (bitsleft (Pair_t (register_t, (Pair_t (mmx_register_t, byte_t))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (register_t, (Pair_t (mmx_register_t, byte_t))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (register_t, (Pair_t (mmx_register_t, byte_t))))
            ('1'::('1'::('0'::('0'::[]))))
            (bitsleft (Pair_t (register_t, (Pair_t (mmx_register_t,
              byte_t)))) ('0'::('1'::('0'::('1'::[]))))
              (bitsleft (Pair_t (register_t, (Pair_t (mmx_register_t,
                byte_t)))) ('1'::('1'::[]))
                (seq register_t (Pair_t (mmx_register_t, byte_t)) reg
                  (seq mmx_register_t byte_t mmx_reg byte))))))) (fun p ->
      let (r32, i) = Obj.magic p in
      let (mmx, imm) = i in
      Obj.magic (PEXTRW ((SSE_GP_Reg_op r32), (SSE_MM_Reg_op mmx),
        (SSE_Imm_op (zero_extend8_32 imm)))))
  
  (** val coq_PINSRW_p : grammar **)
  
  let coq_PINSRW_p =
    alt instruction_t
      (map (Pair_t (mmx_register_t, (Pair_t (register_t, byte_t))))
        instruction_t
        (bitsleft (Pair_t (mmx_register_t, (Pair_t (register_t, byte_t))))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t (mmx_register_t, (Pair_t (register_t, byte_t))))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_register_t, (Pair_t (register_t,
              byte_t)))) ('1'::('1'::('0'::('0'::[]))))
              (bitsleft (Pair_t (mmx_register_t, (Pair_t (register_t,
                byte_t)))) ('0'::('1'::('0'::('0'::[]))))
                (bitsleft (Pair_t (mmx_register_t, (Pair_t (register_t,
                  byte_t)))) ('1'::('1'::[]))
                  (seq mmx_register_t (Pair_t (register_t, byte_t)) mmx_reg
                    (seq register_t byte_t reg byte))))))) (fun p ->
        let (mmx, i) = Obj.magic p in
        let (r32, imm) = i in
        Obj.magic (PINSRW ((SSE_MM_Reg_op mmx), (SSE_GP_Reg_op r32),
          (SSE_Imm_op (zero_extend8_32 imm))))))
      (map (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
        instruction_t
        (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
          ('0'::('0'::('0'::('0'::[]))))
          (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
            byte_t)) ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
              byte_t)) ('1'::('1'::('0'::('0'::[]))))
              (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
                byte_t)) ('0'::('1'::('0'::('0'::[]))))
                (seq (Pair_t (sse_operand_t, sse_operand_t)) byte_t
                  modrm_mm_noreg byte))))) (fun p ->
        let (i, imm) = Obj.magic p in
        let (op1, mem) = i in
        Obj.magic (PINSRW (op1, mem, (SSE_Imm_op (zero_extend8_32 imm))))))
  
  (** val coq_PMAXSW_p : grammar **)
  
  let coq_PMAXSW_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[])))) modrm_mm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMAXSW (op1, op2)))
  
  (** val coq_PMAXUB_p : grammar **)
  
  let coq_PMAXUB_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('1'::('1'::('0'::[])))) modrm_mm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMAXUB (op1, op2)))
  
  (** val coq_PMINSW_p : grammar **)
  
  let coq_PMINSW_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('1'::('0'::[])))) modrm_mm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMINSW (op1, op2)))
  
  (** val coq_PMINUB_p : grammar **)
  
  let coq_PMINUB_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('1'::('0'::[])))) modrm_mm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PMINUB (op1, op2)))
  
  (** val coq_PMOVMSKB_p : grammar **)
  
  let coq_PMOVMSKB_p =
    map (Pair_t (register_t, mmx_register_t)) instruction_t
      (bitsleft (Pair_t (register_t, mmx_register_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (register_t, mmx_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (register_t, mmx_register_t))
            ('1'::('1'::('0'::('1'::[]))))
            (bitsleft (Pair_t (register_t, mmx_register_t))
              ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (register_t, mmx_register_t))
                ('1'::('1'::[])) (seq register_t mmx_register_t reg mmx_reg))))))
      (fun p ->
      let (r2, mr) = Obj.magic p in
      Obj.magic (PMOVMSKB ((SSE_GP_Reg_op r2), (SSE_MM_Reg_op mr))))
  
  (** val coq_PSADBW_p : grammar **)
  
  let coq_PSADBW_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('1'::('0'::[])))) modrm_mm)))) (fun p ->
      let (op1, op2) = Obj.magic p in Obj.magic (PSADBW (op1, op2)))
  
  (** val coq_PSHUFW_p : grammar **)
  
  let coq_PSHUFW_p =
    map (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
      instruction_t
      (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)), byte_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
            byte_t)) ('0'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t ((Pair_t (sse_operand_t, sse_operand_t)),
              byte_t)) ('0'::('0'::('0'::('0'::[]))))
              (seq (Pair_t (sse_operand_t, sse_operand_t)) byte_t modrm_mm
                byte))))) (fun p ->
      let (i, imm) = Obj.magic p in
      let (op1, op2) = i in
      Obj.magic (PSHUFW (op1, op2, (SSE_Imm_op (zero_extend8_32 imm)))))
  
  (** val coq_MASKMOVQ_p : grammar **)
  
  let coq_MASKMOVQ_p =
    map (Pair_t (mmx_register_t, mmx_register_t)) instruction_t
      (bitsleft (Pair_t (mmx_register_t, mmx_register_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (mmx_register_t, mmx_register_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (mmx_register_t, mmx_register_t))
            ('1'::('1'::('1'::('1'::[]))))
            (bitsleft (Pair_t (mmx_register_t, mmx_register_t))
              ('0'::('1'::('1'::('1'::[]))))
              (bitsleft (Pair_t (mmx_register_t, mmx_register_t))
                ('1'::('1'::[]))
                (seq mmx_register_t mmx_register_t mmx_reg mmx_reg))))))
      (fun p ->
      let (mr1, mr2) = Obj.magic p in
      Obj.magic (MASKMOVQ ((SSE_MM_Reg_op mr1), (SSE_MM_Reg_op mr2))))
  
  (** val coq_MOVNTPS_p : grammar **)
  
  let coq_MOVNTPS_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('0'::('0'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('1'::('0'::('1'::('1'::[])))) modrm_xmm_noreg)))) (fun p ->
      let (op1, mem) = Obj.magic p in Obj.magic (MOVNTPS (mem, op1)))
  
  (** val coq_MOVNTQ_p : grammar **)
  
  let coq_MOVNTQ_p =
    map (Pair_t (sse_operand_t, sse_operand_t)) instruction_t
      (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
            ('1'::('1'::('1'::('0'::[]))))
            (bitsleft (Pair_t (sse_operand_t, sse_operand_t))
              ('0'::('1'::('1'::('1'::[])))) modrm_mm_noreg)))) (fun p ->
      let (op1, mem) = Obj.magic p in Obj.magic (MOVNTQ (mem, op1)))
  
  (** val coq_PREFETCHT0_p : grammar **)
  
  let coq_PREFETCHT0_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('0'::('0'::('0'::('1'::[]))))
            (bitsleft sse_operand_t ('1'::('0'::('0'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('0'::('1'::[])))))))) (fun x ->
      Obj.magic (PREFETCHT0 (Obj.magic x)))
  
  (** val coq_PREFETCHT1_p : grammar **)
  
  let coq_PREFETCHT1_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('0'::('0'::('0'::('1'::[]))))
            (bitsleft sse_operand_t ('1'::('0'::('0'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('1'::('0'::[])))))))) (fun x ->
      Obj.magic (PREFETCHT1 (Obj.magic x)))
  
  (** val coq_PREFETCHT2_p : grammar **)
  
  let coq_PREFETCHT2_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('0'::('0'::('0'::('1'::[]))))
            (bitsleft sse_operand_t ('1'::('0'::('0'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('1'::('1'::[])))))))) (fun x ->
      Obj.magic (PREFETCHT2 (Obj.magic x)))
  
  (** val coq_PREFETCHNTA_p : grammar **)
  
  let coq_PREFETCHNTA_p =
    map sse_operand_t instruction_t
      (bitsleft sse_operand_t ('0'::('0'::('0'::('0'::[]))))
        (bitsleft sse_operand_t ('1'::('1'::('1'::('1'::[]))))
          (bitsleft sse_operand_t ('0'::('0'::('0'::('1'::[]))))
            (bitsleft sse_operand_t ('1'::('0'::('0'::('0'::[]))))
              (ext_op_modrm_sse ('0'::('0'::('0'::[])))))))) (fun x ->
      Obj.magic (PREFETCHNTA (Obj.magic x)))
  
  (** val coq_SFENCE_p : grammar **)
  
  let coq_SFENCE_p =
    map (bits_n (length0 ('1'::('0'::('0'::('0'::[])))))) instruction_t
      (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
        ('0'::('0'::('0'::('0'::[]))))
        (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
            ('1'::('0'::('1'::('0'::[]))))
            (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
              ('1'::('1'::('1'::('0'::[]))))
              (bitsleft (bits_n (length0 ('1'::('0'::('0'::('0'::[]))))))
                ('1'::('1'::('1'::('1'::[]))))
                (bits ('1'::('0'::('0'::('0'::[])))))))))) (fun x ->
      Obj.magic SFENCE)
  
  (** val list2pair_t : type0 list -> type0 **)
  
  let rec list2pair_t = function
  | [] -> Unit_t
  | r2 :: l' ->
    (match l' with
     | [] -> Pair_t (r2, (list2pair_t l'))
     | r' :: l0 ->
       (match l0 with
        | [] -> Pair_t (r2, r')
        | t0 :: l1 -> Pair_t (r2, (list2pair_t l'))))
  
  (** val lock_p : grammar **)
  
  let lock_p =
    map (bits_n (length0 ('0'::('0'::('0'::('0'::[])))))) lock_or_rep_t
      (bitsleft (bits_n (length0 ('0'::('0'::('0'::('0'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('0'::('0'::('0'::('0'::[]))))))
      (fun x -> Obj.magic Lock)
  
  (** val rep_or_repn_p : grammar **)
  
  let rep_or_repn_p =
    alt lock_or_rep_t
      (map (bits_n (length0 ('0'::('0'::('1'::('0'::[])))))) lock_or_rep_t
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('0'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bits ('0'::('0'::('1'::('0'::[])))))) (fun x -> Obj.magic Repn))
      (map (bits_n (length0 ('0'::('0'::('1'::('1'::[])))))) lock_or_rep_t
        (bitsleft (bits_n (length0 ('0'::('0'::('1'::('1'::[]))))))
          ('1'::('1'::('1'::('1'::[]))))
          (bits ('0'::('0'::('1'::('1'::[])))))) (fun x -> Obj.magic Rep))
  
  (** val rep_p : grammar **)
  
  let rep_p =
    map (bits_n (length0 ('0'::('0'::('1'::('1'::[])))))) lock_or_rep_t
      (bitsleft (bits_n (length0 ('0'::('0'::('1'::('1'::[]))))))
        ('1'::('1'::('1'::('1'::[])))) (bits ('0'::('0'::('1'::('1'::[]))))))
      (fun x -> Obj.magic Rep)
  
  (** val lock_or_rep_p : grammar **)
  
  let lock_or_rep_p =
    bitsleft lock_or_rep_t ('1'::('1'::('1'::('1'::[]))))
      (alt lock_or_rep_t
        (map (bits_n (length0 ('0'::('0'::('0'::('0'::[])))))) lock_or_rep_t
          (bits ('0'::('0'::('0'::('0'::[]))))) (fun x -> Obj.magic Lock))
        (alt lock_or_rep_t
          (map (bits_n (length0 ('0'::('0'::('1'::('0'::[]))))))
            lock_or_rep_t (bits ('0'::('0'::('1'::('0'::[]))))) (fun x ->
            Obj.magic Repn))
          (map (bits_n (length0 ('0'::('0'::('1'::('1'::[]))))))
            lock_or_rep_t (bits ('0'::('0'::('1'::('1'::[]))))) (fun x ->
            Obj.magic Rep))))
  
  (** val segment_override_p : grammar **)
  
  let segment_override_p =
    alt segment_register_t
      (map (bits_n (length0 ('1'::('1'::('1'::('0'::[]))))))
        segment_register_t
        (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::[]))))))
          ('0'::('0'::('1'::('0'::[]))))
          (bits ('1'::('1'::('1'::('0'::[])))))) (fun x -> Obj.magic CS))
      (alt segment_register_t
        (map (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
          segment_register_t
          (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
            ('0'::('0'::('1'::('1'::[]))))
            (bits ('0'::('1'::('1'::('0'::[])))))) (fun x -> Obj.magic SS))
        (alt segment_register_t
          (map (bits_n (length0 ('1'::('1'::('1'::('0'::[]))))))
            segment_register_t
            (bitsleft (bits_n (length0 ('1'::('1'::('1'::('0'::[]))))))
              ('0'::('0'::('1'::('1'::[]))))
              (bits ('1'::('1'::('1'::('0'::[])))))) (fun x -> Obj.magic DS))
          (alt segment_register_t
            (map (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
              segment_register_t
              (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
                ('0'::('0'::('1'::('0'::[]))))
                (bits ('0'::('1'::('1'::('0'::[])))))) (fun x ->
              Obj.magic ES))
            (alt segment_register_t
              (map (bits_n (length0 ('0'::('1'::('0'::('0'::[]))))))
                segment_register_t
                (bitsleft (bits_n (length0 ('0'::('1'::('0'::('0'::[]))))))
                  ('0'::('1'::('1'::('0'::[]))))
                  (bits ('0'::('1'::('0'::('0'::[])))))) (fun x ->
                Obj.magic FS))
              (map (bits_n (length0 ('0'::('1'::('0'::('1'::[]))))))
                segment_register_t
                (bitsleft (bits_n (length0 ('0'::('1'::('0'::('1'::[]))))))
                  ('0'::('1'::('1'::('0'::[]))))
                  (bits ('0'::('1'::('0'::('1'::[])))))) (fun x ->
                Obj.magic GS))))))
  
  (** val op_override_p : grammar **)
  
  let op_override_p =
    map (bits_n (length0 ('0'::('1'::('1'::('0'::[])))))) bool_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('0'::[]))))))
        ('0'::('1'::('1'::('0'::[])))) (bits ('0'::('1'::('1'::('0'::[]))))))
      (fun x -> Obj.magic true)
  
  (** val addr_override_p : grammar **)
  
  let addr_override_p =
    map (bits_n (length0 ('0'::('1'::('1'::('1'::[])))))) bool_t
      (bitsleft (bits_n (length0 ('0'::('1'::('1'::('1'::[]))))))
        ('0'::('1'::('1'::('0'::[])))) (bits ('0'::('1'::('1'::('1'::[]))))))
      (fun x -> Obj.magic true)
  
  (** val perm2 : type0 -> type0 -> grammar -> grammar -> grammar **)
  
  let perm2 t1 t2 p1 p2 =
    alt (Pair_t (t1, t2)) (seq t1 t2 p1 p2)
      (map (Pair_t (t2, t1)) (Pair_t (t1, t2)) (seq t2 t1 p2 p1) (fun p ->
        let (a, b) = Obj.magic p in Obj.magic (b, a)))
  
  (** val perm3 :
      type0 -> type0 -> type0 -> grammar -> grammar -> grammar -> grammar **)
  
  let perm3 t1 t2 t3 p1 p2 p3 =
    let r_t = Pair_t (t1, (Pair_t (t2, t3))) in
    alt (Pair_t (t1, (Pair_t (t2, t3))))
      (seq t1 (Pair_t (t2, t3)) p1 (perm2 t2 t3 p2 p3))
      (alt r_t
        (map (Pair_t (t2, (Pair_t (t1, t3)))) r_t
          (seq t2 (Pair_t (t1, t3)) p2 (perm2 t1 t3 p1 p3)) (fun p ->
          let (b, i) = Obj.magic p in let (a, c) = i in Obj.magic (a, (b, c))))
        (map (Pair_t (t3, (Pair_t (t1, t2)))) r_t
          (seq t3 (Pair_t (t1, t2)) p3 (perm2 t1 t2 p1 p2)) (fun p ->
          let (c, i) = Obj.magic p in let (a, b) = i in Obj.magic (a, (b, c)))))
  
  (** val perm4 :
      type0 -> type0 -> type0 -> type0 -> grammar -> grammar -> grammar ->
      grammar -> grammar **)
  
  let perm4 t1 t2 t3 t4 p1 p2 p3 p4 =
    let r_t = Pair_t (t1, (Pair_t (t2, (Pair_t (t3, t4))))) in
    alt (Pair_t (t1, (Pair_t (t2, (Pair_t (t3, t4))))))
      (seq t1 (Pair_t (t2, (Pair_t (t3, t4)))) p1 (perm3 t2 t3 t4 p2 p3 p4))
      (alt r_t
        (map (Pair_t (t2, (Pair_t (t1, (Pair_t (t3, t4)))))) r_t
          (seq t2 (Pair_t (t1, (Pair_t (t3, t4)))) p2
            (perm3 t1 t3 t4 p1 p3 p4)) (fun p ->
          let (b, i) = Obj.magic p in
          let (a, i0) = i in let (c, d) = i0 in Obj.magic (a, (b, (c, d)))))
        (alt r_t
          (map (Pair_t (t3, (Pair_t (t1, (Pair_t (t2, t4)))))) r_t
            (seq t3 (Pair_t (t1, (Pair_t (t2, t4)))) p3
              (perm3 t1 t2 t4 p1 p2 p4)) (fun p ->
            let (c, i) = Obj.magic p in
            let (a, i0) = i in let (b, d) = i0 in Obj.magic (a, (b, (c, d)))))
          (map (Pair_t (t4, (Pair_t (t1, (Pair_t (t2, t3)))))) r_t
            (seq t4 (Pair_t (t1, (Pair_t (t2, t3)))) p4
              (perm3 t1 t2 t3 p1 p2 p3)) (fun p ->
            let (d, i) = Obj.magic p in
            let (a, i0) = i in let (b, c) = i0 in Obj.magic (a, (b, (c, d)))))))
  
  (** val option_perm : X86_PARSER_ARG.user_type -> grammar -> grammar **)
  
  let option_perm t1 p1 =
    let r_t = option_t t1 in
    alt r_t (map Unit_t r_t Eps (fun p -> Obj.magic None))
      (map (User_t t1) r_t p1 (fun p -> Obj.magic (Some p)))
  
  (** val option_perm2 :
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type -> grammar ->
      grammar -> grammar **)
  
  let option_perm2 t1 t2 p1 p2 =
    let r_t = Pair_t ((option_t t1), (option_t t2)) in
    alt r_t (map Unit_t r_t Eps (fun p -> Obj.magic (None, None)))
      (alt r_t (map (User_t t1) r_t p1 (fun p -> Obj.magic ((Some p), None)))
        (alt r_t
          (map (User_t t2) r_t p2 (fun p -> Obj.magic (None, (Some p))))
          (map (Pair_t ((User_t t1), (User_t t2))) r_t
            (perm2 (User_t t1) (User_t t2) p1 p2) (fun p ->
            let (a, b) = Obj.magic p in Obj.magic ((Some a), (Some b))))))
  
  (** val option_perm3 :
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type ->
      X86_PARSER_ARG.user_type -> grammar -> grammar -> grammar -> grammar **)
  
  let option_perm3 t1 t2 t3 p1 p2 p3 =
    let r_t = Pair_t ((option_t t1), (Pair_t ((option_t t2), (option_t t3))))
    in
    alt r_t (map Unit_t r_t Eps (fun p -> Obj.magic (None, (None, None))))
      (alt r_t
        (map (User_t t1) r_t p1 (fun p ->
          Obj.magic ((Some p), (None, None))))
        (alt r_t
          (map (User_t t2) r_t p2 (fun p ->
            Obj.magic (None, ((Some p), None))))
          (alt r_t
            (map (User_t t3) r_t p3 (fun p ->
              Obj.magic (None, (None, (Some p)))))
            (alt r_t
              (map (Pair_t ((User_t t1), (User_t t2))) r_t
                (perm2 (User_t t1) (User_t t2) p1 p2) (fun p ->
                let (a, b) = Obj.magic p in
                Obj.magic ((Some a), ((Some b), None))))
              (alt r_t
                (map (Pair_t ((User_t t1), (User_t t3))) r_t
                  (perm2 (User_t t1) (User_t t3) p1 p3) (fun p ->
                  let (a, c) = Obj.magic p in
                  Obj.magic ((Some a), (None, (Some c)))))
                (alt r_t
                  (map (Pair_t ((User_t t2), (User_t t3))) r_t
                    (perm2 (User_t t2) (User_t t3) p2 p3) (fun p ->
                    let (b, c) = Obj.magic p in
                    Obj.magic (None, ((Some b), (Some c)))))
                  (map (Pair_t ((User_t t1), (Pair_t ((User_t t2), (User_t
                    t3))))) r_t
                    (perm3 (User_t t1) (User_t t2) (User_t t3) p1 p2 p3)
                    (fun p ->
                    let (a, i) = Obj.magic p in
                    let (b, c) = i in
                    Obj.magic ((Some a), ((Some b), (Some c)))))))))))
  
  (** val option_perm2_variation :
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type -> grammar ->
      grammar -> grammar **)
  
  let option_perm2_variation t1 t2 p1 p2 =
    let r_t = Pair_t ((option_t t1), (User_t t2)) in
    alt r_t (map (User_t t2) r_t p2 (fun p -> Obj.magic (None, p)))
      (map (Pair_t ((User_t t1), (User_t t2))) r_t
        (perm2 (User_t t1) (User_t t2) p1 p2) (fun p ->
        let (a, b) = Obj.magic p in Obj.magic ((Some a), b)))
  
  (** val option_perm3_variation :
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type ->
      X86_PARSER_ARG.user_type -> grammar -> grammar -> grammar -> grammar **)
  
  let option_perm3_variation t1 t2 t3 p1 p2 p3 =
    let r_t = Pair_t ((option_t t1), (Pair_t ((option_t t2), (User_t t3))))
    in
    alt r_t (map (User_t t3) r_t p3 (fun p -> Obj.magic (None, (None, p))))
      (alt r_t
        (map (Pair_t ((User_t t1), (User_t t3))) r_t
          (perm2 (User_t t1) (User_t t3) p1 p3) (fun p ->
          let (a, c) = Obj.magic p in Obj.magic ((Some a), (None, c))))
        (alt r_t
          (map (Pair_t ((User_t t2), (User_t t3))) r_t
            (perm2 (User_t t2) (User_t t3) p2 p3) (fun p ->
            let (b, c) = Obj.magic p in Obj.magic (None, ((Some b), c))))
          (map (Pair_t ((User_t t1), (Pair_t ((User_t t2), (User_t t3)))))
            r_t (perm3 (User_t t1) (User_t t2) (User_t t3) p1 p2 p3)
            (fun p ->
            let (a, i) = Obj.magic p in
            let (b, c) = i in Obj.magic ((Some a), ((Some b), c))))))
  
  (** val option_perm4 :
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type ->
      X86_PARSER_ARG.user_type -> X86_PARSER_ARG.user_type -> grammar ->
      grammar -> grammar -> grammar -> grammar **)
  
  let option_perm4 t1 t2 t3 t4 p1 p2 p3 p4 =
    let r_t = Pair_t ((option_t t1), (Pair_t ((option_t t2), (Pair_t
      ((option_t t3), (option_t t4))))))
    in
    alt r_t
      (map Unit_t r_t Eps (fun p -> Obj.magic (None, (None, (None, None)))))
      (alt r_t
        (map (User_t t1) r_t p1 (fun p ->
          Obj.magic ((Some p), (None, (None, None)))))
        (alt r_t
          (map (User_t t2) r_t p2 (fun p ->
            Obj.magic (None, ((Some p), (None, None)))))
          (alt r_t
            (map (User_t t3) r_t p3 (fun p ->
              Obj.magic (None, (None, ((Some p), None)))))
            (alt r_t
              (map (User_t t4) r_t p4 (fun p ->
                Obj.magic (None, (None, (None, (Some p))))))
              (alt r_t
                (map (Pair_t ((User_t t1), (User_t t2))) r_t
                  (perm2 (User_t t1) (User_t t2) p1 p2) (fun p ->
                  let (a, b) = Obj.magic p in
                  Obj.magic ((Some a), ((Some b), (None, None)))))
                (alt r_t
                  (map (Pair_t ((User_t t1), (User_t t3))) r_t
                    (perm2 (User_t t1) (User_t t3) p1 p3) (fun p ->
                    let (a, c) = Obj.magic p in
                    Obj.magic ((Some a), (None, ((Some c), None)))))
                  (alt r_t
                    (map (Pair_t ((User_t t1), (User_t t4))) r_t
                      (perm2 (User_t t1) (User_t t4) p1 p4) (fun p ->
                      let (a, d) = Obj.magic p in
                      Obj.magic ((Some a), (None, (None, (Some d))))))
                    (alt r_t
                      (map (Pair_t ((User_t t2), (User_t t3))) r_t
                        (perm2 (User_t t2) (User_t t3) p2 p3) (fun p ->
                        let (b, c) = Obj.magic p in
                        Obj.magic (None, ((Some b), ((Some c), None)))))
                      (alt r_t
                        (map (Pair_t ((User_t t2), (User_t t4))) r_t
                          (perm2 (User_t t2) (User_t t4) p2 p4) (fun p ->
                          let (b, d) = Obj.magic p in
                          Obj.magic (None, ((Some b), (None, (Some d))))))
                        (alt r_t
                          (map (Pair_t ((User_t t3), (User_t t4))) r_t
                            (perm2 (User_t t3) (User_t t4) p3 p4) (fun p ->
                            let (c, d) = Obj.magic p in
                            Obj.magic (None, (None, ((Some c), (Some d))))))
                          (alt r_t
                            (map (Pair_t ((User_t t1), (Pair_t ((User_t t2),
                              (User_t t3))))) r_t
                              (perm3 (User_t t1) (User_t t2) (User_t t3) p1
                                p2 p3) (fun p ->
                              let (a, i) = Obj.magic p in
                              let (b, c) = i in
                              Obj.magic ((Some a), ((Some b), ((Some c),
                                None)))))
                            (alt r_t
                              (map (Pair_t ((User_t t1), (Pair_t ((User_t
                                t3), (User_t t4))))) r_t
                                (perm3 (User_t t1) (User_t t3) (User_t t4) p1
                                  p3 p4) (fun p ->
                                let (a, i) = Obj.magic p in
                                let (c, d) = i in
                                Obj.magic ((Some a), (None, ((Some c), (Some
                                  d))))))
                              (alt r_t
                                (map (Pair_t ((User_t t1), (Pair_t ((User_t
                                  t2), (User_t t4))))) r_t
                                  (perm3 (User_t t1) (User_t t2) (User_t t4)
                                    p1 p2 p4) (fun p ->
                                  let (a, i) = Obj.magic p in
                                  let (b, d) = i in
                                  Obj.magic ((Some a), ((Some b), (None,
                                    (Some d))))))
                                (alt r_t
                                  (map (Pair_t ((User_t t2), (Pair_t ((User_t
                                    t3), (User_t t4))))) r_t
                                    (perm3 (User_t t2) (User_t t3) (User_t
                                      t4) p2 p3 p4) (fun p ->
                                    let (b, i) = Obj.magic p in
                                    let (c, d) = i in
                                    Obj.magic (None, ((Some b), ((Some c),
                                      (Some d))))))
                                  (map (Pair_t ((User_t t1), (Pair_t ((User_t
                                    t2), (Pair_t ((User_t t3), (User_t
                                    t4))))))) r_t
                                    (perm4 (User_t t1) (User_t t2) (User_t
                                      t3) (User_t t4) p1 p2 p3 p4) (fun p ->
                                    let (a, i) = Obj.magic p in
                                    let (b, i0) = i in
                                    let (c, d) = i0 in
                                    Obj.magic ((Some a), ((Some b), ((Some
                                      c), (Some d))))))))))))))))))))
  
  (** val opt2b : bool option -> bool -> bool **)
  
  let opt2b a default =
    match a with
    | Some b -> b
    | None -> default
  
  (** val prefix_grammar_rep : grammar **)
  
  let prefix_grammar_rep =
    map (Pair_t ((option_t X86_PARSER_ARG.Lock_or_Rep_t), (Pair_t
      ((option_t X86_PARSER_ARG.Segment_Register_t),
      (option_t X86_PARSER_ARG.Bool_t))))) prefix_t
      (option_perm3 X86_PARSER_ARG.Lock_or_Rep_t
        X86_PARSER_ARG.Segment_Register_t X86_PARSER_ARG.Bool_t rep_p
        segment_override_p op_override_p) (fun p ->
      let (l, i) = Obj.magic p in
      let (s, op) = i in
      Obj.magic { lock_rep = l; seg_override = s; op_override =
        (opt2b op false); addr_override = false })
  
  (** val instr_grammars_rep : grammar list **)
  
  let instr_grammars_rep =
    coq_INS_p :: (coq_OUTS_p :: (coq_MOVS_p :: (coq_LODS_p :: (coq_STOS_p :: (coq_RET_p :: [])))))
  
  (** val prefix_grammar_rep_or_repn : grammar **)
  
  let prefix_grammar_rep_or_repn =
    map (Pair_t ((option_t X86_PARSER_ARG.Lock_or_Rep_t), (Pair_t
      ((option_t X86_PARSER_ARG.Segment_Register_t),
      (option_t X86_PARSER_ARG.Bool_t))))) prefix_t
      (option_perm3 X86_PARSER_ARG.Lock_or_Rep_t
        X86_PARSER_ARG.Segment_Register_t X86_PARSER_ARG.Bool_t rep_or_repn_p
        segment_override_p op_override_p) (fun p ->
      let (l, i) = Obj.magic p in
      let (s, op) = i in
      Obj.magic { lock_rep = l; seg_override = s; op_override =
        (opt2b op false); addr_override = false })
  
  (** val instr_grammars_rep_or_repn : grammar list **)
  
  let instr_grammars_rep_or_repn =
    coq_CMPS_p :: (coq_SCAS_p :: [])
  
  (** val prefix_grammar_lock_with_op_override : grammar **)
  
  let prefix_grammar_lock_with_op_override =
    map (Pair_t ((option_t X86_PARSER_ARG.Lock_or_Rep_t), (Pair_t
      ((option_t X86_PARSER_ARG.Segment_Register_t), (User_t
      X86_PARSER_ARG.Bool_t))))) prefix_t
      (option_perm3_variation X86_PARSER_ARG.Lock_or_Rep_t
        X86_PARSER_ARG.Segment_Register_t X86_PARSER_ARG.Bool_t lock_p
        segment_override_p op_override_p) (fun p ->
      let (l, i) = Obj.magic p in
      let (s, op) = i in
      Obj.magic { lock_rep = l; seg_override = s; op_override = op;
        addr_override = false })
  
  (** val instr_grammars_lock_with_op_override : grammar list **)
  
  let instr_grammars_lock_with_op_override =
    (coq_ADD_p true) :: ((coq_ADC_p true) :: ((coq_AND_p true) :: (coq_NEG_p :: (coq_NOT_p :: (
      (coq_OR_p true) :: ((coq_SBB_p true) :: ((coq_SUB_p true) :: ((coq_XOR_p
                                                                    true) :: (coq_XCHG_p :: [])))))))))
  
  (** val prefix_grammar_lock_no_op_override : grammar **)
  
  let prefix_grammar_lock_no_op_override =
    map (Pair_t ((option_t X86_PARSER_ARG.Lock_or_Rep_t),
      (option_t X86_PARSER_ARG.Segment_Register_t))) prefix_t
      (option_perm2 X86_PARSER_ARG.Lock_or_Rep_t
        X86_PARSER_ARG.Segment_Register_t lock_p segment_override_p)
      (fun p ->
      let (l, s) = Obj.magic p in
      Obj.magic { lock_rep = l; seg_override = s; op_override = false;
        addr_override = false })
  
  (** val instr_grammars_lock_no_op_override : grammar list **)
  
  let instr_grammars_lock_no_op_override =
    (coq_ADD_p false) :: ((coq_ADC_p false) :: ((coq_AND_p false) :: (coq_BTC_p :: (coq_BTR_p :: (coq_BTS_p :: (coq_CMPXCHG_p :: (coq_DEC_p :: (coq_INC_p :: (coq_NEG_p :: (coq_NOT_p :: (
      (coq_OR_p false) :: ((coq_SBB_p false) :: ((coq_SUB_p false) :: (
      (coq_XOR_p false) :: (coq_XADD_p :: (coq_XCHG_p :: []))))))))))))))))
  
  (** val prefix_grammar_seg_with_op_override : grammar **)
  
  let prefix_grammar_seg_with_op_override =
    map (Pair_t ((option_t X86_PARSER_ARG.Segment_Register_t), (User_t
      X86_PARSER_ARG.Bool_t))) prefix_t
      (option_perm2_variation X86_PARSER_ARG.Segment_Register_t
        X86_PARSER_ARG.Bool_t segment_override_p op_override_p) (fun p ->
      let (s, op) = Obj.magic p in
      Obj.magic { lock_rep = None; seg_override = s; op_override = op;
        addr_override = false })
  
  (** val instr_grammars_seg_with_op_override : grammar list **)
  
  let instr_grammars_seg_with_op_override =
    (coq_CMP_p true) :: ((coq_IMUL_p true) :: ((coq_MOV_p true) :: ((coq_TEST_p
                                                                    true) :: [])))
  
  (** val prefix_grammar_seg_op_override : grammar **)
  
  let prefix_grammar_seg_op_override =
    map (Pair_t ((option_t X86_PARSER_ARG.Segment_Register_t),
      (option_t X86_PARSER_ARG.Bool_t))) prefix_t
      (option_perm2 X86_PARSER_ARG.Segment_Register_t X86_PARSER_ARG.Bool_t
        segment_override_p op_override_p) (fun p ->
      let (s, op) = Obj.magic p in
      Obj.magic { lock_rep = None; seg_override = s; op_override =
        (opt2b op false); addr_override = false })
  
  (** val instr_grammars_seg_op_override : grammar list **)
  
  let instr_grammars_seg_op_override =
    coq_CDQ_p :: (coq_CMOVcc_p :: (coq_CWDE_p :: (coq_DIV_p :: (coq_IDIV_p :: (coq_MOVSX_p :: (coq_MOVZX_p :: (coq_MUL_p :: (coq_NOP_p :: (coq_ROL_p :: (coq_ROR_p :: (coq_SAR_p :: (coq_SHL_p :: (coq_SHLD_p :: (coq_SHR_p :: (coq_SHRD_p :: [])))))))))))))))
  
  (** val prefix_grammar_seg_override : grammar **)
  
  let prefix_grammar_seg_override =
    map (option_t X86_PARSER_ARG.Segment_Register_t) prefix_t
      (option_perm X86_PARSER_ARG.Segment_Register_t segment_override_p)
      (fun s ->
      Obj.magic { lock_rep = None; seg_override = (Obj.magic s);
        op_override = false; addr_override = false })
  
  (** val instr_grammars_seg_override : grammar list **)
  
  let instr_grammars_seg_override =
    coq_AAA_p :: (coq_AAD_p :: (coq_AAM_p :: (coq_AAS_p :: ((coq_CMP_p false) :: (coq_ARPL_p :: (coq_BOUND_p :: (coq_BSF_p :: (coq_BSR_p :: (coq_BSWAP_p :: (coq_BT_p :: (coq_CALL_p :: (coq_CLC_p :: (coq_CLD_p :: (coq_CLI_p :: (coq_CLTS_p :: (coq_CMC_p :: (coq_CPUID_p :: (coq_DAA_p :: (coq_DAS_p :: (coq_HLT_p :: (
      (coq_IMUL_p false) :: (coq_IN_p :: (coq_INTn_p :: (coq_INT_p :: (coq_INTO_p :: (coq_INVD_p :: (coq_INVLPG_p :: (coq_IRET_p :: (coq_Jcc_p :: (coq_JCXZ_p :: (coq_JMP_p :: (coq_LAHF_p :: (coq_LAR_p :: (coq_LDS_p :: (coq_LEA_p :: (coq_LEAVE_p :: (coq_LES_p :: (coq_LFS_p :: (coq_LGDT_p :: (coq_LGS_p :: (coq_LIDT_p :: (coq_LLDT_p :: (coq_LMSW_p :: (coq_LOOP_p :: (coq_LOOPZ_p :: (coq_LOOPNZ_p :: (coq_LSL_p :: (coq_LSS_p :: (coq_LTR_p :: (
      (coq_MOV_p false) :: (coq_MOVCR_p :: (coq_MOVDR_p :: (coq_MOVSR_p :: (coq_MOVBE_p :: (coq_OUT_p :: (coq_POP_p :: (coq_POPSR_p :: (coq_POPA_p :: (coq_POPF_p :: (coq_PUSH_p :: (coq_PUSHSR_p :: (coq_PUSHA_p :: (coq_PUSHF_p :: (coq_RCL_p :: (coq_RCR_p :: (coq_RDMSR_p :: (coq_RDPMC_p :: (coq_RDTSC_p :: (coq_RDTSCP_p :: (coq_RSM_p :: (coq_SAHF_p :: (coq_SETcc_p :: (coq_SGDT_p :: (coq_SIDT_p :: (coq_SLDT_p :: (coq_SMSW_p :: (coq_STC_p :: (coq_STD_p :: (coq_STI_p :: (coq_STR_p :: (
      (coq_TEST_p false) :: (coq_UD2_p :: (coq_VERR_p :: (coq_VERW_p :: (coq_WBINVD_p :: (coq_WRMSR_p :: (coq_XLAT_p :: (coq_F2XM1_p :: (coq_FABS_p :: (coq_FADD_p :: (coq_FADDP_p :: (coq_FBLD_p :: (coq_FBSTP_p :: (coq_FCHS_p :: (coq_FCMOVcc_p :: (coq_FCOM_p :: (coq_FCOMP_p :: (coq_FCOMPP_p :: (coq_FCOMIP_p :: (coq_FCOS_p :: (coq_FDECSTP_p :: (coq_FDIV_p :: (coq_FDIVP_p :: (coq_FDIVR_p :: (coq_FDIVRP_p :: (coq_FFREE_p :: (coq_FIADD_p :: (coq_FICOM_p :: (coq_FICOMP_p :: (coq_FIDIV_p :: (coq_FIDIVR_p :: (coq_FILD_p :: (coq_FIMUL_p :: (coq_FINCSTP_p :: (coq_FIST_p :: (coq_FISTP_p :: (coq_FISUB_p :: (coq_FISUBR_p :: (coq_FLD_p :: (coq_FLD1_p :: (coq_FLDCW_p :: (coq_FLDENV_p :: (coq_FLDL2E_p :: (coq_FLDL2T_p :: (coq_FLDLG2_p :: (coq_FLDLN2_p :: (coq_FLDPI_p :: (coq_FLDZ_p :: (coq_FMUL_p :: (coq_FMULP_p :: (coq_FNCLEX_p :: (coq_FNINIT_p :: (coq_FNOP_p :: (coq_FNSAVE_p :: (coq_FNSTCW_p :: (coq_FNSTSW_p :: (coq_FPATAN_p :: (coq_FPREM_p :: (coq_FPREM1_p :: (coq_FPTAN_p :: (coq_FRNDINT_p :: (coq_FRSTOR_p :: (coq_FSCALE_p :: (coq_FSIN_p :: (coq_FSINCOS_p :: (coq_FSQRT_p :: (coq_FST_p :: (coq_FSTENV_p :: (coq_FSTP_p :: (coq_FSUB_p :: (coq_FSUBP_p :: (coq_FSUBR_p :: (coq_FSUBRP_p :: (coq_FTST_p :: (coq_FUCOM_p :: (coq_FUCOMP_p :: (coq_FUCOMPP_p :: (coq_FUCOMI_p :: (coq_FUCOMIP_p :: (coq_FXAM_p :: (coq_FXCH_p :: (coq_FXTRACT_p :: (coq_FYL2X_p :: (coq_FYL2XP1_p :: (coq_FWAIT_p :: (coq_EMMS_p :: (coq_MOVD_p :: (coq_MOVQ_p :: (coq_PACKSSDW_p :: (coq_PACKSSWB_p :: (coq_PACKUSWB_p :: (coq_PADD_p :: (coq_PADDS_p :: (coq_PADDUS_p :: (coq_PAND_p :: (coq_PANDN_p :: (coq_PCMPEQ_p :: (coq_PCMPGT_p :: (coq_PMADDWD_p :: (coq_PMULHUW_p :: (coq_PMULHW_p :: (coq_PMULLW_p :: (coq_POR_p :: (coq_PSLL_p :: (coq_PSRA_p :: (coq_PSRL_p :: (coq_PSUB_p :: (coq_PSUBS_p :: (coq_PSUBUS_p :: (coq_PUNPCKH_p :: (coq_PUNPCKL_p :: (coq_PXOR_p :: (coq_ADDPS_p :: (coq_ADDSS_p :: (coq_ANDNPS_p :: (coq_ANDPS_p :: (coq_CMPPS_p :: (coq_CMPSS_p :: (coq_COMISS_p :: (coq_CVTPI2PS_p :: (coq_CVTPS2PI_p :: (coq_CVTSI2SS_p :: (coq_CVTSS2SI_p :: (coq_CVTTPS2PI_p :: (coq_CVTTSS2SI_p :: (coq_DIVPS_p :: (coq_DIVSS_p :: (coq_LDMXCSR_p :: (coq_MAXPS_p :: (coq_MAXSS_p :: (coq_MINPS_p :: (coq_MINSS_p :: (coq_MOVAPS_p :: (coq_MOVHLPS_p :: (coq_MOVLPS_p :: (coq_MOVMSKPS_p :: (coq_MOVSS_p :: (coq_MOVUPS_p :: (coq_MULPS_p :: (coq_MULSS_p :: (coq_ORPS_p :: (coq_RCPPS_p :: (coq_RCPSS_p :: (coq_RSQRTPS_p :: (coq_RSQRTSS_p :: (coq_SHUFPS_p :: (coq_SQRTPS_p :: (coq_SQRTSS_p :: (coq_STMXCSR_p :: (coq_SUBPS_p :: (coq_SUBSS_p :: (coq_UCOMISS_p :: (coq_UNPCKHPS_p :: (coq_UNPCKLPS_p :: (coq_XORPS_p :: (coq_PAVGB_p :: (coq_PEXTRW_p :: (coq_PINSRW_p :: (coq_PMAXSW_p :: (coq_PMAXUB_p :: (coq_PMINSW_p :: (coq_PMINUB_p :: (coq_PMOVMSKB_p :: (coq_PSADBW_p :: (coq_PSHUFW_p :: (coq_MASKMOVQ_p :: (coq_MOVNTPS_p :: (coq_MOVNTQ_p :: (coq_PREFETCHT0_p :: (coq_PREFETCHT1_p :: (coq_PREFETCHT2_p :: (coq_PREFETCHNTA_p :: (coq_SFENCE_p :: [])))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
  
  (** val instruction_grammar_list : grammar list **)
  
  let instruction_grammar_list =
    app
      (Coq__1.map (fun p -> seq prefix_t instruction_t prefix_grammar_rep p)
        instr_grammars_rep)
      (app
        (Coq__1.map (fun p ->
          seq prefix_t instruction_t prefix_grammar_rep_or_repn p)
          instr_grammars_rep_or_repn)
        (app
          (Coq__1.map (fun p ->
            seq prefix_t instruction_t prefix_grammar_lock_with_op_override p)
            instr_grammars_lock_with_op_override)
          (app
            (Coq__1.map (fun p ->
              seq prefix_t instruction_t prefix_grammar_lock_no_op_override p)
              instr_grammars_lock_no_op_override)
            (app
              (Coq__1.map (fun p ->
                seq prefix_t instruction_t
                  prefix_grammar_seg_with_op_override p)
                instr_grammars_seg_with_op_override)
              (app
                (Coq__1.map (fun p ->
                  seq prefix_t instruction_t prefix_grammar_seg_op_override p)
                  instr_grammars_seg_op_override)
                (Coq__1.map (fun p ->
                  seq prefix_t instruction_t prefix_grammar_seg_override p)
                  instr_grammars_seg_override))))))
  
  (** val instruction_grammar : grammar **)
  
  let instruction_grammar =
    alts (Pair_t (prefix_t, instruction_t)) instruction_grammar_list
  
  (** val opt_initial_decoder_state :
      Big.big_int -> instParserState option **)
  
  let opt_initial_decoder_state n =
    opt_initial_parser_state n instruction_grammar
  
  (** val parse_byte :
      instParserState -> int8 -> instParserState * (prefix * instr) list **)
  
  let parse_byte ps byte0 =
    Obj.magic
      (parse_token ps
        (Z.to_nat
          (Word.intval (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero))))))) byte0)))
 end

type 'm monad = { return : (__ -> __ -> 'm);
                  bind : (__ -> __ -> 'm -> (__ -> 'm) -> 'm) }

(** val return : 'a1 monad -> 'a2 -> 'a1 **)

let return monad0 x =
  let { return = return0; bind = bind0 } = monad0 in Obj.magic return0 __ x

(** val bind : 'a1 monad -> 'a1 -> ('a2 -> 'a1) -> 'a1 **)

let bind monad0 x x0 =
  let { return = return0; bind = bind0 } = monad0 in
  Obj.magic bind0 __ __ x x0

type r = unit

(** val r0 : r **)

let r0 = ()

(** val r1 : r **)

let r1 = ()

(** val rplus : r -> r -> r **)

(* let rplus = let rec loop x y = loop x y in loop *)

let coq_Rplus a b = failwith "Test Constant" 

(** val rmult : r -> r -> r **)

(* let rmult = let rec loop x y = loop x y in loop *)

let coq_Rmult a b = failwith "Test Constant"

(** val ropp : r -> r **)

(* let ropp = let rec loop x = loop x in loop *)

let coq_Ropp a = failwith "Test Constant"

(** val rinv : r -> r **)

(* let rinv = let rec loop x = loop x in loop *)

let coq_Rinv a = failwith "Test Constant"

(** val total_order_T : r -> r -> bool option **)

(* let total_order_T = let rec loop x y = loop x y in loop *)

let coq_Total_order_T a = failwith "Test Constant"

(** val zeven : Big.big_int -> bool **)

let zeven n =
  Big.z_case
    (fun _ ->
    true)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      false)
      (fun p0 ->
      true)
      (fun _ ->
      false)
      p)
    (fun p ->
    Big.positive_case
      (fun p0 ->
      false)
      (fun p0 ->
      true)
      (fun _ ->
      false)
      p)
    n

type radix =
  Big.big_int
  (* singleton inductive, whose constructor was Build_radix *)

(** val radix_val : radix -> Big.big_int **)

let radix_val r2 =
  r2

(** val cond_Zopp : bool -> Big.big_int -> Big.big_int **)

let cond_Zopp b m =
  if b then Z.opp m else m

(** val p2R : Big.big_int -> r **)

let rec p2R p =
  Big.positive_case
    (fun t0 ->
    Big.positive_case
      (fun p0 ->
      coq_Rplus r1 (coq_Rmult (coq_Rplus r1 r1) (p2R t0)))
      (fun p0 ->
      coq_Rplus r1 (coq_Rmult (coq_Rplus r1 r1) (p2R t0)))
      (fun _ ->
      coq_Rplus r1 (coq_Rplus r1 r1))
      t0)
    (fun t0 ->
    Big.positive_case
      (fun p0 ->
      coq_Rmult (coq_Rplus r1 r1) (p2R t0))
      (fun p0 ->
      coq_Rmult (coq_Rplus r1 r1) (p2R t0))
      (fun _ ->
      coq_Rplus r1 r1)
      t0)
    (fun _ ->
    r1)
    p

(** val z2R : Big.big_int -> r **)

let z2R n =
  Big.z_case
    (fun _ ->
    r0)
    (fun p ->
    p2R p)
    (fun p ->
    coq_Ropp (p2R p))
    n

(** val rcompare : r -> r -> comparison **)

let rcompare x y =
  match coq_Total_order_T x y with
  | Some s -> if s then Lt else Eq
  | None -> Gt

(** val bpow : radix -> Big.big_int -> r **)

let bpow r2 e =
  Big.z_case
    (fun _ ->
    r1)
    (fun p ->
    z2R (Z.pow_pos (radix_val r2) p))
    (fun p ->
    coq_Rinv (z2R (Z.pow_pos (radix_val r2) p)))
    e

type float = { fnum : Big.big_int; fexp : Big.big_int }

(** val fnum : radix -> float -> Big.big_int **)

let fnum _ x = x.fnum

(** val fexp : radix -> float -> Big.big_int **)

let fexp _ x = x.fexp

(** val f2R : radix -> float -> r **)

let f2R beta f =
  coq_Rmult (z2R f.fnum) (bpow beta f.fexp)

(** val fLT_exp :
    Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int **)

let fLT_exp emin prec e =
  Z.max (Z.sub e prec) emin

(** val digits2_Pnat : Big.big_int -> Big.big_int **)

let rec digits2_Pnat n =
  Big.positive_case
    (fun p -> Big.succ
    (digits2_Pnat p))
    (fun p -> Big.succ
    (digits2_Pnat p))
    (fun _ ->
    Big.zero)
    n

type location =
| Loc_Exact
| Loc_Inexact of comparison

(** val new_location_even :
    Big.big_int -> Big.big_int -> location -> location **)

let new_location_even nb_steps k l =
  if zeq_bool k Big.zero
  then (match l with
        | Loc_Exact -> l
        | Loc_Inexact c -> Loc_Inexact Lt)
  else Loc_Inexact
         (match Z.compare (Z.mul (Big.double Big.one) k) nb_steps with
          | Eq ->
            (match l with
             | Loc_Exact -> Eq
             | Loc_Inexact c -> Gt)
          | x -> x)

(** val new_location_odd :
    Big.big_int -> Big.big_int -> location -> location **)

let new_location_odd nb_steps k l =
  if zeq_bool k Big.zero
  then (match l with
        | Loc_Exact -> l
        | Loc_Inexact c -> Loc_Inexact Lt)
  else Loc_Inexact
         (match Z.compare (Z.add (Z.mul (Big.double Big.one) k) Big.one)
                  nb_steps with
          | Eq ->
            (match l with
             | Loc_Exact -> Lt
             | Loc_Inexact l0 -> l0)
          | x -> x)

(** val new_location : Big.big_int -> Big.big_int -> location -> location **)

let new_location nb_steps =
  if zeven nb_steps
  then new_location_even nb_steps
  else new_location_odd nb_steps

(** val cond_incr : bool -> Big.big_int -> Big.big_int **)

let cond_incr b m =
  if b then Z.add m Big.one else m

(** val round_sign_DN : bool -> location -> bool **)

let round_sign_DN s = function
| Loc_Exact -> false
| Loc_Inexact c -> s

(** val round_sign_UP : bool -> location -> bool **)

let round_sign_UP s = function
| Loc_Exact -> false
| Loc_Inexact c -> negb s

(** val round_N : bool -> location -> bool **)

let round_N p = function
| Loc_Exact -> false
| Loc_Inexact c ->
  (match c with
   | Eq -> p
   | Lt -> false
   | Gt -> true)

type full_float =
| F754_zero of bool
| F754_infinity of bool
| F754_nan
| F754_finite of bool * Big.big_int * Big.big_int

type binary_float =
| B754_zero of bool
| B754_infinity of bool
| B754_nan
| B754_finite of bool * Big.big_int * Big.big_int

(** val fF2B : Big.big_int -> Big.big_int -> full_float -> binary_float **)

let fF2B prec emax = function
| F754_zero s -> B754_zero s
| F754_infinity s -> B754_infinity s
| F754_nan -> B754_nan
| F754_finite (s, m, e) -> B754_finite (s, m, e)

(** val radix2 : radix **)

let radix2 =
  (Big.double Big.one)

(** val b2R : Big.big_int -> Big.big_int -> binary_float -> r **)

let b2R prec emax = function
| B754_finite (s, m, e) -> f2R radix2 { fnum = (cond_Zopp s m); fexp = e }
| _ -> r0

(** val bopp : Big.big_int -> Big.big_int -> binary_float -> binary_float **)

let bopp prec emax x = match x with
| B754_zero sx -> B754_zero (negb sx)
| B754_infinity sx -> B754_infinity (negb sx)
| B754_nan -> x
| B754_finite (sx, mx, ex) -> B754_finite ((negb sx), mx, ex)

type shr_record = { shr_m : Big.big_int; shr_r : bool; shr_s : bool }

(** val shr_m : shr_record -> Big.big_int **)

let shr_m x = x.shr_m

(** val shr_1 : shr_record -> shr_record **)

let shr_1 mrs =
  let { shr_m = m; shr_r = r2; shr_s = s } = mrs in
  let s0 = (||) r2 s in
  (Big.z_case
     (fun _ -> { shr_m = Big.zero; shr_r = false; shr_s =
     s0 })
     (fun p0 ->
     Big.positive_case
       (fun p -> { shr_m = p; shr_r = true; shr_s =
       s0 })
       (fun p -> { shr_m = p; shr_r = false; shr_s =
       s0 })
       (fun _ -> { shr_m = Big.zero; shr_r = true; shr_s =
       s0 })
       p0)
     (fun p0 ->
     Big.positive_case
       (fun p -> { shr_m = (Big.opp p); shr_r = true; shr_s =
       s0 })
       (fun p -> { shr_m = (Big.opp p); shr_r = false; shr_s =
       s0 })
       (fun _ -> { shr_m = Big.zero; shr_r = true; shr_s =
       s0 })
       p0)
     m)

(** val loc_of_shr_record : shr_record -> location **)

let loc_of_shr_record mrs =
  let { shr_m = shr_m0; shr_r = shr_r0; shr_s = shr_s0 } = mrs in
  if shr_r0
  then if shr_s0 then Loc_Inexact Gt else Loc_Inexact Eq
  else if shr_s0 then Loc_Inexact Lt else Loc_Exact

(** val shr_record_of_loc : Big.big_int -> location -> shr_record **)

let shr_record_of_loc m = function
| Loc_Exact -> { shr_m = m; shr_r = false; shr_s = false }
| Loc_Inexact c ->
  (match c with
   | Eq -> { shr_m = m; shr_r = true; shr_s = false }
   | Lt -> { shr_m = m; shr_r = false; shr_s = true }
   | Gt -> { shr_m = m; shr_r = true; shr_s = true })

(** val shr0 :
    shr_record -> Big.big_int -> Big.big_int -> shr_record * Big.big_int **)

let shr0 mrs e n =
  Big.z_case
    (fun _ -> (mrs,
    e))
    (fun p -> ((Coq_Pos.iter p shr_1 mrs),
    (Z.add e n)))
    (fun p -> (mrs,
    e))
    n

(** val zdigits2 : Big.big_int -> Big.big_int **)

let zdigits2 m =
  Big.z_case
    (fun _ ->
    m)
    (fun p ->
    Z.of_nat (Big.succ (digits2_Pnat p)))
    (fun p ->
    Z.of_nat (Big.succ (digits2_Pnat p)))
    m

(** val shr_fexp :
    Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int -> location ->
    shr_record * Big.big_int **)

let shr_fexp prec emax =
  let emin = Z.sub (Z.sub (Big.doubleplusone Big.one) emax) prec in
  let fexp0 = fLT_exp emin prec in
  (fun m e l ->
  shr0 (shr_record_of_loc m l) e (Z.sub (fexp0 (Z.add (zdigits2 m) e)) e))

type mode =
| Mode_NE
| Mode_ZR
| Mode_DN
| Mode_UP
| Mode_NA

(** val choice_mode :
    mode -> bool -> Big.big_int -> location -> Big.big_int **)

let choice_mode m sx mx lx =
  match m with
  | Mode_NE -> cond_incr (round_N (negb (zeven mx)) lx) mx
  | Mode_ZR -> mx
  | Mode_DN -> cond_incr (round_sign_DN sx lx) mx
  | Mode_UP -> cond_incr (round_sign_UP sx lx) mx
  | Mode_NA -> cond_incr (round_N true lx) mx

(** val overflow_to_inf : mode -> bool -> bool **)

let overflow_to_inf m s =
  match m with
  | Mode_ZR -> false
  | Mode_DN -> s
  | Mode_UP -> negb s
  | _ -> true

(** val binary_overflow :
    Big.big_int -> Big.big_int -> mode -> bool -> full_float **)

let binary_overflow prec emax m s =
  if overflow_to_inf m s
  then F754_infinity s
  else F754_finite (s,
         (Big.z_case
            (fun _ ->
            Big.one)
            (fun p ->
            p)
            (fun p ->
            Big.one)
            (Z.sub (Z.pow (Big.double Big.one) prec) Big.one)),
         (Z.sub emax prec))

(** val binary_round_aux :
    Big.big_int -> Big.big_int -> mode -> bool -> Big.big_int -> Big.big_int
    -> location -> full_float **)

let binary_round_aux prec emax mode0 sx mx ex lx =
  let (mrs', e') = shr_fexp prec emax mx ex lx in
  let (mrs'', e'') =
    shr_fexp prec emax
      (choice_mode mode0 sx mrs'.shr_m (loc_of_shr_record mrs')) e' Loc_Exact
  in
  (Big.z_case
     (fun _ -> F754_zero
     sx)
     (fun m ->
     if Z.leb e'' (Z.sub emax prec)
     then F754_finite (sx, m, e'')
     else binary_overflow prec emax mode0 sx)
     (fun p ->
     F754_nan)
     mrs''.shr_m)

(** val bmult :
    Big.big_int -> Big.big_int -> mode -> binary_float -> binary_float ->
    binary_float **)

let bmult prec emax m x y =
  match x with
  | B754_zero sx ->
    (match y with
     | B754_zero sy -> B754_zero (xorb sx sy)
     | B754_infinity b -> B754_nan
     | B754_nan -> y
     | B754_finite (sy, m0, e) -> B754_zero (xorb sx sy))
  | B754_infinity sx ->
    (match y with
     | B754_zero b -> B754_nan
     | B754_infinity sy -> B754_infinity (xorb sx sy)
     | B754_nan -> y
     | B754_finite (sy, m0, e) -> B754_infinity (xorb sx sy))
  | B754_nan -> x
  | B754_finite (sx, mx, ex) ->
    (match y with
     | B754_zero sy -> B754_zero (xorb sx sy)
     | B754_infinity sy -> B754_infinity (xorb sx sy)
     | B754_nan -> y
     | B754_finite (sy, my, ey) ->
       fF2B prec emax
         (binary_round_aux prec emax m (xorb sx sy) (Coq_Pos.mul mx my)
           (Z.add ex ey) Loc_Exact))

(** val shl_align :
    Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int * Big.big_int **)

let shl_align mx ex ex' =
  Big.z_case
    (fun _ -> (mx,
    ex))
    (fun p -> (mx,
    ex))
    (fun d -> ((shift_pos d mx),
    ex'))
    (Z.sub ex' ex)

(** val shl_align_fexp :
    Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int ->
    Big.big_int * Big.big_int **)

let shl_align_fexp prec emax =
  let emin = Z.sub (Z.sub (Big.doubleplusone Big.one) emax) prec in
  let fexp0 = fLT_exp emin prec in
  (fun mx ex ->
  shl_align mx ex (fexp0 (Z.add (Z.of_nat (Big.succ (digits2_Pnat mx))) ex)))

(** val binary_round :
    Big.big_int -> Big.big_int -> mode -> bool -> Big.big_int -> Big.big_int
    -> full_float **)

let binary_round prec emax m sx mx ex =
  let (mz, ez) = shl_align_fexp prec emax mx ex in
  binary_round_aux prec emax m sx mz ez Loc_Exact

(** val binary_normalize :
    Big.big_int -> Big.big_int -> mode -> Big.big_int -> Big.big_int -> bool
    -> binary_float **)

let binary_normalize prec emax mode0 m e szero =
  Big.z_case
    (fun _ -> B754_zero
    szero)
    (fun m0 ->
    fF2B prec emax (binary_round prec emax mode0 false m0 e))
    (fun m0 ->
    fF2B prec emax (binary_round prec emax mode0 true m0 e))
    m

(** val bplus :
    Big.big_int -> Big.big_int -> mode -> binary_float -> binary_float ->
    binary_float **)

let bplus prec emax m x y =
  match x with
  | B754_zero sx ->
    (match y with
     | B754_zero sy ->
       if eqb sx sy
       then x
       else (match m with
             | Mode_DN -> B754_zero true
             | _ -> B754_zero false)
     | _ -> y)
  | B754_infinity sx ->
    (match y with
     | B754_infinity sy -> if eqb sx sy then x else B754_nan
     | B754_nan -> y
     | _ -> x)
  | B754_nan -> x
  | B754_finite (sx, mx, ex) ->
    (match y with
     | B754_zero b -> x
     | B754_finite (sy, my, ey) ->
       let ez = Z.min ex ey in
       binary_normalize prec emax m
         (Z.add (cond_Zopp sx (fst (shl_align mx ex ez)))
           (cond_Zopp sy (fst (shl_align my ey ez)))) ez
         (match m with
          | Mode_DN -> true
          | _ -> false)
     | _ -> y)

(** val bminus :
    Big.big_int -> Big.big_int -> mode -> binary_float -> binary_float ->
    binary_float **)

let bminus prec emax m x y =
  bplus prec emax m x (bopp prec emax y)

(** val fdiv_core_binary :
    Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int
    -> (Big.big_int * Big.big_int) * location **)

let fdiv_core_binary prec m1 e1 m2 e2 =
  let d1 = zdigits2 m1 in
  let d2 = zdigits2 m2 in
  let e = Z.sub e1 e2 in
  (Big.z_case
     (fun _ ->
     let (q, r2) = Z.div_eucl m1 m2 in
     ((q, e), (new_location m2 r2 Loc_Exact)))
     (fun p ->
     let m = Z.mul m1 (Z.pow_pos (Big.double Big.one) p) in
     let e' = Z.add e (Big.opp p) in
     let (q, r2) = Z.div_eucl m m2 in
     ((q, e'), (new_location m2 r2 Loc_Exact)))
     (fun p ->
     let (q, r2) = Z.div_eucl m1 m2 in
     ((q, e), (new_location m2 r2 Loc_Exact)))
     (Z.sub (Z.add d2 prec) d1))

(** val bdiv :
    Big.big_int -> Big.big_int -> mode -> binary_float -> binary_float ->
    binary_float **)

let bdiv prec emax m x y =
  match x with
  | B754_zero sx ->
    (match y with
     | B754_zero sy -> B754_nan
     | B754_infinity sy -> B754_zero (xorb sx sy)
     | B754_nan -> y
     | B754_finite (sy, m0, e) -> B754_zero (xorb sx sy))
  | B754_infinity sx ->
    (match y with
     | B754_zero sy -> B754_infinity (xorb sx sy)
     | B754_infinity sy -> B754_nan
     | B754_nan -> y
     | B754_finite (sy, m0, e) -> B754_infinity (xorb sx sy))
  | B754_nan -> x
  | B754_finite (sx, mx, ex) ->
    (match y with
     | B754_zero sy -> B754_infinity (xorb sx sy)
     | B754_infinity sy -> B754_infinity (xorb sx sy)
     | B754_nan -> y
     | B754_finite (sy, my, ey) ->
       fF2B prec emax
         (let (p, lz) = fdiv_core_binary prec mx ex my ey in
          let (mz, ez) = p in
          (Big.z_case
             (fun _ ->
             F754_nan)
             (fun mz0 ->
             binary_round_aux prec emax m (xorb sx sy) mz0 ez lz)
             (fun p0 ->
             F754_nan)
             mz)))

(** val join_bits :
    Big.big_int -> Big.big_int -> bool -> Big.big_int -> Big.big_int ->
    Big.big_int **)

let join_bits mw ew s m e =
  Z.add
    (Z.mul (Z.add (if s then Z.pow (Big.double Big.one) ew else Big.zero) e)
      (Z.pow (Big.double Big.one) mw)) m

(** val split_bits :
    Big.big_int -> Big.big_int -> Big.big_int ->
    (bool * Big.big_int) * Big.big_int **)

let split_bits mw ew x =
  let mm = Z.pow (Big.double Big.one) mw in
  let em = Z.pow (Big.double Big.one) ew in
  (((Z.leb (Z.mul mm em) x), (Z.modulo x mm)), (Z.modulo (Z.div x mm) em))

(** val bits_of_binary_float :
    Big.big_int -> Big.big_int -> binary_float -> Big.big_int **)

let bits_of_binary_float mw ew =
  let emax = Z.pow (Big.double Big.one) (Z.sub ew Big.one) in
  let prec = Z.add mw Big.one in
  let emin = Z.sub (Z.sub (Big.doubleplusone Big.one) emax) prec in
  (fun x ->
  match x with
  | B754_zero sx -> join_bits mw ew sx Big.zero Big.zero
  | B754_infinity sx ->
    join_bits mw ew sx Big.zero
      (Z.sub (Z.pow (Big.double Big.one) ew) Big.one)
  | B754_nan ->
    join_bits mw ew false (Z.sub (Z.pow (Big.double Big.one) mw) Big.one)
      (Z.sub (Z.pow (Big.double Big.one) ew) Big.one)
  | B754_finite (sx, mx, ex) ->
    if Z.leb (Z.pow (Big.double Big.one) mw) mx
    then join_bits mw ew sx (Z.sub mx (Z.pow (Big.double Big.one) mw))
           (Z.add (Z.sub ex emin) Big.one)
    else join_bits mw ew sx mx Big.zero)

(** val binary_float_of_bits_aux :
    Big.big_int -> Big.big_int -> Big.big_int -> full_float **)

let binary_float_of_bits_aux mw ew =
  let emax = Z.pow (Big.double Big.one) (Z.sub ew Big.one) in
  let prec = Z.add mw Big.one in
  let emin = Z.sub (Z.sub (Big.doubleplusone Big.one) emax) prec in
  (fun x ->
  let (p, ex) = split_bits mw ew x in
  let (sx, mx) = p in
  if zeq_bool ex Big.zero
  then (Big.z_case
          (fun _ -> F754_zero
          sx)
          (fun px -> F754_finite (sx, px,
          emin))
          (fun p0 ->
          F754_nan)
          mx)
  else if zeq_bool ex (Z.sub (Z.pow (Big.double Big.one) ew) Big.one)
       then if zeq_bool mx Big.zero then F754_infinity sx else F754_nan
       else (Big.z_case
               (fun _ ->
               F754_nan)
               (fun px -> F754_finite (sx, px,
               (Z.sub (Z.add ex emin) Big.one)))
               (fun p0 ->
               F754_nan)
               (Z.add mx (Z.pow (Big.double Big.one) mw))))

(** val binary_float_of_bits :
    Big.big_int -> Big.big_int -> Big.big_int -> binary_float **)

let binary_float_of_bits mw ew x =
  let emax = Z.pow (Big.double Big.one) (Z.sub ew Big.one) in
  let prec = Z.add mw Big.one in
  fF2B prec emax (binary_float_of_bits_aux mw ew x)

type binary32 = binary_float

(** val b32_of_bits : Big.big_int -> binary32 **)

let b32_of_bits =
  binary_float_of_bits (Big.doubleplusone (Big.doubleplusone
    (Big.doubleplusone (Big.double Big.one)))) (Big.double (Big.double
    (Big.double Big.one)))

(** val bits_of_b32 : binary32 -> Big.big_int **)

let bits_of_b32 =
  bits_of_binary_float (Big.doubleplusone (Big.doubleplusone
    (Big.doubleplusone (Big.double Big.one)))) (Big.double (Big.double
    (Big.double Big.one)))

type binary64 = binary_float

(** val b64_of_bits : Big.big_int -> binary64 **)

let b64_of_bits =
  binary_float_of_bits (Big.double (Big.double (Big.doubleplusone (Big.double
    (Big.doubleplusone Big.one))))) (Big.doubleplusone (Big.doubleplusone
    (Big.double Big.one)))

(** val bits_of_b64 : binary64 -> Big.big_int **)

let bits_of_b64 =
  bits_of_binary_float (Big.double (Big.double (Big.doubleplusone (Big.double
    (Big.doubleplusone Big.one))))) (Big.doubleplusone (Big.doubleplusone
    (Big.double Big.one)))

(** val size1 : Big.big_int **)

let size1 =
  Big.zero

(** val size2 : Big.big_int **)

let size2 =
  Big.succ Big.zero

(** val size3 : Big.big_int **)

let size3 =
  Big.succ (Big.succ Big.zero)

(** val size4 : Big.big_int **)

let size4 =
  Big.succ (Big.succ (Big.succ Big.zero))

(** val size8 : Big.big_int **)

let size8 =
  Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    Big.zero))))))

(** val size16 : Big.big_int **)

let size16 =
  Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ Big.zero))))))))))))))

(** val size32 : Big.big_int **)

let size32 =
  Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))

(** val size64 : Big.big_int **)

let size64 =
  Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    Big.zero))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val size79 : Big.big_int **)

let size79 =
  Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ
    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val size80 : Big.big_int **)

let size80 =
  Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ
    Big.zero))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

type int0 = Word.int

module type MACHINE_SIG = 
 sig 
  type location 
  
  type array 
  
  val size_addr : Big.big_int
  
  type mach_state 
  
  val get_location : Big.big_int -> location -> mach_state -> Word.int
  
  val set_location :
    Big.big_int -> location -> Word.int -> mach_state -> mach_state
  
  val array_sub :
    Big.big_int -> Big.big_int -> array -> Word.int -> mach_state -> Word.int
  
  val array_upd :
    Big.big_int -> Big.big_int -> array -> Word.int -> Word.int -> mach_state
    -> mach_state
 end

module RTL = 
 functor (M:MACHINE_SIG) ->
 struct 
  module AddrIndexed = 
   struct 
    type t = int0
    
    (** val index : int0 -> Big.big_int **)
    
    let index i =
      ZIndexed.index (Word.unsigned M.size_addr i)
    
    (** val eq : Word.int -> Word.int -> bool **)
    
    let eq =
      Word.eq_dec M.size_addr
   end
  
  module AddrMap = IMap(AddrIndexed)
  
  type bit_vector_op =
  | Coq_add_op
  | Coq_sub_op
  | Coq_mul_op
  | Coq_divs_op
  | Coq_divu_op
  | Coq_modu_op
  | Coq_mods_op
  | Coq_and_op
  | Coq_or_op
  | Coq_xor_op
  | Coq_shl_op
  | Coq_shr_op
  | Coq_shru_op
  | Coq_ror_op
  | Coq_rol_op
  
  (** val bit_vector_op_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> bit_vector_op -> 'a1 **)
  
  let bit_vector_op_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 = function
  | Coq_add_op -> f
  | Coq_sub_op -> f0
  | Coq_mul_op -> f1
  | Coq_divs_op -> f2
  | Coq_divu_op -> f3
  | Coq_modu_op -> f4
  | Coq_mods_op -> f5
  | Coq_and_op -> f6
  | Coq_or_op -> f7
  | Coq_xor_op -> f8
  | Coq_shl_op -> f9
  | Coq_shr_op -> f10
  | Coq_shru_op -> f11
  | Coq_ror_op -> f12
  | Coq_rol_op -> f13
  
  (** val bit_vector_op_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> bit_vector_op -> 'a1 **)
  
  let bit_vector_op_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 = function
  | Coq_add_op -> f
  | Coq_sub_op -> f0
  | Coq_mul_op -> f1
  | Coq_divs_op -> f2
  | Coq_divu_op -> f3
  | Coq_modu_op -> f4
  | Coq_mods_op -> f5
  | Coq_and_op -> f6
  | Coq_or_op -> f7
  | Coq_xor_op -> f8
  | Coq_shl_op -> f9
  | Coq_shr_op -> f10
  | Coq_shru_op -> f11
  | Coq_ror_op -> f12
  | Coq_rol_op -> f13
  
  type float_arith_op =
  | Coq_fadd_op
  | Coq_fsub_op
  | Coq_fmul_op
  | Coq_fdiv_op
  
  (** val float_arith_op_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> float_arith_op -> 'a1 **)
  
  let float_arith_op_rect f f0 f1 f2 = function
  | Coq_fadd_op -> f
  | Coq_fsub_op -> f0
  | Coq_fmul_op -> f1
  | Coq_fdiv_op -> f2
  
  (** val float_arith_op_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> float_arith_op -> 'a1 **)
  
  let float_arith_op_rec f f0 f1 f2 = function
  | Coq_fadd_op -> f
  | Coq_fsub_op -> f0
  | Coq_fmul_op -> f1
  | Coq_fdiv_op -> f2
  
  type test_op =
  | Coq_eq_op
  | Coq_lt_op
  | Coq_ltu_op
  
  (** val test_op_rect : 'a1 -> 'a1 -> 'a1 -> test_op -> 'a1 **)
  
  let test_op_rect f f0 f1 = function
  | Coq_eq_op -> f
  | Coq_lt_op -> f0
  | Coq_ltu_op -> f1
  
  (** val test_op_rec : 'a1 -> 'a1 -> 'a1 -> test_op -> 'a1 **)
  
  let test_op_rec f f0 f1 = function
  | Coq_eq_op -> f
  | Coq_lt_op -> f0
  | Coq_ltu_op -> f1
  
  type rounding_mode = mode
  
  type rtl_exp =
  | Coq_arith_rtl_exp of Big.big_int * bit_vector_op * rtl_exp * rtl_exp
  | Coq_test_rtl_exp of Big.big_int * test_op * rtl_exp * rtl_exp
  | Coq_if_rtl_exp of Big.big_int * rtl_exp * rtl_exp * rtl_exp
  | Coq_cast_s_rtl_exp of Big.big_int * Big.big_int * rtl_exp
  | Coq_cast_u_rtl_exp of Big.big_int * Big.big_int * rtl_exp
  | Coq_imm_rtl_exp of Big.big_int * int0
  | Coq_get_loc_rtl_exp of Big.big_int * M.location
  | Coq_get_array_rtl_exp of Big.big_int * Big.big_int * M.array * rtl_exp
  | Coq_get_byte_rtl_exp of rtl_exp
  | Coq_choose_rtl_exp of Big.big_int
  | Coq_farith_rtl_exp of Big.big_int * Big.big_int * float_arith_op
     * rtl_exp * rtl_exp * rtl_exp
  | Coq_fcast_rtl_exp of Big.big_int * Big.big_int * Big.big_int
     * Big.big_int * rtl_exp * rtl_exp
  
  (** val rtl_exp_rect :
      (Big.big_int -> bit_vector_op -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 ->
      'a1) -> (Big.big_int -> test_op -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 ->
      'a1) -> (Big.big_int -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 -> rtl_exp ->
      'a1 -> 'a1) -> (Big.big_int -> Big.big_int -> rtl_exp -> 'a1 -> 'a1) ->
      (Big.big_int -> Big.big_int -> rtl_exp -> 'a1 -> 'a1) -> (Big.big_int
      -> int0 -> 'a1) -> (Big.big_int -> M.location -> 'a1) -> (Big.big_int
      -> Big.big_int -> M.array -> rtl_exp -> 'a1 -> 'a1) -> (rtl_exp -> 'a1
      -> 'a1) -> (Big.big_int -> 'a1) -> (Big.big_int -> Big.big_int -> __ ->
      float_arith_op -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 ->
      'a1) -> (Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int -> __
      -> __ -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 -> 'a1) -> Big.big_int ->
      rtl_exp -> 'a1 **)
  
  let rec rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 n = function
  | Coq_arith_rtl_exp (s, b, e1, e2) ->
    f s b e1 (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e1) e2
      (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e2)
  | Coq_test_rtl_exp (s, top, e1, e2) ->
    f0 s top e1 (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e1) e2
      (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e2)
  | Coq_if_rtl_exp (s, cond, e1, e2) ->
    f1 s cond (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 size1 cond)
      e1 (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e1) e2
      (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e2)
  | Coq_cast_s_rtl_exp (s1, s2, e) ->
    f2 s1 s2 e (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s1 e)
  | Coq_cast_u_rtl_exp (s1, s2, e) ->
    f3 s1 s2 e (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s1 e)
  | Coq_imm_rtl_exp (s, i) -> f4 s i
  | Coq_get_loc_rtl_exp (s, l) -> f5 s l
  | Coq_get_array_rtl_exp (l, s, a, r3) ->
    f6 l s a r3 (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 l r3)
  | Coq_get_byte_rtl_exp addr ->
    f7 addr
      (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 M.size_addr addr)
  | Coq_choose_rtl_exp s -> f8 s
  | Coq_farith_rtl_exp (ew, mw, x, x0, x1, x2) ->
    let len = plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw) in
    f9 ew mw __ x x0
      (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 size2 x0) x1
      (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 len x1) x2
      (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 len x2)
  | Coq_fcast_rtl_exp (ew1, mw1, ew2, mw2, r3, r4) ->
    f10 ew1 mw1 ew2 mw2 __ __ r3
      (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 size2 r3) r4
      (rtl_exp_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10
        (plus (Coq_Pos.to_nat ew1) (Coq_Pos.to_nat mw1)) r4)
  
  (** val rtl_exp_rec :
      (Big.big_int -> bit_vector_op -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 ->
      'a1) -> (Big.big_int -> test_op -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 ->
      'a1) -> (Big.big_int -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 -> rtl_exp ->
      'a1 -> 'a1) -> (Big.big_int -> Big.big_int -> rtl_exp -> 'a1 -> 'a1) ->
      (Big.big_int -> Big.big_int -> rtl_exp -> 'a1 -> 'a1) -> (Big.big_int
      -> int0 -> 'a1) -> (Big.big_int -> M.location -> 'a1) -> (Big.big_int
      -> Big.big_int -> M.array -> rtl_exp -> 'a1 -> 'a1) -> (rtl_exp -> 'a1
      -> 'a1) -> (Big.big_int -> 'a1) -> (Big.big_int -> Big.big_int -> __ ->
      float_arith_op -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 ->
      'a1) -> (Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int -> __
      -> __ -> rtl_exp -> 'a1 -> rtl_exp -> 'a1 -> 'a1) -> Big.big_int ->
      rtl_exp -> 'a1 **)
  
  let rec rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 n = function
  | Coq_arith_rtl_exp (s, b, e1, e2) ->
    f s b e1 (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e1) e2
      (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e2)
  | Coq_test_rtl_exp (s, top, e1, e2) ->
    f0 s top e1 (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e1) e2
      (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e2)
  | Coq_if_rtl_exp (s, cond, e1, e2) ->
    f1 s cond (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 size1 cond) e1
      (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e1) e2
      (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s e2)
  | Coq_cast_s_rtl_exp (s1, s2, e) ->
    f2 s1 s2 e (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s1 e)
  | Coq_cast_u_rtl_exp (s1, s2, e) ->
    f3 s1 s2 e (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 s1 e)
  | Coq_imm_rtl_exp (s, i) -> f4 s i
  | Coq_get_loc_rtl_exp (s, l) -> f5 s l
  | Coq_get_array_rtl_exp (l, s, a, r3) ->
    f6 l s a r3 (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 l r3)
  | Coq_get_byte_rtl_exp addr ->
    f7 addr
      (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 M.size_addr addr)
  | Coq_choose_rtl_exp s -> f8 s
  | Coq_farith_rtl_exp (ew, mw, x, x0, x1, x2) ->
    let len = plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw) in
    f9 ew mw __ x x0
      (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 size2 x0) x1
      (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 len x1) x2
      (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 len x2)
  | Coq_fcast_rtl_exp (ew1, mw1, ew2, mw2, r3, r4) ->
    f10 ew1 mw1 ew2 mw2 __ __ r3
      (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 size2 r3) r4
      (rtl_exp_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10
        (plus (Coq_Pos.to_nat ew1) (Coq_Pos.to_nat mw1)) r4)
  
  type rtl_instr =
  | Coq_set_loc_rtl of Big.big_int * rtl_exp * M.location
  | Coq_set_array_rtl of Big.big_int * Big.big_int * M.array * rtl_exp
     * rtl_exp
  | Coq_set_byte_rtl of rtl_exp * rtl_exp
  | Coq_if_rtl of rtl_exp * rtl_instr
  | Coq_error_rtl
  | Coq_trap_rtl
  
  (** val rtl_instr_rect :
      (Big.big_int -> rtl_exp -> M.location -> 'a1) -> (Big.big_int ->
      Big.big_int -> M.array -> rtl_exp -> rtl_exp -> 'a1) -> (rtl_exp ->
      rtl_exp -> 'a1) -> (rtl_exp -> rtl_instr -> 'a1 -> 'a1) -> 'a1 -> 'a1
      -> rtl_instr -> 'a1 **)
  
  let rec rtl_instr_rect f f0 f1 f2 f3 f4 = function
  | Coq_set_loc_rtl (s, e, l) -> f s e l
  | Coq_set_array_rtl (l, s, a, r3, r4) -> f0 l s a r3 r4
  | Coq_set_byte_rtl (e, addr) -> f1 e addr
  | Coq_if_rtl (r3, r4) -> f2 r3 r4 (rtl_instr_rect f f0 f1 f2 f3 f4 r4)
  | Coq_error_rtl -> f3
  | Coq_trap_rtl -> f4
  
  (** val rtl_instr_rec :
      (Big.big_int -> rtl_exp -> M.location -> 'a1) -> (Big.big_int ->
      Big.big_int -> M.array -> rtl_exp -> rtl_exp -> 'a1) -> (rtl_exp ->
      rtl_exp -> 'a1) -> (rtl_exp -> rtl_instr -> 'a1 -> 'a1) -> 'a1 -> 'a1
      -> rtl_instr -> 'a1 **)
  
  let rec rtl_instr_rec f f0 f1 f2 f3 f4 = function
  | Coq_set_loc_rtl (s, e, l) -> f s e l
  | Coq_set_array_rtl (l, s, a, r3, r4) -> f0 l s a r3 r4
  | Coq_set_byte_rtl (e, addr) -> f1 e addr
  | Coq_if_rtl (r3, r4) -> f2 r3 r4 (rtl_instr_rec f f0 f1 f2 f3 f4 r4)
  | Coq_error_rtl -> f3
  | Coq_trap_rtl -> f4
  
  type oracle = { oracle_bits : (Big.big_int -> Big.big_int -> int0);
                  oracle_offset : Big.big_int }
  
  (** val oracle_rect :
      ((Big.big_int -> Big.big_int -> int0) -> Big.big_int -> 'a1) -> oracle
      -> 'a1 **)
  
  let oracle_rect f o =
    let { oracle_bits = x; oracle_offset = x0 } = o in f x x0
  
  (** val oracle_rec :
      ((Big.big_int -> Big.big_int -> int0) -> Big.big_int -> 'a1) -> oracle
      -> 'a1 **)
  
  let oracle_rec f o =
    let { oracle_bits = x; oracle_offset = x0 } = o in f x x0
  
  (** val oracle_bits : oracle -> Big.big_int -> Big.big_int -> int0 **)
  
  let oracle_bits o =
    o.oracle_bits
  
  (** val oracle_offset : oracle -> Big.big_int **)
  
  let oracle_offset o =
    o.oracle_offset
  
  type rtl_state = { rtl_oracle : oracle; rtl_mach_state : M.mach_state;
                     rtl_memory : int8 AddrMap.t }
  
  (** val rtl_state_rect :
      (oracle -> M.mach_state -> int8 AddrMap.t -> 'a1) -> rtl_state -> 'a1 **)
  
  let rtl_state_rect f r2 =
    let { rtl_oracle = x; rtl_mach_state = x0; rtl_memory = x1 } = r2 in
    f x x0 x1
  
  (** val rtl_state_rec :
      (oracle -> M.mach_state -> int8 AddrMap.t -> 'a1) -> rtl_state -> 'a1 **)
  
  let rtl_state_rec f r2 =
    let { rtl_oracle = x; rtl_mach_state = x0; rtl_memory = x1 } = r2 in
    f x x0 x1
  
  (** val rtl_oracle : rtl_state -> oracle **)
  
  let rtl_oracle r2 =
    r2.rtl_oracle
  
  (** val rtl_mach_state : rtl_state -> M.mach_state **)
  
  let rtl_mach_state r2 =
    r2.rtl_mach_state
  
  (** val rtl_memory : rtl_state -> int8 AddrMap.t **)
  
  let rtl_memory r2 =
    r2.rtl_memory
  
  type 'a coq_RTL_ans =
  | Fail_ans
  | Trap_ans
  | Okay_ans of 'a
  
  (** val coq_RTL_ans_rect :
      'a2 -> 'a2 -> ('a1 -> 'a2) -> 'a1 coq_RTL_ans -> 'a2 **)
  
  let coq_RTL_ans_rect f f0 f1 = function
  | Fail_ans -> f
  | Trap_ans -> f0
  | Okay_ans x -> f1 x
  
  (** val coq_RTL_ans_rec :
      'a2 -> 'a2 -> ('a1 -> 'a2) -> 'a1 coq_RTL_ans -> 'a2 **)
  
  let coq_RTL_ans_rec f f0 f1 = function
  | Fail_ans -> f
  | Trap_ans -> f0
  | Okay_ans x -> f1 x
  
  type 't coq_RTL = rtl_state -> 't coq_RTL_ans * rtl_state
  
  (** val coq_RTL_monad : __ coq_RTL monad **)
  
  let coq_RTL_monad =
    { return = (fun _ x rs -> ((Okay_ans x), rs)); bind = (fun _ _ c f rs ->
      let (safeFail_ans, rs') = c rs in
      (match safeFail_ans with
       | Okay_ans v -> f v rs'
       | x -> (x, rs'))) }
  
  (** val coq_Fail : 'a1 coq_RTL **)
  
  let coq_Fail rs =
    (Fail_ans, rs)
  
  (** val coq_Trap : 'a1 coq_RTL **)
  
  let coq_Trap rs =
    (Trap_ans, rs)
  
  (** val set_loc : Big.big_int -> M.location -> int0 -> unit coq_RTL **)
  
  let set_loc s l v rs =
    ((Okay_ans ()), { rtl_oracle = (rtl_oracle rs); rtl_mach_state =
      (M.set_location s l v (rtl_mach_state rs)); rtl_memory =
      (rtl_memory rs) })
  
  (** val set_array :
      Big.big_int -> Big.big_int -> M.array -> int0 -> int0 -> unit coq_RTL **)
  
  let set_array l s a i v rs =
    ((Okay_ans ()), { rtl_oracle = (rtl_oracle rs); rtl_mach_state =
      (M.array_upd l s a i v (rtl_mach_state rs)); rtl_memory =
      (rtl_memory rs) })
  
  (** val set_byte : int0 -> int0 -> unit coq_RTL **)
  
  let set_byte addr v rs =
    ((Okay_ans ()), { rtl_oracle = (rtl_oracle rs); rtl_mach_state =
      (rtl_mach_state rs); rtl_memory =
      (AddrMap.set addr v (rtl_memory rs)) })
  
  (** val get_loc : Big.big_int -> M.location -> int0 coq_RTL **)
  
  let get_loc s l rs =
    ((Okay_ans (M.get_location s l (rtl_mach_state rs))), rs)
  
  (** val get_array :
      Big.big_int -> Big.big_int -> M.array -> int0 -> int0 coq_RTL **)
  
  let get_array l s a i rs =
    ((Okay_ans (M.array_sub l s a i (rtl_mach_state rs))), rs)
  
  (** val get_byte : int0 -> int0 coq_RTL **)
  
  let get_byte addr rs =
    ((Okay_ans (AddrMap.get addr (rtl_memory rs))), rs)
  
  (** val choose_bits : Big.big_int -> int0 coq_RTL **)
  
  let choose_bits s rs =
    let o = rtl_oracle rs in
    let o' = { oracle_bits = (oracle_bits o); oracle_offset =
      (Z.add (oracle_offset o) Big.one) }
    in
    ((Okay_ans (oracle_bits o s (oracle_offset o))), { rtl_oracle = o';
    rtl_mach_state = (rtl_mach_state rs); rtl_memory = (rtl_memory rs) })
  
  (** val interp_arith :
      Big.big_int -> bit_vector_op -> int0 -> int0 -> int0 **)
  
  let interp_arith s b v1 v2 =
    match b with
    | Coq_add_op -> Word.add s v1 v2
    | Coq_sub_op -> Word.sub s v1 v2
    | Coq_mul_op -> Word.mul s v1 v2
    | Coq_divs_op -> Word.divs s v1 v2
    | Coq_divu_op -> Word.divu s v1 v2
    | Coq_modu_op -> Word.modu s v1 v2
    | Coq_mods_op -> Word.mods s v1 v2
    | Coq_and_op -> Word.coq_and s v1 v2
    | Coq_or_op -> Word.coq_or s v1 v2
    | Coq_xor_op -> Word.xor s v1 v2
    | Coq_shl_op -> Word.shl s v1 v2
    | Coq_shr_op -> Word.shr s v1 v2
    | Coq_shru_op -> Word.shru s v1 v2
    | Coq_ror_op -> Word.ror s v1 v2
    | Coq_rol_op -> Word.rol s v1 v2
  
  (** val interp_test : Big.big_int -> test_op -> int0 -> int0 -> int0 **)
  
  let interp_test s t0 v1 v2 =
    if match t0 with
       | Coq_eq_op -> Word.eq s v1 v2
       | Coq_lt_op -> Word.lt s v1 v2
       | Coq_ltu_op -> Word.ltu s v1 v2
    then Word.one size1
    else Word.zero size1
  
  (** val dec_rounding_mode : int0 -> rounding_mode **)
  
  let dec_rounding_mode rm =
    if Word.eq size2 rm (Word.repr size2 Big.zero)
    then Mode_NE
    else if Word.eq size2 rm (Word.repr size2 Big.one)
         then Mode_DN
         else if Word.eq size2 rm (Word.repr size2 (Big.double Big.one))
              then Mode_UP
              else Mode_ZR
  
  (** val interp_farith :
      Big.big_int -> Big.big_int -> float_arith_op -> int0 -> int0 -> int0 ->
      int0 **)
  
  let interp_farith ew mw fop rm v1 v2 =
    let prec = Z.add mw Big.one in
    let emax = Z.pow (Big.double Big.one) (Z.sub ew Big.one) in
    let bf_of_bits = binary_float_of_bits mw ew in
    let bf1 =
      bf_of_bits
        (Word.unsigned (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw)) v1)
    in
    let bf2 =
      bf_of_bits
        (Word.unsigned (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw)) v2)
    in
    let md = dec_rounding_mode rm in
    let res =
      match fop with
      | Coq_fadd_op -> bplus prec emax md bf1 bf2
      | Coq_fsub_op -> bminus prec emax md bf1 bf2
      | Coq_fmul_op -> bmult prec emax md bf1 bf2
      | Coq_fdiv_op -> bdiv prec emax md bf1 bf2
    in
    Word.repr (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
      (bits_of_binary_float mw ew res)
  
  (** val cond_Zopp : bool -> Big.big_int -> Big.big_int **)
  
  let cond_Zopp b m =
    if b then Z.opp m else m
  
  (** val binary_float_cast :
      Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int -> int0 ->
      binary_float -> binary_float **)
  
  let binary_float_cast prec1 emax1 prec2 emax2 rm bf =
    let md = dec_rounding_mode rm in
    (match bf with
     | B754_finite (sign, mant, ep) ->
       binary_normalize prec2 emax2 md (cond_Zopp sign mant) ep true
     | x -> x)
  
  (** val interp_fcast :
      Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int -> int0 ->
      int0 -> int0 **)
  
  let interp_fcast ew1 mw1 ew2 mw2 rm v =
    let bf_of_bits = binary_float_of_bits mw1 ew1 in
    let bf =
      bf_of_bits
        (Word.unsigned (plus (Coq_Pos.to_nat ew1) (Coq_Pos.to_nat mw1)) v)
    in
    let bf' =
      binary_float_cast (Z.add mw1 Big.one)
        (Z.pow (Big.double Big.one) (Z.sub ew1 Big.one)) (Z.add mw2 Big.one)
        (Z.pow (Big.double Big.one) (Z.sub ew2 Big.one)) rm bf
    in
    Word.repr (plus (Coq_Pos.to_nat ew2) (Coq_Pos.to_nat mw2))
      (bits_of_binary_float mw2 ew2 bf')
  
  (** val interp_rtl_exp : Big.big_int -> rtl_exp -> int0 coq_RTL **)
  
  let rec interp_rtl_exp s = function
  | Coq_arith_rtl_exp (s0, b, e1, e2) ->
    bind (Obj.magic coq_RTL_monad) (interp_rtl_exp s0 e1) (fun v1 ->
      bind (Obj.magic coq_RTL_monad) (interp_rtl_exp s0 e2) (fun v2 ->
        return (Obj.magic coq_RTL_monad) (interp_arith s0 b v1 v2)))
  | Coq_test_rtl_exp (s0, t0, e1, e2) ->
    bind (Obj.magic coq_RTL_monad) (interp_rtl_exp s0 e1) (fun v1 ->
      bind (Obj.magic coq_RTL_monad) (interp_rtl_exp s0 e2) (fun v2 ->
        return (Obj.magic coq_RTL_monad) (interp_test s0 t0 v1 v2)))
  | Coq_if_rtl_exp (s0, cd, e1, e2) ->
    bind (Obj.magic coq_RTL_monad) (interp_rtl_exp size1 cd) (fun v ->
      if Word.eq size1 v (Word.one size1)
      then interp_rtl_exp s0 e1
      else interp_rtl_exp s0 e2)
  | Coq_cast_s_rtl_exp (s1, s2, e0) ->
    bind (Obj.magic coq_RTL_monad) (interp_rtl_exp s1 e0) (fun v ->
      return (Obj.magic coq_RTL_monad) (Word.repr s2 (Word.signed s1 v)))
  | Coq_cast_u_rtl_exp (s1, s2, e0) ->
    bind (Obj.magic coq_RTL_monad) (interp_rtl_exp s1 e0) (fun v ->
      return (Obj.magic coq_RTL_monad) (Word.repr s2 (Word.unsigned s1 v)))
  | Coq_imm_rtl_exp (s0, v) -> return (Obj.magic coq_RTL_monad) v
  | Coq_get_loc_rtl_exp (s0, l) -> get_loc s0 l
  | Coq_get_array_rtl_exp (l, s0, a, e0) ->
    bind (Obj.magic coq_RTL_monad) (interp_rtl_exp l e0) (fun i ->
      get_array l s0 a i)
  | Coq_get_byte_rtl_exp addr ->
    bind (Obj.magic coq_RTL_monad) (interp_rtl_exp M.size_addr addr)
      (fun v -> get_byte v)
  | Coq_choose_rtl_exp s0 -> choose_bits s0
  | Coq_farith_rtl_exp (ew, mw, x, x0, x1, x2) ->
    let len = plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw) in
    bind (Obj.magic coq_RTL_monad) (interp_rtl_exp len x1) (fun v1 ->
      bind (Obj.magic coq_RTL_monad) (interp_rtl_exp len x2) (fun v2 ->
        bind (Obj.magic coq_RTL_monad) (interp_rtl_exp size2 x0) (fun vrm ->
          return (Obj.magic coq_RTL_monad) (interp_farith ew mw x vrm v1 v2))))
  | Coq_fcast_rtl_exp (ew1, mw1, ew2, mw2, rm, e0) ->
    bind (Obj.magic coq_RTL_monad)
      (interp_rtl_exp (plus (Coq_Pos.to_nat ew1) (Coq_Pos.to_nat mw1)) e0)
      (fun v ->
      bind (Obj.magic coq_RTL_monad) (interp_rtl_exp size2 rm) (fun vrm ->
        return (Obj.magic coq_RTL_monad) (interp_fcast ew1 mw1 ew2 mw2 vrm v)))
  
  (** val interp_rtl : rtl_instr -> unit coq_RTL **)
  
  let rec interp_rtl = function
  | Coq_set_loc_rtl (s, e, l) ->
    bind (Obj.magic coq_RTL_monad) (Obj.magic (interp_rtl_exp s e)) (fun v ->
      set_loc s l v)
  | Coq_set_array_rtl (l, s, a, e1, e2) ->
    bind (Obj.magic coq_RTL_monad) (Obj.magic (interp_rtl_exp l e1))
      (fun i ->
      bind (Obj.magic coq_RTL_monad) (Obj.magic (interp_rtl_exp s e2))
        (fun v -> set_array l s a i v))
  | Coq_set_byte_rtl (e, addr) ->
    bind (Obj.magic coq_RTL_monad) (Obj.magic (interp_rtl_exp size8 e))
      (fun v ->
      bind (Obj.magic coq_RTL_monad)
        (Obj.magic (interp_rtl_exp M.size_addr addr)) (fun a -> set_byte a v))
  | Coq_if_rtl (r2, i) ->
    bind (Obj.magic coq_RTL_monad) (Obj.magic (interp_rtl_exp size1 r2))
      (fun v ->
      if Word.eq size1 v (Word.one size1)
      then interp_rtl i
      else return (Obj.magic coq_RTL_monad) ())
  | Coq_error_rtl -> coq_Fail
  | Coq_trap_rtl -> coq_Trap
  
  type instruction = { instr_assembly : char list; instr_rtl : rtl_instr list }
  
  (** val instruction_rect :
      (char list -> rtl_instr list -> 'a1) -> instruction -> 'a1 **)
  
  let instruction_rect f i =
    let { instr_assembly = x; instr_rtl = x0 } = i in f x x0
  
  (** val instruction_rec :
      (char list -> rtl_instr list -> 'a1) -> instruction -> 'a1 **)
  
  let instruction_rec f i =
    let { instr_assembly = x; instr_rtl = x0 } = i in f x x0
  
  (** val instr_assembly : instruction -> char list **)
  
  let instr_assembly i =
    i.instr_assembly
  
  (** val instr_rtl : instruction -> rtl_instr list **)
  
  let instr_rtl i =
    i.instr_rtl
 end

type binary79 = binary_float

(** val b79_of_bits : Big.big_int -> binary79 **)

let b79_of_bits =
  binary_float_of_bits (Big.doubleplusone (Big.doubleplusone
    (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))))
    (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))

(** val bits_of_b79 : binary79 -> Big.big_int **)

let bits_of_b79 =
  bits_of_binary_float (Big.doubleplusone (Big.doubleplusone
    (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))))
    (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))

type de_float = binary79

(** val de_float_of_bits : Big.big_int -> de_float **)

let de_float_of_bits x =
  let (p, ex) =
    split_bits (Big.double (Big.double (Big.double (Big.double (Big.double
      (Big.double Big.one)))))) (Big.doubleplusone (Big.doubleplusone
      (Big.doubleplusone Big.one))) x
  in
  let (sx, mx) = p in
  let mx' =
    Z.modulo mx
      (Z.pow (Big.double Big.one) (Big.doubleplusone (Big.doubleplusone
        (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
        Big.one))))))
  in
  b79_of_bits
    (join_bits (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
      (Big.doubleplusone (Big.doubleplusone Big.one))))) (Big.doubleplusone
      (Big.doubleplusone (Big.doubleplusone Big.one))) sx mx' ex)

(** val bits_of_de_float : de_float -> Big.big_int **)

let bits_of_de_float f =
  let x = bits_of_b79 f in
  let (p, ex) =
    split_bits (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
      (Big.doubleplusone (Big.doubleplusone Big.one))))) (Big.doubleplusone
      (Big.doubleplusone (Big.doubleplusone Big.one))) x
  in
  let (sx, mx) = p in
  if zeq_bool ex Big.zero
  then join_bits (Big.double (Big.double (Big.double (Big.double (Big.double
         (Big.double Big.one)))))) (Big.doubleplusone (Big.doubleplusone
         (Big.doubleplusone Big.one))) sx mx ex
  else if zeq_bool ex
            (Z.sub
              (Z.pow (Big.double Big.one) (Big.doubleplusone
                (Big.doubleplusone (Big.doubleplusone Big.one)))) Big.one)
       then join_bits (Big.double (Big.double (Big.double (Big.double
              (Big.double (Big.double Big.one)))))) (Big.doubleplusone
              (Big.doubleplusone (Big.doubleplusone Big.one))) sx mx ex
       else join_bits (Big.double (Big.double (Big.double (Big.double
              (Big.double (Big.double Big.one)))))) (Big.doubleplusone
              (Big.doubleplusone (Big.doubleplusone Big.one))) sx
              (Z.add
                (Z.pow (Big.double Big.one) (Big.doubleplusone
                  (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
                  (Big.doubleplusone Big.one)))))) mx) ex

module X86_MACHINE = 
 struct 
  (** val size_addr : Big.big_int **)
  
  let size_addr =
    size32
  
  type flag =
  | ID
  | VIP
  | VIF
  | AC
  | VM
  | RF
  | NT
  | IOPL
  | OF
  | DF
  | IF_flag
  | TF
  | SF
  | ZF
  | AF
  | PF
  | CF
  
  (** val flag_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> flag -> 'a1 **)
  
  let flag_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 = function
  | ID -> f
  | VIP -> f0
  | VIF -> f1
  | AC -> f2
  | VM -> f3
  | RF -> f4
  | NT -> f5
  | IOPL -> f6
  | OF -> f7
  | DF -> f8
  | IF_flag -> f9
  | TF -> f10
  | SF -> f11
  | ZF -> f12
  | AF -> f13
  | PF -> f14
  | CF -> f15
  
  (** val flag_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> flag -> 'a1 **)
  
  let flag_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 = function
  | ID -> f
  | VIP -> f0
  | VIF -> f1
  | AC -> f2
  | VM -> f3
  | RF -> f4
  | NT -> f5
  | IOPL -> f6
  | OF -> f7
  | DF -> f8
  | IF_flag -> f9
  | TF -> f10
  | SF -> f11
  | ZF -> f12
  | AF -> f13
  | PF -> f14
  | CF -> f15
  
  (** val flag_eq_dec : flag -> flag -> bool **)
  
  let flag_eq_dec f1 f2 =
    match f1 with
    | ID ->
      (match f2 with
       | ID -> true
       | _ -> false)
    | VIP ->
      (match f2 with
       | VIP -> true
       | _ -> false)
    | VIF ->
      (match f2 with
       | VIF -> true
       | _ -> false)
    | AC ->
      (match f2 with
       | AC -> true
       | _ -> false)
    | VM ->
      (match f2 with
       | VM -> true
       | _ -> false)
    | RF ->
      (match f2 with
       | RF -> true
       | _ -> false)
    | NT ->
      (match f2 with
       | NT -> true
       | _ -> false)
    | IOPL ->
      (match f2 with
       | IOPL -> true
       | _ -> false)
    | OF ->
      (match f2 with
       | OF -> true
       | _ -> false)
    | DF ->
      (match f2 with
       | DF -> true
       | _ -> false)
    | IF_flag ->
      (match f2 with
       | IF_flag -> true
       | _ -> false)
    | TF ->
      (match f2 with
       | TF -> true
       | _ -> false)
    | SF ->
      (match f2 with
       | SF -> true
       | _ -> false)
    | ZF ->
      (match f2 with
       | ZF -> true
       | _ -> false)
    | AF ->
      (match f2 with
       | AF -> true
       | _ -> false)
    | PF ->
      (match f2 with
       | PF -> true
       | _ -> false)
    | CF ->
      (match f2 with
       | CF -> true
       | _ -> false)
  
  type fpu_flag =
  | F_Busy
  | F_C3
  | F_C2
  | F_C1
  | F_C0
  | F_ES
  | F_SF
  | F_PE
  | F_UE
  | F_OE
  | F_ZE
  | F_DE
  | F_IE
  
  (** val fpu_flag_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> fpu_flag -> 'a1 **)
  
  let fpu_flag_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 = function
  | F_Busy -> f
  | F_C3 -> f0
  | F_C2 -> f1
  | F_C1 -> f2
  | F_C0 -> f3
  | F_ES -> f4
  | F_SF -> f5
  | F_PE -> f6
  | F_UE -> f7
  | F_OE -> f8
  | F_ZE -> f9
  | F_DE -> f10
  | F_IE -> f11
  
  (** val fpu_flag_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> 'a1 -> fpu_flag -> 'a1 **)
  
  let fpu_flag_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 = function
  | F_Busy -> f
  | F_C3 -> f0
  | F_C2 -> f1
  | F_C1 -> f2
  | F_C0 -> f3
  | F_ES -> f4
  | F_SF -> f5
  | F_PE -> f6
  | F_UE -> f7
  | F_OE -> f8
  | F_ZE -> f9
  | F_DE -> f10
  | F_IE -> f11
  
  type fpu_ctrl_flag =
  | F_Res15
  | F_Res14
  | F_Res13
  | F_Res7
  | F_Res6
  | F_IC
  | F_PM
  | F_UM
  | F_OM
  | F_ZM
  | F_DM
  | F_IM
  
  (** val fpu_ctrl_flag_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> fpu_ctrl_flag -> 'a1 **)
  
  let fpu_ctrl_flag_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 = function
  | F_Res15 -> f
  | F_Res14 -> f0
  | F_Res13 -> f1
  | F_Res7 -> f2
  | F_Res6 -> f3
  | F_IC -> f4
  | F_PM -> f5
  | F_UM -> f6
  | F_OM -> f7
  | F_ZM -> f8
  | F_DM -> f9
  | F_IM -> f10
  
  (** val fpu_ctrl_flag_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 ->
      'a1 -> 'a1 -> fpu_ctrl_flag -> 'a1 **)
  
  let fpu_ctrl_flag_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 = function
  | F_Res15 -> f
  | F_Res14 -> f0
  | F_Res13 -> f1
  | F_Res7 -> f2
  | F_Res6 -> f3
  | F_IC -> f4
  | F_PM -> f5
  | F_UM -> f6
  | F_OM -> f7
  | F_ZM -> f8
  | F_DM -> f9
  | F_IM -> f10
  
  (** val size11 : Big.big_int **)
  
  let size11 =
    Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ Big.zero)))))))))
  
  (** val size48 : Big.big_int **)
  
  let size48 =
    Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero))))))))))))))))))))))))))))))))))))))))))))))
  
  type int48 = Word.int
  
  type loc =
  | Coq_reg_loc of register
  | Coq_seg_reg_start_loc of segment_register
  | Coq_seg_reg_limit_loc of segment_register
  | Coq_flag_loc of flag
  | Coq_control_register_loc of control_register
  | Coq_debug_register_loc of debug_register
  | Coq_pc_loc
  | Coq_fpu_stktop_loc
  | Coq_fpu_flag_loc of fpu_flag
  | Coq_fpu_rctrl_loc
  | Coq_fpu_pctrl_loc
  | Coq_fpu_ctrl_flag_loc of fpu_ctrl_flag
  | Coq_fpu_lastInstrPtr_loc
  | Coq_fpu_lastDataPtr_loc
  | Coq_fpu_lastOpcode_loc
  
  (** val loc_rect :
      (register -> 'a1) -> (segment_register -> 'a1) -> (segment_register ->
      'a1) -> (flag -> 'a1) -> (control_register -> 'a1) -> (debug_register
      -> 'a1) -> 'a1 -> 'a1 -> (fpu_flag -> 'a1) -> 'a1 -> 'a1 ->
      (fpu_ctrl_flag -> 'a1) -> 'a1 -> 'a1 -> 'a1 -> Big.big_int -> loc ->
      'a1 **)
  
  let loc_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 n = function
  | Coq_reg_loc x -> f x
  | Coq_seg_reg_start_loc x -> f0 x
  | Coq_seg_reg_limit_loc x -> f1 x
  | Coq_flag_loc x -> f2 x
  | Coq_control_register_loc x -> f3 x
  | Coq_debug_register_loc x -> f4 x
  | Coq_pc_loc -> f5
  | Coq_fpu_stktop_loc -> f6
  | Coq_fpu_flag_loc x -> f7 x
  | Coq_fpu_rctrl_loc -> f8
  | Coq_fpu_pctrl_loc -> f9
  | Coq_fpu_ctrl_flag_loc x -> f10 x
  | Coq_fpu_lastInstrPtr_loc -> f11
  | Coq_fpu_lastDataPtr_loc -> f12
  | Coq_fpu_lastOpcode_loc -> f13
  
  (** val loc_rec :
      (register -> 'a1) -> (segment_register -> 'a1) -> (segment_register ->
      'a1) -> (flag -> 'a1) -> (control_register -> 'a1) -> (debug_register
      -> 'a1) -> 'a1 -> 'a1 -> (fpu_flag -> 'a1) -> 'a1 -> 'a1 ->
      (fpu_ctrl_flag -> 'a1) -> 'a1 -> 'a1 -> 'a1 -> Big.big_int -> loc ->
      'a1 **)
  
  let loc_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 n = function
  | Coq_reg_loc x -> f x
  | Coq_seg_reg_start_loc x -> f0 x
  | Coq_seg_reg_limit_loc x -> f1 x
  | Coq_flag_loc x -> f2 x
  | Coq_control_register_loc x -> f3 x
  | Coq_debug_register_loc x -> f4 x
  | Coq_pc_loc -> f5
  | Coq_fpu_stktop_loc -> f6
  | Coq_fpu_flag_loc x -> f7 x
  | Coq_fpu_rctrl_loc -> f8
  | Coq_fpu_pctrl_loc -> f9
  | Coq_fpu_ctrl_flag_loc x -> f10 x
  | Coq_fpu_lastInstrPtr_loc -> f11
  | Coq_fpu_lastDataPtr_loc -> f12
  | Coq_fpu_lastOpcode_loc -> f13
  
  type location = loc
  
  type arr =
  | Coq_fpu_datareg
  | Coq_fpu_tag
  
  (** val arr_rect :
      'a1 -> 'a1 -> Big.big_int -> Big.big_int -> arr -> 'a1 **)
  
  let arr_rect f f0 n n0 = function
  | Coq_fpu_datareg -> f
  | Coq_fpu_tag -> f0
  
  (** val arr_rec :
      'a1 -> 'a1 -> Big.big_int -> Big.big_int -> arr -> 'a1 **)
  
  let arr_rec f f0 n n0 = function
  | Coq_fpu_datareg -> f
  | Coq_fpu_tag -> f0
  
  type array = arr
  
  type ('a, 'b) fmap = 'a -> 'b
  
  (** val upd :
      ('a1 -> 'a1 -> bool) -> ('a1, 'a2) fmap -> 'a1 -> 'a2 -> ('a1, 'a2)
      fmap **)
  
  let upd eq_dec0 f x v y =
    if eq_dec0 x y then v else f y
  
  (** val look : ('a1, 'a2) fmap -> 'a1 -> 'a2 **)
  
  let look f x =
    f x
  
  type core_state = { gp_regs : (register, int32) fmap;
                      seg_regs_starts : (segment_register, int32) fmap;
                      seg_regs_limits : (segment_register, int32) fmap;
                      flags_reg : (flag, int1) fmap;
                      control_regs : (control_register, int32) fmap;
                      debug_regs : (debug_register, int32) fmap;
                      pc_reg : int0 }
  
  (** val core_state_rect :
      ((register, int32) fmap -> (segment_register, int32) fmap ->
      (segment_register, int32) fmap -> (flag, int1) fmap ->
      (control_register, int32) fmap -> (debug_register, int32) fmap -> int0
      -> 'a1) -> core_state -> 'a1 **)
  
  let core_state_rect f c =
    let { gp_regs = x; seg_regs_starts = x0; seg_regs_limits = x1;
      flags_reg = x2; control_regs = x3; debug_regs = x4; pc_reg = x5 } = c
    in
    f x x0 x1 x2 x3 x4 x5
  
  (** val core_state_rec :
      ((register, int32) fmap -> (segment_register, int32) fmap ->
      (segment_register, int32) fmap -> (flag, int1) fmap ->
      (control_register, int32) fmap -> (debug_register, int32) fmap -> int0
      -> 'a1) -> core_state -> 'a1 **)
  
  let core_state_rec f c =
    let { gp_regs = x; seg_regs_starts = x0; seg_regs_limits = x1;
      flags_reg = x2; control_regs = x3; debug_regs = x4; pc_reg = x5 } = c
    in
    f x x0 x1 x2 x3 x4 x5
  
  (** val gp_regs : core_state -> (register, int32) fmap **)
  
  let gp_regs x = x.gp_regs
  
  (** val seg_regs_starts : core_state -> (segment_register, int32) fmap **)
  
  let seg_regs_starts x = x.seg_regs_starts
  
  (** val seg_regs_limits : core_state -> (segment_register, int32) fmap **)
  
  let seg_regs_limits x = x.seg_regs_limits
  
  (** val flags_reg : core_state -> (flag, int1) fmap **)
  
  let flags_reg x = x.flags_reg
  
  (** val control_regs : core_state -> (control_register, int32) fmap **)
  
  let control_regs x = x.control_regs
  
  (** val debug_regs : core_state -> (debug_register, int32) fmap **)
  
  let debug_regs x = x.debug_regs
  
  (** val pc_reg : core_state -> int0 **)
  
  let pc_reg x = x.pc_reg
  
  type fpu_state = { fpu_data_regs : (int3, int80) fmap; fpu_status : 
                     int16; fpu_control : int16;
                     fpu_tags : (int3, int2) fmap; fpu_lastInstrPtr : 
                     int48; fpu_lastDataPtr : int48; fpu_lastOpcode : 
                     int0 }
  
  (** val fpu_state_rect :
      ((int3, int80) fmap -> int16 -> int16 -> (int3, int2) fmap -> int48 ->
      int48 -> int0 -> 'a1) -> fpu_state -> 'a1 **)
  
  let fpu_state_rect f f0 =
    let { fpu_data_regs = x; fpu_status = x0; fpu_control = x1; fpu_tags =
      x2; fpu_lastInstrPtr = x3; fpu_lastDataPtr = x4; fpu_lastOpcode =
      x5 } = f0
    in
    f x x0 x1 x2 x3 x4 x5
  
  (** val fpu_state_rec :
      ((int3, int80) fmap -> int16 -> int16 -> (int3, int2) fmap -> int48 ->
      int48 -> int0 -> 'a1) -> fpu_state -> 'a1 **)
  
  let fpu_state_rec f f0 =
    let { fpu_data_regs = x; fpu_status = x0; fpu_control = x1; fpu_tags =
      x2; fpu_lastInstrPtr = x3; fpu_lastDataPtr = x4; fpu_lastOpcode =
      x5 } = f0
    in
    f x x0 x1 x2 x3 x4 x5
  
  (** val fpu_data_regs : fpu_state -> (int3, int80) fmap **)
  
  let fpu_data_regs x = x.fpu_data_regs
  
  (** val fpu_status : fpu_state -> int16 **)
  
  let fpu_status x = x.fpu_status
  
  (** val fpu_control : fpu_state -> int16 **)
  
  let fpu_control x = x.fpu_control
  
  (** val fpu_tags : fpu_state -> (int3, int2) fmap **)
  
  let fpu_tags x = x.fpu_tags
  
  (** val fpu_lastInstrPtr : fpu_state -> int48 **)
  
  let fpu_lastInstrPtr x = x.fpu_lastInstrPtr
  
  (** val fpu_lastDataPtr : fpu_state -> int48 **)
  
  let fpu_lastDataPtr x = x.fpu_lastDataPtr
  
  (** val fpu_lastOpcode : fpu_state -> int0 **)
  
  let fpu_lastOpcode x = x.fpu_lastOpcode
  
  type mach = { core : core_state; fpu : fpu_state }
  
  (** val mach_rect : (core_state -> fpu_state -> 'a1) -> mach -> 'a1 **)
  
  let mach_rect f m =
    let { core = x; fpu = x0 } = m in f x x0
  
  (** val mach_rec : (core_state -> fpu_state -> 'a1) -> mach -> 'a1 **)
  
  let mach_rec f m =
    let { core = x; fpu = x0 } = m in f x x0
  
  (** val core : mach -> core_state **)
  
  let core x = x.core
  
  (** val fpu : mach -> fpu_state **)
  
  let fpu x = x.fpu
  
  type mach_state = mach
  
  (** val get_bits_rng :
      Big.big_int -> int0 -> Big.big_int -> Big.big_int -> int0 **)
  
  let get_bits_rng s i n m =
    Word.repr (minus m n)
      (Word.unsigned s (Word.shru s i (Word.repr s (Z.of_nat n))))
  
  (** val set_bits_rng :
      Big.big_int -> int0 -> Big.big_int -> Big.big_int -> int0 -> int0 **)
  
  let set_bits_rng s i n m v =
    let highbits =
      Word.unsigned s
        (Word.shru s i (Word.repr s (Z.add (Z.of_nat m) Big.one)))
    in
    let lowbits = Z.modulo (Word.unsigned s i) (two_power_nat n) in
    Word.repr s
      (Z.add
        (Z.add lowbits
          (Z.mul (Word.unsigned (minus m n) v) (two_power_nat n)))
        (Z.mul highbits (two_power_nat (plus m (Big.succ Big.zero)))))
  
  (** val get_bit : Big.big_int -> int0 -> Big.big_int -> int1 **)
  
  let get_bit s i n =
    let wordsize0 = Big.succ s in
    if Word.bits_of_Z wordsize0 (Word.unsigned s i) n
    then Word.one Big.zero
    else Word.zero Big.zero
  
  (** val set_bit : Big.big_int -> int0 -> Big.big_int -> bool -> int0 **)
  
  let set_bit s i n v =
    set_bits_rng s i n n (Word.bool_to_int (minus n n) v)
  
  (** val get_fpu_flag_reg : fpu_flag -> fpu_state -> int1 **)
  
  let get_fpu_flag_reg f fs =
    match f with
    | F_Busy ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status
        (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))
    | F_C3 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        (Big.doubleplusone (Big.doubleplusone Big.one)))
    | F_C2 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        (Big.doubleplusone (Big.double Big.one)))
    | F_C1 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status
        (Big.doubleplusone (Big.double (Big.double Big.one)))
    | F_C0 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        (Big.double (Big.double Big.one)))
    | F_ES ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status
        (Big.doubleplusone (Big.doubleplusone Big.one))
    | F_SF ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        (Big.doubleplusone Big.one))
    | F_PE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status
        (Big.doubleplusone (Big.double Big.one))
    | F_UE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        (Big.double Big.one))
    | F_OE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status
        (Big.doubleplusone Big.one)
    | F_ZE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.double
        Big.one)
    | F_DE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status Big.one
    | F_IE ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status Big.zero
  
  (** val get_stktop_reg : fpu_state -> int3 **)
  
  let get_stktop_reg fs =
    get_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_status (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ Big.zero))))))))))) (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))
  
  (** val get_fpu_ctrl_flag_reg : fpu_ctrl_flag -> fpu_state -> int1 **)
  
  let get_fpu_ctrl_flag_reg f fs =
    match f with
    | F_Res15 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))
    | F_Res14 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.double (Big.doubleplusone (Big.doubleplusone Big.one)))
    | F_Res13 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.doubleplusone (Big.double (Big.doubleplusone Big.one)))
    | F_Res7 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.doubleplusone (Big.doubleplusone Big.one))
    | F_Res6 ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.double (Big.doubleplusone Big.one))
    | F_IC ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.double (Big.double (Big.doubleplusone Big.one)))
    | F_PM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.doubleplusone (Big.double Big.one))
    | F_UM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.double (Big.double Big.one))
    | F_OM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.doubleplusone Big.one)
    | F_ZM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control
        (Big.double Big.one)
    | F_DM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control Big.one
    | F_IM ->
      get_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control Big.zero
  
  (** val get_rctrl_reg : fpu_state -> int2 **)
  
  let get_rctrl_reg fs =
    get_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero)))))))))) (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ Big.zero)))))))))))
  
  (** val get_pctrl_reg : fpu_state -> int2 **)
  
  let get_pctrl_reg fs =
    get_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero))))))))))))))) fs.fpu_control (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero)))))))) (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))
  
  (** val get_location : Big.big_int -> loc -> mach_state -> int0 **)
  
  let get_location s l m =

    match l with
    | Coq_reg_loc r2 -> look m.core.gp_regs r2
    | Coq_seg_reg_start_loc r2 -> look m.core.seg_regs_starts r2
    | Coq_seg_reg_limit_loc r2 -> look m.core.seg_regs_limits r2
    | Coq_flag_loc f -> look m.core.flags_reg f
    | Coq_control_register_loc r2 -> look m.core.control_regs r2
    | Coq_debug_register_loc r2 -> look m.core.debug_regs r2
    | Coq_pc_loc -> m.core.pc_reg
    | Coq_fpu_stktop_loc -> get_stktop_reg m.fpu
    | Coq_fpu_flag_loc f -> get_fpu_flag_reg f m.fpu
    | Coq_fpu_ctrl_flag_loc f -> get_fpu_ctrl_flag_reg f m.fpu
    | Coq_fpu_lastInstrPtr_loc -> m.fpu.fpu_lastInstrPtr
    | Coq_fpu_lastDataPtr_loc -> m.fpu.fpu_lastDataPtr
    | Coq_fpu_lastOpcode_loc -> m.fpu.fpu_lastOpcode
    | _ -> get_rctrl_reg m.fpu
  
  (** val set_gp_reg : register -> int32 -> mach -> mach **)
  
  let set_gp_reg r2 v m =
    { core = { gp_regs = (upd register_eq_dec m.core.gp_regs r2 v);
      seg_regs_starts = m.core.seg_regs_starts; seg_regs_limits =
      m.core.seg_regs_limits; flags_reg = m.core.flags_reg; control_regs =
      m.core.control_regs; debug_regs = m.core.debug_regs; pc_reg =
      m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_seg_reg_start : segment_register -> int32 -> mach -> mach **)
  
  let set_seg_reg_start r2 v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      (upd segment_register_eq_dec m.core.seg_regs_starts r2 v);
      seg_regs_limits = m.core.seg_regs_limits; flags_reg = m.core.flags_reg;
      control_regs = m.core.control_regs; debug_regs = m.core.debug_regs;
      pc_reg = m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_seg_reg_limit : segment_register -> int32 -> mach -> mach **)
  
  let set_seg_reg_limit r2 v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      m.core.seg_regs_starts; seg_regs_limits =
      (upd segment_register_eq_dec m.core.seg_regs_limits r2 v); flags_reg =
      m.core.flags_reg; control_regs = m.core.control_regs; debug_regs =
      m.core.debug_regs; pc_reg = m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_flags_reg : flag -> int1 -> mach -> mach **)
  
  let set_flags_reg r2 v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      m.core.seg_regs_starts; seg_regs_limits = m.core.seg_regs_limits;
      flags_reg = (upd flag_eq_dec m.core.flags_reg r2 v); control_regs =
      m.core.control_regs; debug_regs = m.core.debug_regs; pc_reg =
      m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_control_reg : control_register -> int32 -> mach -> mach **)
  
  let set_control_reg r2 v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      m.core.seg_regs_starts; seg_regs_limits = m.core.seg_regs_limits;
      flags_reg = m.core.flags_reg; control_regs =
      (upd control_register_eq_dec m.core.control_regs r2 v); debug_regs =
      m.core.debug_regs; pc_reg = m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_debug_reg : debug_register -> int32 -> mach -> mach **)
  
  let set_debug_reg r2 v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      m.core.seg_regs_starts; seg_regs_limits = m.core.seg_regs_limits;
      flags_reg = m.core.flags_reg; control_regs = m.core.control_regs;
      debug_regs = (upd debug_register_eq_dec m.core.debug_regs r2 v);
      pc_reg = m.core.pc_reg }; fpu = m.fpu }
  
  (** val set_pc : int0 -> mach -> mach **)
  
  let set_pc v m =
    { core = { gp_regs = m.core.gp_regs; seg_regs_starts =
      m.core.seg_regs_starts; seg_regs_limits = m.core.seg_regs_limits;
      flags_reg = m.core.flags_reg; control_regs = m.core.control_regs;
      debug_regs = m.core.debug_regs; pc_reg = v }; fpu = m.fpu }
  
  (** val set_fpu_stktop_reg : int3 -> mach -> mach **)
  
  let set_fpu_stktop_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status =
      (set_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
        m.fpu.fpu_status (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))) (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ Big.zero))))))))))))) v); fpu_control = m.fpu.fpu_control;
      fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = m.fpu.fpu_lastDataPtr; fpu_lastOpcode =
      m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_flags_reg : fpu_flag -> int1 -> mach -> mach **)
  
  let set_fpu_flags_reg f v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status =
      (let old_status = m.fpu.fpu_status in
       let b = negb (Word.eq Big.zero v (Word.zero Big.zero)) in
       (match f with
        | F_Busy ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) b
        | F_C3 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))))))))) b
        | F_C2 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))) b
        | F_C1 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))) b
        | F_C0 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))) b
        | F_ES ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ Big.zero))))))) b
        | F_SF ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            Big.zero)))))) b
        | F_PE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ Big.zero))))) b
        | F_UE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))) b
        | F_OE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ (Big.succ Big.zero))) b
        | F_ZE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ (Big.succ Big.zero)) b
        | F_DE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            (Big.succ Big.zero) b
        | F_IE ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_status
            Big.zero b)); fpu_control = m.fpu.fpu_control; fpu_tags =
      m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = m.fpu.fpu_lastDataPtr; fpu_lastOpcode =
      m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_rctrl_reg : int2 -> mach -> mach **)
  
  let set_fpu_rctrl_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control =
      (set_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
        m.fpu.fpu_control (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ Big.zero))))))))))
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ Big.zero))))))))))) v);
      fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = m.fpu.fpu_lastDataPtr; fpu_lastOpcode =
      m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_pctrl_reg : int2 -> mach -> mach **)
  
  let set_fpu_pctrl_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control =
      (set_bits_rng (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
        m.fpu.fpu_control (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ Big.zero)))))))) (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))) v); fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr =
      m.fpu.fpu_lastInstrPtr; fpu_lastDataPtr = m.fpu.fpu_lastDataPtr;
      fpu_lastOpcode = m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_ctrl_reg : fpu_ctrl_flag -> int1 -> mach -> mach **)
  
  let set_fpu_ctrl_reg f v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control =
      (let old_ctrl = m.fpu.fpu_control in
       let b = negb (Word.eq Big.zero v (Word.zero Big.zero)) in
       (match f with
        | F_Res15 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) b
        | F_Res14 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))))))))) b
        | F_Res13 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ Big.zero))))))))))))) b
        | F_Res7 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ Big.zero))))))) b
        | F_Res6 ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            Big.zero)))))) b
        | F_IC ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            Big.zero)))))))))))) b
        | F_PM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ Big.zero))))) b
        | F_UM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))) b
        | F_OM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ (Big.succ Big.zero))) b
        | F_ZM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ (Big.succ Big.zero)) b
        | F_DM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            (Big.succ Big.zero) b
        | F_IM ->
          set_bit (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ Big.zero))))))))))))))) old_ctrl
            Big.zero b)); fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr =
      m.fpu.fpu_lastInstrPtr; fpu_lastDataPtr = m.fpu.fpu_lastDataPtr;
      fpu_lastOpcode = m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_lastInstrPtr_reg : int48 -> mach -> mach **)
  
  let set_fpu_lastInstrPtr_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control = m.fpu.fpu_control;
      fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr = v; fpu_lastDataPtr =
      m.fpu.fpu_lastDataPtr; fpu_lastOpcode = m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_lastDataPtr_reg : int48 -> mach -> mach **)
  
  let set_fpu_lastDataPtr_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control = m.fpu.fpu_control;
      fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = v; fpu_lastOpcode = m.fpu.fpu_lastOpcode } }
  
  (** val set_lastOpcode_reg : int0 -> mach -> mach **)
  
  let set_lastOpcode_reg v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control = m.fpu.fpu_control;
      fpu_tags = m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = m.fpu.fpu_lastDataPtr; fpu_lastOpcode = v } }
  
  (** val set_location : Big.big_int -> loc -> int0 -> mach -> mach_state **)
  
  let set_location s l v m =
    match l with
    | Coq_reg_loc r2 -> set_gp_reg r2 v m
    | Coq_seg_reg_start_loc r2 -> set_seg_reg_start r2 v m
    | Coq_seg_reg_limit_loc r2 -> set_seg_reg_limit r2 v m
    | Coq_flag_loc f -> set_flags_reg f v m
    | Coq_control_register_loc r2 -> set_control_reg r2 v m
    | Coq_debug_register_loc r2 -> set_debug_reg r2 v m
    | Coq_pc_loc -> set_pc v m
    | Coq_fpu_stktop_loc -> set_fpu_stktop_reg v m
    | Coq_fpu_flag_loc f -> set_fpu_flags_reg f v m
    | Coq_fpu_rctrl_loc -> set_fpu_rctrl_reg v m
    | Coq_fpu_pctrl_loc -> set_fpu_pctrl_reg v m
    | Coq_fpu_ctrl_flag_loc f -> set_fpu_ctrl_reg f v m
    | Coq_fpu_lastInstrPtr_loc -> set_fpu_lastInstrPtr_reg v m
    | Coq_fpu_lastDataPtr_loc -> set_fpu_lastDataPtr_reg v m
    | Coq_fpu_lastOpcode_loc -> set_lastOpcode_reg v m
  
  (** val array_sub :
      Big.big_int -> Big.big_int -> array -> int0 -> mach_state -> int0 **)
  
  let array_sub l s a i m =
    match a with
    | Coq_fpu_datareg -> look m.fpu.fpu_data_regs i
    | Coq_fpu_tag -> look m.fpu.fpu_tags i
  
  (** val set_fpu_datareg : int3 -> int80 -> mach -> mach **)
  
  let set_fpu_datareg r2 v m =
    { core = m.core; fpu = { fpu_data_regs =
      (upd (Word.eq_dec size3) m.fpu.fpu_data_regs r2 v); fpu_status =
      m.fpu.fpu_status; fpu_control = m.fpu.fpu_control; fpu_tags =
      m.fpu.fpu_tags; fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr;
      fpu_lastDataPtr = m.fpu.fpu_lastDataPtr; fpu_lastOpcode =
      m.fpu.fpu_lastOpcode } }
  
  (** val set_fpu_tags_reg : Word.int -> int2 -> mach -> mach **)
  
  let set_fpu_tags_reg r2 v m =
    { core = m.core; fpu = { fpu_data_regs = m.fpu.fpu_data_regs;
      fpu_status = m.fpu.fpu_status; fpu_control = m.fpu.fpu_control;
      fpu_tags = (upd (Word.eq_dec size3) m.fpu.fpu_tags r2 v);
      fpu_lastInstrPtr = m.fpu.fpu_lastInstrPtr; fpu_lastDataPtr =
      m.fpu.fpu_lastDataPtr; fpu_lastOpcode = m.fpu.fpu_lastOpcode } }
  
  (** val array_upd :
      Big.big_int -> Big.big_int -> array -> int0 -> int0 -> mach ->
      mach_state **)
  
  let array_upd l s a i v m =
    match a with
    | Coq_fpu_datareg -> set_fpu_datareg i v m
    | Coq_fpu_tag -> set_fpu_tags_reg i v m
 end

module X86_RTL = RTL(X86_MACHINE)

module X86_Compile = 
 struct 
  type conv_state =
    X86_RTL.rtl_instr list
    (* singleton inductive, whose constructor was Build_conv_state *)
  
  (** val conv_state_rect :
      (X86_RTL.rtl_instr list -> 'a1) -> conv_state -> 'a1 **)
  
  let conv_state_rect f c =
    f c
  
  (** val conv_state_rec :
      (X86_RTL.rtl_instr list -> 'a1) -> conv_state -> 'a1 **)
  
  let conv_state_rec f c =
    f c
  
  (** val c_rev_i : conv_state -> X86_RTL.rtl_instr list **)
  
  let c_rev_i c =
    c
  
  type 't coq_Conv = conv_state -> 't * conv_state
  
  (** val coq_Conv_monad : __ coq_Conv monad **)
  
  let coq_Conv_monad =
    { return = (fun _ x s -> (x, s)); bind = (fun _ _ c f s ->
      let (v, s') = c s in f v s') }
  
  (** val runConv : unit coq_Conv -> X86_RTL.rtl_instr list **)
  
  let runConv c =
    let (u, c') = c [] in rev (c_rev_i c')
  
  (** val coq_EMIT : X86_RTL.rtl_instr -> unit coq_Conv **)
  
  let coq_EMIT i s =
    ((), (i :: (c_rev_i s)))
  
  (** val load_Z : Big.big_int -> Big.big_int -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_Z s i =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_imm_rtl_exp (s,
      (Word.repr s i)))
  
  (** val load_int : Big.big_int -> int0 -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_int s i =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_imm_rtl_exp (s, i))
  
  (** val arith :
      Big.big_int -> X86_RTL.bit_vector_op -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let arith s b e1 e2 =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_arith_rtl_exp (s, b, e1,
      e2))
  
  (** val test :
      Big.big_int -> X86_RTL.test_op -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let test s t0 e1 e2 =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_test_rtl_exp (s, t0, e1,
      e2))
  
  (** val load_reg : register -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_reg r2 =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size32,
      (X86_MACHINE.Coq_reg_loc r2)))
  
  (** val set_reg : X86_RTL.rtl_exp -> register -> unit coq_Conv **)
  
  let set_reg p r2 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (size32, p, (X86_MACHINE.Coq_reg_loc
      r2)))
  
  (** val cast_u :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let cast_u s1 s2 e =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_cast_u_rtl_exp (s1, s2,
      e))
  
  (** val cast_s :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let cast_s s1 s2 e =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_cast_s_rtl_exp (s1, s2,
      e))
  
  (** val get_seg_start : segment_register -> X86_RTL.rtl_exp coq_Conv **)
  
  let get_seg_start s =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size32,
      (X86_MACHINE.Coq_seg_reg_start_loc s)))
  
  (** val get_seg_limit : segment_register -> X86_RTL.rtl_exp coq_Conv **)
  
  let get_seg_limit s =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size32,
      (X86_MACHINE.Coq_seg_reg_limit_loc s)))
  
  (** val read_byte : X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let read_byte a =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_byte_rtl_exp a)
  
  (** val write_byte :
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let write_byte v a =
    coq_EMIT (X86_RTL.Coq_set_byte_rtl (v, a))
  
  (** val get_flag : X86_MACHINE.flag -> X86_RTL.rtl_exp coq_Conv **)
  
  let get_flag fl =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size1,
      (X86_MACHINE.Coq_flag_loc fl)))
  
  (** val set_flag : X86_MACHINE.flag -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_flag fl r2 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (size1, r2, (X86_MACHINE.Coq_flag_loc
      fl)))
  
  (** val get_pc : X86_RTL.rtl_exp coq_Conv **)
  
  let get_pc =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size32,
      X86_MACHINE.Coq_pc_loc))
  
  (** val set_pc : X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_pc v =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (size32, v, X86_MACHINE.Coq_pc_loc))
  
  (** val if_exp :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let if_exp s g e1 e2 =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_if_rtl_exp (s, g, e1, e2))
  
  (** val if_test : X86_RTL.rtl_exp -> X86_RTL.rtl_instr -> unit coq_Conv **)
  
  let if_test g i =
    coq_EMIT (X86_RTL.Coq_if_rtl (g, i))
  
  (** val choose : Big.big_int -> X86_RTL.rtl_exp coq_Conv **)
  
  let choose s =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_choose_rtl_exp s)
  
  (** val not :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let not s p =
    bind (Obj.magic coq_Conv_monad) (load_Z s (Word.max_unsigned s))
      (fun mask0 -> arith s X86_RTL.Coq_xor_op p mask0)
  
  (** val undef_flag : X86_MACHINE.flag -> unit coq_Conv **)
  
  let undef_flag f =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (choose size1)) (fun v ->
      set_flag f v)
  
  (** val first_bits :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let first_bits s1 s2 x =
    bind (Obj.magic coq_Conv_monad) (load_Z s2 (Z.of_nat (minus s2 s1)))
      (fun c ->
      bind (Obj.magic coq_Conv_monad) (arith s2 X86_RTL.Coq_shru_op x c)
        (fun r2 -> cast_u s2 s1 r2))
  
  (** val last_bits :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let last_bits s1 s2 x =
    bind (Obj.magic coq_Conv_monad)
      (load_Z s2 (two_power_nat (plus s1 (Big.succ Big.zero)))) (fun c ->
      bind (Obj.magic coq_Conv_monad) (arith s2 X86_RTL.Coq_modu_op x c)
        (fun r2 -> cast_u s2 s1 r2))
  
  (** val concat_bits :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let concat_bits s1 s2 x y =
    bind (Obj.magic coq_Conv_monad)
      (cast_u s1 (plus (plus s1 s2) (Big.succ Big.zero)) x) (fun x' ->
      bind (Obj.magic coq_Conv_monad)
        (load_Z (plus (plus s1 s2) (Big.succ Big.zero))
          (Z.of_nat (plus s2 (Big.succ Big.zero)))) (fun c ->
        bind (Obj.magic coq_Conv_monad)
          (arith (plus (plus s1 s2) (Big.succ Big.zero)) X86_RTL.Coq_shl_op
            x' c) (fun raised_x ->
          bind (Obj.magic coq_Conv_monad)
            (cast_u s2 (plus (plus s1 s2) (Big.succ Big.zero)) y) (fun y' ->
            arith (plus (plus s1 s2) (Big.succ Big.zero)) X86_RTL.Coq_add_op
              raised_x y'))))
  
  (** val copy_ps :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let copy_ps s rs =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_cast_u_rtl_exp (s, s, rs))
  
  (** val scale_to_int32 : scale -> int32 **)
  
  let scale_to_int32 s =
    Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero)))))))))))))))))))))))))))))))
      (match s with
       | Scale1 -> Big.one
       | Scale2 -> (Big.double Big.one)
       | Scale4 -> (Big.double (Big.double Big.one))
       | Scale8 -> (Big.double (Big.double (Big.double Big.one))))
  
  (** val compute_addr : address -> X86_RTL.rtl_exp coq_Conv **)
  
  let compute_addr a =
    let disp = a.addrDisp in
    (match a.addrBase with
     | Some r2 ->
       (match a.addrIndex with
        | Some p ->
          let (s, r3) = p in
          bind (Obj.magic coq_Conv_monad) (load_reg r2) (fun b ->
            bind (Obj.magic coq_Conv_monad) (load_reg r3) (fun i ->
              bind (Obj.magic coq_Conv_monad)
                (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
                  (scale_to_int32 s)) (fun s0 ->
                bind (Obj.magic coq_Conv_monad)
                  (arith size32 X86_RTL.Coq_mul_op i s0) (fun p0 ->
                  bind (Obj.magic coq_Conv_monad)
                    (arith size32 X86_RTL.Coq_add_op b p0) (fun p1 ->
                    bind (Obj.magic coq_Conv_monad)
                      (load_int (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ
                        Big.zero))))))))))))))))))))))))))))))) disp)
                      (fun disp0 -> arith size32 X86_RTL.Coq_add_op p1 disp0))))))
        | None ->
          bind (Obj.magic coq_Conv_monad) (load_reg r2) (fun p1 ->
            bind (Obj.magic coq_Conv_monad)
              (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
                disp) (fun p2 -> arith size32 X86_RTL.Coq_add_op p1 p2)))
     | None ->
       (match a.addrIndex with
        | Some p ->
          let (s, r2) = p in
          bind (Obj.magic coq_Conv_monad) (load_reg r2) (fun i ->
            bind (Obj.magic coq_Conv_monad)
              (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
                (scale_to_int32 s)) (fun s0 ->
              bind (Obj.magic coq_Conv_monad)
                (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                  (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
                  disp) (fun disp0 ->
                bind (Obj.magic coq_Conv_monad)
                  (arith size32 X86_RTL.Coq_mul_op i s0) (fun p0 ->
                  arith (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ Big.zero)))))))))))))))))))))))))))))))
                    X86_RTL.Coq_add_op disp0 p0))))
        | None ->
          load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))) disp))
  
  (** val add_and_check_segment :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let add_and_check_segment seg a =
    bind (Obj.magic coq_Conv_monad) (get_seg_start seg) (fun p1 ->
      bind (Obj.magic coq_Conv_monad) (arith size32 X86_RTL.Coq_add_op p1 a)
        (fun p2 ->
        bind (Obj.magic coq_Conv_monad) (get_seg_limit seg) (fun p3 ->
          bind (Obj.magic coq_Conv_monad)
            (test size32 X86_RTL.Coq_ltu_op p3 a) (fun guard ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic
                (coq_EMIT (X86_RTL.Coq_if_rtl (guard, X86_RTL.Coq_trap_rtl))))
              (fun x -> return (Obj.magic coq_Conv_monad) p2)))))
  
  (** val lmem :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let lmem seg a =
    bind (Obj.magic coq_Conv_monad) (add_and_check_segment seg a) (fun p ->
      read_byte p)
  
  (** val smem :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let smem seg v a =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (add_and_check_segment seg a))
      (fun p -> write_byte v p)
  
  (** val load_mem_n :
      segment_register -> X86_RTL.rtl_exp -> Big.big_int -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let rec load_mem_n seg addr nbytes_minus_one =
    Big.nat_case
      (fun _ ->
      lmem seg addr)
      (fun n ->
      bind (Obj.magic coq_Conv_monad) (load_mem_n seg addr n) (fun rec0 ->
        bind (Obj.magic coq_Conv_monad)
          (load_Z size32 (Z.of_nat (Big.succ n))) (fun count ->
          bind (Obj.magic coq_Conv_monad)
            (arith size32 X86_RTL.Coq_add_op addr count) (fun p3 ->
            bind (Obj.magic coq_Conv_monad) (lmem seg p3) (fun nb ->
              bind (Obj.magic coq_Conv_monad)
                (cast_u
                  (minus
                    (mult (plus n (Big.succ Big.zero)) (Big.succ (Big.succ
                      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                      (Big.succ Big.zero))))))))) (Big.succ Big.zero))
                  (minus
                    (mult (plus nbytes_minus_one (Big.succ Big.zero))
                      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                      (Big.succ (Big.succ (Big.succ Big.zero)))))))))
                    (Big.succ Big.zero)) rec0) (fun p5 ->
                bind (Obj.magic coq_Conv_monad)
                  (cast_u size8
                    (minus
                      (mult (plus nbytes_minus_one (Big.succ Big.zero))
                        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ Big.zero)))))))))
                      (Big.succ Big.zero)) nb) (fun p6 ->
                  bind (Obj.magic coq_Conv_monad)
                    (load_Z
                      (minus
                        (mult (plus nbytes_minus_one (Big.succ Big.zero))
                          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                          (Big.succ (Big.succ (Big.succ Big.zero)))))))))
                        (Big.succ Big.zero))
                      (Z.mul (Z.of_nat (Big.succ n)) (Big.double (Big.double
                        (Big.double Big.one))))) (fun p7 ->
                    bind (Obj.magic coq_Conv_monad)
                      (arith
                        (minus
                          (mult (plus nbytes_minus_one (Big.succ Big.zero))
                            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                            (Big.succ (Big.succ (Big.succ Big.zero)))))))))
                          (Big.succ Big.zero)) X86_RTL.Coq_shl_op p6 p7)
                      (fun p8 ->
                      arith
                        (minus
                          (mult (plus (Big.succ n) (Big.succ Big.zero))
                            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                            (Big.succ (Big.succ (Big.succ Big.zero)))))))))
                          (Big.succ Big.zero)) X86_RTL.Coq_or_op p5 p8)))))))))
      nbytes_minus_one
  
  (** val load_mem80 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem80 seg addr =
    load_mem_n seg addr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))
  
  (** val load_mem64 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem64 seg addr =
    load_mem_n seg addr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ Big.zero)))))))
  
  (** val load_mem32 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem32 seg addr =
    load_mem_n seg addr (Big.succ (Big.succ (Big.succ Big.zero)))
  
  (** val load_mem16 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem16 seg addr =
    load_mem_n seg addr (Big.succ Big.zero)
  
  (** val load_mem8 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem8 seg addr =
    load_mem_n seg addr Big.zero
  
  (** val opsize : bool -> bool -> Big.big_int **)
  
  let opsize override w =
    if override
    then if w then size16 else size8
    else if w then size32 else size8
  
  (** val load_mem :
      prefix -> bool -> segment_register -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let load_mem p w seg op =
    if p.op_override
    then if w then load_mem16 seg op else load_mem8 seg op
    else if w then load_mem32 seg op else load_mem8 seg op
  
  (** val iload_op32 :
      segment_register -> operand -> X86_RTL.rtl_exp coq_Conv **)
  
  let iload_op32 seg = function
  | Imm_op i ->
    load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero))))))))))))))))))))))))))))))) i
  | Reg_op r2 -> load_reg r2
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (compute_addr a) (fun p1 ->
      load_mem32 seg p1)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) off) (fun p1 ->
      load_mem32 seg p1)
  
  (** val iload_op16 :
      segment_register -> operand -> X86_RTL.rtl_exp coq_Conv **)
  
  let iload_op16 seg = function
  | Imm_op i ->
    bind (Obj.magic coq_Conv_monad)
      (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) i) (fun tmp ->
      cast_u (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) size16 tmp)
  | Reg_op r2 ->
    bind (Obj.magic coq_Conv_monad) (load_reg r2) (fun tmp ->
      cast_u size32 size16 tmp)
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (compute_addr a) (fun p1 ->
      load_mem16 seg p1)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) off) (fun p1 ->
      load_mem16 seg p1)
  
  (** val iload_op8 :
      segment_register -> operand -> X86_RTL.rtl_exp coq_Conv **)
  
  let iload_op8 seg = function
  | Imm_op i ->
    bind (Obj.magic coq_Conv_monad)
      (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) i) (fun tmp ->
      cast_u (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) size8 tmp)
  | Reg_op r2 ->
    bind (Obj.magic coq_Conv_monad)
      (load_reg
        (match r2 with
         | ESP -> EAX
         | EBP -> ECX
         | ESI -> EDX
         | EDI -> EBX
         | x -> x)) (fun tmp ->
      match r2 with
      | EAX -> cast_u size32 size8 tmp
      | ECX -> cast_u size32 size8 tmp
      | EDX -> cast_u size32 size8 tmp
      | EBX -> cast_u size32 size8 tmp
      | _ ->
        bind (Obj.magic coq_Conv_monad)
          (load_Z size32 (Big.double (Big.double (Big.double Big.one))))
          (fun eight ->
          bind (Obj.magic coq_Conv_monad)
            (arith size32 X86_RTL.Coq_shru_op tmp eight) (fun tmp2 ->
            cast_u size32 size8 tmp2)))
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (compute_addr a) (fun p1 ->
      load_mem8 seg p1)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) off) (fun p1 ->
      load_mem8 seg p1)
  
  (** val set_mem_n :
      Big.big_int -> segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      -> unit coq_Conv **)
  
  let rec set_mem_n t0 seg v addr =
    Big.nat_case
      (fun _ ->
      smem seg v addr)
      (fun u ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic
          (cast_u
            (minus
              (mult (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ Big.zero))))))))
                (plus t0 (Big.succ Big.zero))) (Big.succ Big.zero))
            (minus
              (mult (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                (Big.succ (Big.succ (Big.succ Big.zero))))))))
                (plus u (Big.succ Big.zero))) (Big.succ Big.zero)) v))
        (fun p1 ->
        bind (Obj.magic coq_Conv_monad) (set_mem_n u seg p1 addr) (fun x ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic
              (load_Z
                (minus
                  (mult (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ Big.zero))))))))
                    (plus t0 (Big.succ Big.zero))) (Big.succ Big.zero))
                (Z.of_nat
                  (mult (Big.succ u) (Big.succ (Big.succ (Big.succ (Big.succ
                    (Big.succ (Big.succ (Big.succ (Big.succ Big.zero))))))))))))
            (fun p2 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic
                (arith
                  (minus
                    (mult (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                      (Big.succ (Big.succ (Big.succ Big.zero))))))))
                      (plus t0 (Big.succ Big.zero))) (Big.succ Big.zero))
                  X86_RTL.Coq_shru_op v p2)) (fun p3 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic
                  (cast_u
                    (minus
                      (mult (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                        (Big.succ (Big.succ (Big.succ Big.zero))))))))
                        (plus t0 (Big.succ Big.zero))) (Big.succ Big.zero))
                    size8 p3)) (fun p4 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (load_Z size32 (Z.of_nat (Big.succ u))))
                  (fun p5 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic (arith size32 X86_RTL.Coq_add_op p5 addr))
                    (fun p6 -> smem seg p4 p6))))))))
      t0
  
  (** val set_mem80 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem80 seg v a =
    set_mem_n (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ Big.zero))))))))) seg v a
  
  (** val set_mem64 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem64 seg v a =
    set_mem_n (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ Big.zero))))))) seg v a
  
  (** val set_mem32 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem32 seg v a =
    set_mem_n (Big.succ (Big.succ (Big.succ Big.zero))) seg v a
  
  (** val set_mem16 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem16 seg v a =
    set_mem_n (Big.succ Big.zero) seg v a
  
  (** val set_mem8 :
      segment_register -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem8 seg v a =
    set_mem_n Big.zero seg v a
  
  (** val set_mem :
      prefix -> bool -> segment_register -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_mem p w seg =
    if p.op_override
    then if w then set_mem16 seg else set_mem8 seg
    else if w then set_mem32 seg else set_mem8 seg
  
  (** val iset_op80 :
      segment_register -> X86_RTL.rtl_exp -> operand -> unit coq_Conv **)
  
  let iset_op80 seg p = function
  | Imm_op i -> coq_EMIT X86_RTL.Coq_error_rtl
  | Reg_op r2 ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (cast_u size80 size32 p))
      (fun tmp -> set_reg tmp r2)
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a)) (fun addr ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (cast_u size80 size32 p))
        (fun tmp -> set_mem32 seg tmp addr))
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ Big.zero))))))))))))))))))))))))))))))) off))
      (fun addr ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (cast_u size80 size32 p))
        (fun tmp -> set_mem32 seg tmp addr))
  
  (** val iset_op32 :
      segment_register -> X86_RTL.rtl_exp -> operand -> unit coq_Conv **)
  
  let iset_op32 seg p = function
  | Imm_op i -> coq_EMIT X86_RTL.Coq_error_rtl
  | Reg_op r2 -> set_reg p r2
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a)) (fun addr ->
      set_mem32 seg p addr)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ Big.zero))))))))))))))))))))))))))))))) off))
      (fun addr -> set_mem32 seg p addr)
  
  (** val iset_op16 :
      segment_register -> X86_RTL.rtl_exp -> operand -> unit coq_Conv **)
  
  let iset_op16 seg p = function
  | Imm_op i -> coq_EMIT X86_RTL.Coq_error_rtl
  | Reg_op r2 ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_reg r2)) (fun tmp ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic (load_int size32 (Word.mone size32))) (fun mask0 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic
            (load_Z size32 (Big.double (Big.double (Big.double (Big.double
              Big.one)))))) (fun sixteen ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size32 X86_RTL.Coq_shl_op mask0 sixteen))
            (fun mask2 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (arith size32 X86_RTL.Coq_and_op mask2 tmp))
              (fun tmp2 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (cast_u size16 size32 p)) (fun p32 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (arith size32 X86_RTL.Coq_or_op tmp2 p32))
                  (fun tmp3 -> set_reg tmp3 r2)))))))
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a)) (fun addr ->
      set_mem16 seg p addr)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ Big.zero))))))))))))))))))))))))))))))) off))
      (fun addr -> set_mem16 seg p addr)
  
  (** val iset_op8 :
      segment_register -> X86_RTL.rtl_exp -> operand -> unit coq_Conv **)
  
  let iset_op8 seg p = function
  | Imm_op i -> coq_EMIT X86_RTL.Coq_error_rtl
  | Reg_op r2 ->
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_reg
          (match r2 with
           | ESP -> EAX
           | EBP -> ECX
           | ESI -> EDX
           | EDI -> EBX
           | x -> x))) (fun tmp0 ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic
          (load_Z size32
            (match r2 with
             | ESP -> (Big.double (Big.double (Big.double Big.one)))
             | EBP -> (Big.double (Big.double (Big.double Big.one)))
             | ESI -> (Big.double (Big.double (Big.double Big.one)))
             | EDI -> (Big.double (Big.double (Big.double Big.one)))
             | _ -> Big.zero))) (fun shift ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (load_int size32 (Word.mone size32))) (fun mone0 ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic
              (load_Z size32 (Big.doubleplusone (Big.doubleplusone
                (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
                (Big.doubleplusone (Big.doubleplusone Big.one)))))))))
            (fun mask0 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (arith size32 X86_RTL.Coq_shl_op mask0 shift))
              (fun mask1 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (arith size32 X86_RTL.Coq_xor_op mask1 mone0))
                (fun mask2 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (arith size32 X86_RTL.Coq_and_op tmp0 mask2))
                  (fun tmp1 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic (cast_u size8 size32 p)) (fun pext ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic
                        (arith size32 X86_RTL.Coq_shl_op pext shift))
                      (fun pext_shift ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (arith size32 X86_RTL.Coq_or_op tmp1 pext_shift))
                        (fun res ->
                        set_reg res
                          (match r2 with
                           | ESP -> EAX
                           | EBP -> ECX
                           | ESI -> EDX
                           | EDI -> EBX
                           | x -> x)))))))))))
  | Address_op a ->
    bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a)) (fun addr ->
      set_mem8 seg p addr)
  | Offset_op off ->
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ Big.zero))))))))))))))))))))))))))))))) off))
      (fun addr -> set_mem8 seg p addr)
  
  (** val load_op :
      prefix -> bool -> segment_register -> operand -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let load_op p w seg op =
    if p.op_override
    then if w then iload_op16 seg op else iload_op8 seg op
    else if w then iload_op32 seg op else iload_op8 seg op
  
  (** val set_op :
      prefix -> bool -> segment_register -> X86_RTL.rtl_exp -> operand ->
      unit coq_Conv **)
  
  let set_op p w seg =
    if p.op_override
    then if w then iset_op16 seg else iset_op8 seg
    else if w then iset_op32 seg else iset_op8 seg
  
  (** val get_segment : prefix -> segment_register -> segment_register **)
  
  let get_segment p def =
    match p.seg_override with
    | Some s -> s
    | None -> def
  
  (** val op_contains_stack : operand -> bool **)
  
  let op_contains_stack = function
  | Address_op a ->
    (match a.addrBase with
     | Some r2 ->
       (match r2 with
        | ESP -> true
        | EBP -> true
        | _ -> false)
     | None -> false)
  | _ -> false
  
  (** val get_segment_op :
      prefix -> segment_register -> operand -> segment_register **)
  
  let get_segment_op p def op =
    match p.seg_override with
    | Some s -> s
    | None -> if op_contains_stack op then SS else def
  
  (** val get_segment_op2 :
      prefix -> segment_register -> operand -> operand -> segment_register **)
  
  let get_segment_op2 p def op1 op2 =
    match p.seg_override with
    | Some s -> s
    | None ->
      let b = op_contains_stack op1 in
      let b0 = op_contains_stack op2 in
      if b then SS else if b0 then SS else def
  
  (** val compute_cc : condition_type -> X86_RTL.rtl_exp coq_Conv **)
  
  let compute_cc = function
  | O_ct -> get_flag X86_MACHINE.OF
  | NO_ct ->
    bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.OF) (fun p ->
      not size1 p)
  | B_ct -> get_flag X86_MACHINE.CF
  | NB_ct ->
    bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.CF) (fun p ->
      not size1 p)
  | E_ct -> get_flag X86_MACHINE.ZF
  | NE_ct ->
    bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.ZF) (fun p ->
      not size1 p)
  | BE_ct ->
    bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.CF) (fun cf ->
      bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.ZF) (fun zf ->
        arith size1 X86_RTL.Coq_or_op cf zf))
  | NBE_ct ->
    bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.CF) (fun cf ->
      bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.ZF) (fun zf ->
        bind (Obj.magic coq_Conv_monad) (arith size1 X86_RTL.Coq_or_op cf zf)
          (fun p -> not size1 p)))
  | S_ct -> get_flag X86_MACHINE.SF
  | NS_ct ->
    bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.SF) (fun p ->
      not size1 p)
  | P_ct -> get_flag X86_MACHINE.PF
  | NP_ct ->
    bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.PF) (fun p ->
      not size1 p)
  | L_ct ->
    bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.SF) (fun sf ->
      bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.OF) (fun of0 ->
        arith size1 X86_RTL.Coq_xor_op sf of0))
  | NL_ct ->
    bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.SF) (fun sf ->
      bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.OF) (fun of0 ->
        bind (Obj.magic coq_Conv_monad)
          (arith size1 X86_RTL.Coq_xor_op sf of0) (fun p -> not size1 p)))
  | LE_ct ->
    bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.ZF) (fun zf ->
      bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.OF) (fun of0 ->
        bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.SF) (fun sf ->
          bind (Obj.magic coq_Conv_monad)
            (arith size1 X86_RTL.Coq_xor_op of0 sf) (fun p ->
            arith size1 X86_RTL.Coq_or_op zf p))))
  | NLE_ct ->
    bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.ZF) (fun zf ->
      bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.OF) (fun of0 ->
        bind (Obj.magic coq_Conv_monad) (get_flag X86_MACHINE.SF) (fun sf ->
          bind (Obj.magic coq_Conv_monad)
            (arith size1 X86_RTL.Coq_xor_op of0 sf) (fun p0 ->
            bind (Obj.magic coq_Conv_monad)
              (arith size1 X86_RTL.Coq_or_op zf p0) (fun p1 -> not size1 p1)))))
  
  (** val compute_parity_aux :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> Big.big_int ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let rec compute_parity_aux s op1 op2 n =
    Big.nat_case
      (fun _ ->
      load_Z size1 Big.zero)
      (fun m ->
      bind (Obj.magic coq_Conv_monad) (compute_parity_aux s op1 op2 m)
        (fun op3 ->
        bind (Obj.magic coq_Conv_monad) (load_Z s Big.one) (fun one0 ->
          bind (Obj.magic coq_Conv_monad)
            (arith s X86_RTL.Coq_shru_op op1 one0) (fun op4 ->
            bind (Obj.magic coq_Conv_monad) (cast_u s size1 op4) (fun r2 ->
              arith size1 X86_RTL.Coq_xor_op r2 op3)))))
      n
  
  (** val compute_parity :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let compute_parity s op =
    bind (Obj.magic coq_Conv_monad) (load_Z size1 Big.zero) (fun r2 ->
      bind (Obj.magic coq_Conv_monad) (load_Z size1 Big.one) (fun one0 ->
        bind (Obj.magic coq_Conv_monad)
          (compute_parity_aux s op r2 (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))
          (fun p -> arith size1 X86_RTL.Coq_xor_op p one0)))
  
  (** val conv_INC : prefix -> bool -> operand -> unit coq_Conv **)
  
  let conv_INC pre w op =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op pre DS op in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op) (fun p0 ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic (load_Z (opsize pre.op_override w) Big.one)) (fun p1 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic
            (arith (opsize pre.op_override w) X86_RTL.Coq_add_op p0 p1))
          (fun p2 ->
          bind (Obj.magic coq_Conv_monad) (set0 seg p2 op) (fun x ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (load_Z (opsize pre.op_override w) Big.zero))
              (fun zero0 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic
                  (test (opsize pre.op_override w) X86_RTL.Coq_lt_op p2 p0))
                (fun ofp ->
                bind (Obj.magic coq_Conv_monad) (set_flag X86_MACHINE.OF ofp)
                  (fun x0 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic
                      (test (opsize pre.op_override w) X86_RTL.Coq_eq_op p2
                        zero0)) (fun zfp ->
                    bind (Obj.magic coq_Conv_monad)
                      (set_flag X86_MACHINE.ZF zfp) (fun x1 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (test (opsize pre.op_override w) X86_RTL.Coq_lt_op
                            p2 zero0)) (fun sfp ->
                        bind (Obj.magic coq_Conv_monad)
                          (set_flag X86_MACHINE.SF sfp) (fun x2 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (compute_parity (opsize pre.op_override w) p2))
                            (fun pfp ->
                            bind (Obj.magic coq_Conv_monad)
                              (set_flag X86_MACHINE.PF pfp) (fun x3 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_u (opsize pre.op_override w) size4
                                    p0)) (fun n0 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic (load_Z size4 Big.one))
                                  (fun n1 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (arith size4 X86_RTL.Coq_add_op n0 n1))
                                    (fun n2 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (test size4 X86_RTL.Coq_ltu_op n2 n0))
                                      (fun afp ->
                                      set_flag X86_MACHINE.AF afp)))))))))))))))))
  
  (** val conv_DEC : prefix -> bool -> operand -> unit coq_Conv **)
  
  let conv_DEC pre w op =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op pre DS op in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op) (fun p0 ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic (load_Z (opsize pre.op_override w) Big.one)) (fun p1 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic
            (arith (opsize pre.op_override w) X86_RTL.Coq_sub_op p0 p1))
          (fun p2 ->
          bind (Obj.magic coq_Conv_monad) (set0 seg p2 op) (fun x ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (load_Z (opsize pre.op_override w) Big.zero))
              (fun zero0 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic
                  (test (opsize pre.op_override w) X86_RTL.Coq_lt_op p0 p2))
                (fun ofp ->
                bind (Obj.magic coq_Conv_monad) (set_flag X86_MACHINE.OF ofp)
                  (fun x0 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic
                      (test (opsize pre.op_override w) X86_RTL.Coq_eq_op p2
                        zero0)) (fun zfp ->
                    bind (Obj.magic coq_Conv_monad)
                      (set_flag X86_MACHINE.ZF zfp) (fun x1 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (test (opsize pre.op_override w) X86_RTL.Coq_lt_op
                            p2 zero0)) (fun sfp ->
                        bind (Obj.magic coq_Conv_monad)
                          (set_flag X86_MACHINE.SF sfp) (fun x2 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (compute_parity (opsize pre.op_override w) p2))
                            (fun pfp ->
                            bind (Obj.magic coq_Conv_monad)
                              (set_flag X86_MACHINE.PF pfp) (fun x3 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_u (opsize pre.op_override w) size4
                                    p0)) (fun n0 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic (load_Z size4 Big.one))
                                  (fun n1 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (arith size4 X86_RTL.Coq_sub_op n0 n1))
                                    (fun n2 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (test size4 X86_RTL.Coq_ltu_op n0 n2))
                                      (fun afp ->
                                      set_flag X86_MACHINE.AF afp)))))))))))))))))
  
  (** val conv_ADC :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_ADC pre w op1 op2 =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op2 pre DS op1 op2 in
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic (load_Z (opsize pre.op_override w) Big.zero)) (fun zero0 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 Big.one))
        (fun up ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1) (fun p0 ->
          bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op2) (fun p1 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (get_flag X86_MACHINE.CF)) (fun cf1 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (cast_u size1 (opsize pre.op_override w) cf1))
                (fun cfext ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic
                    (arith (opsize pre.op_override w) X86_RTL.Coq_add_op p0
                      p1)) (fun p2 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic
                      (arith (opsize pre.op_override w) X86_RTL.Coq_add_op p2
                        cfext)) (fun p3 ->
                    bind (Obj.magic coq_Conv_monad) (set0 seg p3 op1)
                      (fun x ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (test (opsize pre.op_override w) X86_RTL.Coq_lt_op
                            zero0 p0)) (fun b0 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic
                            (test (opsize pre.op_override w)
                              X86_RTL.Coq_lt_op zero0 p1)) (fun b1 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (test (opsize pre.op_override w)
                                X86_RTL.Coq_lt_op zero0 p3)) (fun b2 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (arith size1 X86_RTL.Coq_xor_op b0 b1))
                              (fun b3 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (arith size1 X86_RTL.Coq_xor_op up b3))
                                (fun b4 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (arith size1 X86_RTL.Coq_xor_op b0 b2))
                                  (fun b5 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (arith size1 X86_RTL.Coq_and_op b4 b5))
                                    (fun b6 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (set_flag X86_MACHINE.OF b6) (fun x0 ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (test (opsize pre.op_override w)
                                            X86_RTL.Coq_ltu_op p3 p0))
                                        (fun b7 ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (test (opsize pre.op_override w)
                                              X86_RTL.Coq_ltu_op p3 p1))
                                          (fun b8 ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (arith size1 X86_RTL.Coq_or_op
                                                b7 b8)) (fun b9 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (set_flag X86_MACHINE.CF b9)
                                              (fun x1 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (test
                                                    (opsize pre.op_override
                                                      w) X86_RTL.Coq_eq_op p3
                                                    zero0)) (fun b10 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (set_flag X86_MACHINE.ZF
                                                    b10) (fun x2 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (test
                                                        (opsize
                                                          pre.op_override w)
                                                        X86_RTL.Coq_lt_op p3
                                                        zero0)) (fun b11 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (set_flag
                                                        X86_MACHINE.SF b11)
                                                      (fun x3 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (compute_parity
                                                            (opsize
                                                              pre.op_override
                                                              w) p3))
                                                        (fun b12 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (set_flag
                                                            X86_MACHINE.PF
                                                            b12) (fun x4 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (cast_u
                                                                (opsize
                                                                  pre.op_override
                                                                  w) size4
                                                                p0))
                                                            (fun n0 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (cast_u
                                                                  (opsize
                                                                    pre.op_override
                                                                    w) size4
                                                                  p1))
                                                              (fun n1 ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (cast_u
                                                                    size1
                                                                    size4
                                                                    cf1))
                                                                (fun cf4 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (Obj.magic
                                                                    (arith
                                                                    size4
                                                                    X86_RTL.Coq_add_op
                                                                    n0 n1))
                                                                  (fun n2 ->
                                                                  bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (arith
                                                                    size4
                                                                    X86_RTL.Coq_add_op
                                                                    n2 cf4))
                                                                    (fun n3 ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (test
                                                                    size4
                                                                    X86_RTL.Coq_ltu_op
                                                                    n3 n0))
                                                                    (fun b13 ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (test
                                                                    size4
                                                                    X86_RTL.Coq_ltu_op
                                                                    n3 n1))
                                                                    (fun b14 ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (arith
                                                                    size1
                                                                    X86_RTL.Coq_or_op
                                                                    b13 b14))
                                                                    (fun b15 ->
                                                                    set_flag
                                                                    X86_MACHINE.AF
                                                                    b15)))))))))))))))))))))))))))))))))))
  
  (** val conv_STC : unit coq_Conv **)
  
  let conv_STC =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 Big.one))
      (fun one0 -> set_flag X86_MACHINE.CF one0)
  
  (** val conv_STD : unit coq_Conv **)
  
  let conv_STD =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 Big.one))
      (fun one0 -> set_flag X86_MACHINE.DF one0)
  
  (** val conv_CLC : unit coq_Conv **)
  
  let conv_CLC =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 Big.zero))
      (fun zero0 -> set_flag X86_MACHINE.CF zero0)
  
  (** val conv_CLD : unit coq_Conv **)
  
  let conv_CLD =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 Big.zero))
      (fun zero0 -> set_flag X86_MACHINE.DF zero0)
  
  (** val conv_CMC : unit coq_Conv **)
  
  let conv_CMC =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 Big.zero))
      (fun zero0 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (get_flag X86_MACHINE.CF))
        (fun p1 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (test size1 X86_RTL.Coq_eq_op zero0 p1)) (fun p0 ->
          set_flag X86_MACHINE.CF p0)))
  
  (** val conv_LAHF : unit coq_Conv **)
  
  let conv_LAHF =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size8 Big.zero))
      (fun dst ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (get_flag X86_MACHINE.SF))
        (fun fl ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic
            (load_Z size8 (Big.doubleplusone (Big.doubleplusone Big.one))))
          (fun pos ->
          bind (Obj.magic coq_Conv_monad) (Obj.magic (cast_u size1 size8 fl))
            (fun byt ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (arith size8 X86_RTL.Coq_shl_op byt pos))
              (fun tmp ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (arith size8 X86_RTL.Coq_or_op dst tmp))
                (fun dst0 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (get_flag X86_MACHINE.ZF)) (fun fl0 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic
                      (load_Z size8 (Big.double (Big.doubleplusone Big.one))))
                    (fun pos0 ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic (cast_u size1 size8 fl0)) (fun byt0 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (arith size8 X86_RTL.Coq_shl_op byt0 pos0))
                        (fun tmp0 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic
                            (arith size8 X86_RTL.Coq_or_op dst0 tmp0))
                          (fun dst1 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (get_flag X86_MACHINE.AF)) (fun fl1 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (load_Z size8 (Big.double (Big.double
                                  Big.one)))) (fun pos2 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic (cast_u size1 size8 fl1))
                                (fun byt1 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (arith size8 X86_RTL.Coq_shl_op byt1
                                      pos2)) (fun tmp1 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (arith size8 X86_RTL.Coq_or_op dst1
                                        tmp1)) (fun dst2 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic (get_flag X86_MACHINE.PF))
                                      (fun fl2 ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (load_Z size8 (Big.double Big.one)))
                                        (fun pos3 ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (cast_u size1 size8 fl2))
                                          (fun byt2 ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (arith size8 X86_RTL.Coq_shl_op
                                                byt2 pos3)) (fun tmp2 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (arith size8
                                                  X86_RTL.Coq_or_op dst2
                                                  tmp2)) (fun dst3 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (get_flag X86_MACHINE.CF))
                                                (fun fl3 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (load_Z size8 Big.zero))
                                                  (fun pos4 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (cast_u size1 size8
                                                        fl3)) (fun byt3 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (arith size8
                                                          X86_RTL.Coq_shl_op
                                                          byt3 pos4))
                                                      (fun tmp3 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (arith size8
                                                            X86_RTL.Coq_or_op
                                                            dst3 tmp3))
                                                        (fun dst4 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (load_Z size8
                                                              Big.one))
                                                          (fun fl4 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (load_Z size8
                                                                Big.one))
                                                            (fun pos5 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (cast_u size8
                                                                  size8 fl4))
                                                              (fun byt4 ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (arith
                                                                    size8
                                                                    X86_RTL.Coq_shl_op
                                                                    byt4
                                                                    pos5))
                                                                (fun tmp4 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (Obj.magic
                                                                    (arith
                                                                    size8
                                                                    X86_RTL.Coq_or_op
                                                                    dst4
                                                                    tmp4))
                                                                  (fun dst5 ->
                                                                  iset_op8 DS
                                                                    dst5
                                                                    (Reg_op
                                                                    ESP))))))))))))))))))))))))))))))))
  
  (** val conv_SAHF : unit coq_Conv **)
  
  let conv_SAHF =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size8 Big.one))
      (fun one0 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (iload_op8 DS (Reg_op ESP)))
        (fun ah ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic
            (load_Z size8 (Big.doubleplusone (Big.doubleplusone Big.one))))
          (fun pos ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size8 X86_RTL.Coq_shr_op ah pos)) (fun tmp ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (arith size8 X86_RTL.Coq_and_op tmp one0))
              (fun tmp0 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (test size8 X86_RTL.Coq_eq_op one0 tmp0))
                (fun b ->
                bind (Obj.magic coq_Conv_monad) (set_flag X86_MACHINE.SF b)
                  (fun x ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic
                      (load_Z size8 (Big.double (Big.doubleplusone Big.one))))
                    (fun pos0 ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic (arith size8 X86_RTL.Coq_shr_op ah pos0))
                      (fun tmp1 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (arith size8 X86_RTL.Coq_and_op tmp1 one0))
                        (fun tmp2 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic
                            (test size8 X86_RTL.Coq_eq_op one0 tmp2))
                          (fun b0 ->
                          bind (Obj.magic coq_Conv_monad)
                            (set_flag X86_MACHINE.ZF b0) (fun x0 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (load_Z size8 (Big.double (Big.double
                                  Big.one)))) (fun pos2 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (arith size8 X86_RTL.Coq_shr_op ah pos2))
                                (fun tmp3 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (arith size8 X86_RTL.Coq_and_op tmp3
                                      one0)) (fun tmp4 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (test size8 X86_RTL.Coq_eq_op one0
                                        tmp4)) (fun b1 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (set_flag X86_MACHINE.AF b1) (fun x1 ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (load_Z size8 (Big.double Big.one)))
                                        (fun pos3 ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (arith size8 X86_RTL.Coq_shr_op
                                              ah pos3)) (fun tmp5 ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (arith size8 X86_RTL.Coq_and_op
                                                tmp5 one0)) (fun tmp6 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (test size8 X86_RTL.Coq_eq_op
                                                  one0 tmp6)) (fun b2 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (set_flag X86_MACHINE.PF b2)
                                                (fun x2 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (load_Z size8 Big.zero))
                                                  (fun pos4 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith size8
                                                        X86_RTL.Coq_shr_op ah
                                                        pos4)) (fun tmp7 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (arith size8
                                                          X86_RTL.Coq_and_op
                                                          tmp7 one0))
                                                      (fun tmp8 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (test size8
                                                            X86_RTL.Coq_eq_op
                                                            one0 tmp8))
                                                        (fun b3 ->
                                                        set_flag
                                                          X86_MACHINE.CF b3))))))))))))))))))))))))))
  
  (** val conv_ADD :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_ADD pre w op1 op2 =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op2 pre DS op1 op2 in
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic (load_Z (opsize pre.op_override w) Big.zero)) (fun zero0 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 Big.one))
        (fun up ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1) (fun p0 ->
          bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op2) (fun p1 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic
                (arith (opsize pre.op_override w) X86_RTL.Coq_add_op p0 p1))
              (fun p2 ->
              bind (Obj.magic coq_Conv_monad) (set0 seg p2 op1) (fun x ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic
                    (test (opsize pre.op_override w) X86_RTL.Coq_lt_op zero0
                      p0)) (fun b0 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic
                      (test (opsize pre.op_override w) X86_RTL.Coq_lt_op
                        zero0 p1)) (fun b1 ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic
                        (test (opsize pre.op_override w) X86_RTL.Coq_lt_op
                          zero0 p2)) (fun b2 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic (arith size1 X86_RTL.Coq_xor_op b0 b1))
                        (fun b3 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic (arith size1 X86_RTL.Coq_xor_op up b3))
                          (fun b4 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (arith size1 X86_RTL.Coq_xor_op b0 b2))
                            (fun b5 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (arith size1 X86_RTL.Coq_and_op b4 b5))
                              (fun b6 ->
                              bind (Obj.magic coq_Conv_monad)
                                (set_flag X86_MACHINE.OF b6) (fun x0 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (test (opsize pre.op_override w)
                                      X86_RTL.Coq_ltu_op p2 p0)) (fun b7 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (test (opsize pre.op_override w)
                                        X86_RTL.Coq_ltu_op p2 p1)) (fun b8 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (arith size1 X86_RTL.Coq_or_op b7 b8))
                                      (fun b9 ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (set_flag X86_MACHINE.CF b9)
                                        (fun x1 ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (test (opsize pre.op_override w)
                                              X86_RTL.Coq_eq_op p2 zero0))
                                          (fun b10 ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (set_flag X86_MACHINE.ZF b10)
                                            (fun x2 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (test
                                                  (opsize pre.op_override w)
                                                  X86_RTL.Coq_lt_op p2 zero0))
                                              (fun b11 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (set_flag X86_MACHINE.SF b11)
                                                (fun x3 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (compute_parity
                                                      (opsize pre.op_override
                                                        w) p2)) (fun b12 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (set_flag X86_MACHINE.PF
                                                      b12) (fun x4 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (cast_u
                                                          (opsize
                                                            pre.op_override
                                                            w) size4 p0))
                                                      (fun n0 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (cast_u
                                                            (opsize
                                                              pre.op_override
                                                              w) size4 p1))
                                                        (fun n1 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (arith size4
                                                              X86_RTL.Coq_add_op
                                                              n0 n1))
                                                          (fun n2 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (test size4
                                                                X86_RTL.Coq_ltu_op
                                                                n2 n0))
                                                            (fun b13 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (test size4
                                                                  X86_RTL.Coq_ltu_op
                                                                  n2 n1))
                                                              (fun b14 ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (arith
                                                                    size1
                                                                    X86_RTL.Coq_or_op
                                                                    b13 b14))
                                                                (fun b15 ->
                                                                set_flag
                                                                  X86_MACHINE.AF
                                                                  b15))))))))))))))))))))))))))))))
  
  (** val conv_SUB_CMP_generic :
      bool -> prefix -> bool -> operand -> operand -> operand ->
      segment_register -> segment_register -> segment_register -> unit
      coq_Conv **)
  
  let conv_SUB_CMP_generic e pre w dest op1 op2 segdest seg1 seg2 =
    let load = load_op pre w in
    let set0 = set_op pre w in
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic (load_Z (opsize pre.op_override w) Big.zero)) (fun zero0 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 Big.one))
        (fun up ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic load seg1 op1) (fun p0 ->
          bind (Obj.magic coq_Conv_monad) (Obj.magic load seg2 op2)
            (fun p1 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic
                (arith (opsize pre.op_override w) X86_RTL.Coq_sub_op p0 p1))
              (fun p2 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic
                  (arith (opsize pre.op_override w) X86_RTL.Coq_sub_op zero0
                    p1)) (fun negp1 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic
                    (test (opsize pre.op_override w) X86_RTL.Coq_lt_op zero0
                      p0)) (fun b0 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic
                      (test (opsize pre.op_override w) X86_RTL.Coq_lt_op
                        zero0 negp1)) (fun b1 ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic
                        (test (opsize pre.op_override w) X86_RTL.Coq_lt_op
                          zero0 p2)) (fun b2 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic (arith size1 X86_RTL.Coq_xor_op b0 b1))
                        (fun b3 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic (arith size1 X86_RTL.Coq_xor_op up b3))
                          (fun b4 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (arith size1 X86_RTL.Coq_xor_op b0 b2))
                            (fun b5 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (arith size1 X86_RTL.Coq_and_op b4 b5))
                              (fun b6 ->
                              bind (Obj.magic coq_Conv_monad)
                                (set_flag X86_MACHINE.OF b6) (fun x ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (test (opsize pre.op_override w)
                                      X86_RTL.Coq_ltu_op p0 p1)) (fun b7 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (set_flag X86_MACHINE.CF b7) (fun x0 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (test (opsize pre.op_override w)
                                          X86_RTL.Coq_eq_op p2 zero0))
                                      (fun b8 ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (set_flag X86_MACHINE.ZF b8)
                                        (fun x1 ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (test (opsize pre.op_override w)
                                              X86_RTL.Coq_lt_op p2 zero0))
                                          (fun b9 ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (set_flag X86_MACHINE.SF b9)
                                            (fun x2 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (compute_parity
                                                  (opsize pre.op_override w)
                                                  p2)) (fun b10 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (set_flag X86_MACHINE.PF b10)
                                                (fun x3 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_u
                                                      (opsize pre.op_override
                                                        w) size4 p0))
                                                  (fun n0 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (cast_u
                                                        (opsize
                                                          pre.op_override w)
                                                        size4 p1)) (fun n1 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (test
                                                          (opsize
                                                            pre.op_override
                                                            w)
                                                          X86_RTL.Coq_ltu_op
                                                          p0 p1)) (fun b11 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (set_flag
                                                          X86_MACHINE.AF b11)
                                                        (fun x4 ->
                                                        if e
                                                        then set0 segdest p2
                                                               dest
                                                        else return
                                                               (Obj.magic
                                                                 coq_Conv_monad)
                                                               ()))))))))))))))))))))))))))
  
  (** val conv_CMP :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_CMP pre w op1 op2 =
    let seg = get_segment_op2 pre DS op1 op2 in
    conv_SUB_CMP_generic false pre w op1 op1 op2 seg seg seg
  
  (** val conv_SUB :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_SUB pre w op1 op2 =
    let seg = get_segment_op2 pre DS op1 op2 in
    conv_SUB_CMP_generic true pre w op1 op1 op2 seg seg seg
  
  (** val conv_NEG : prefix -> bool -> operand -> unit coq_Conv **)
  
  let conv_NEG pre w op1 =
    let seg = get_segment_op pre DS op1 in
    conv_SUB_CMP_generic true pre w op1 (Imm_op
      (Word.zero (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))))) op1 seg seg seg
  
  (** val conv_SBB :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_SBB pre w op1 op2 =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op2 pre DS op1 op2 in
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic (load_Z (opsize pre.op_override w) Big.zero)) (fun zero0 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 Big.one))
        (fun up ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (get_flag X86_MACHINE.CF))
          (fun old_cf ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (cast_u size1 (opsize pre.op_override w) old_cf))
            (fun old_cf_ext ->
            bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1)
              (fun p0 ->
              bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op2)
                (fun p1 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic
                    (arith (opsize pre.op_override w) X86_RTL.Coq_sub_op p0
                      p1)) (fun p2_0 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic
                      (arith (opsize pre.op_override w) X86_RTL.Coq_sub_op
                        p2_0 old_cf_ext)) (fun p2 ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic
                        (arith (opsize pre.op_override w) X86_RTL.Coq_sub_op
                          zero0 p1)) (fun negp1 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (test (opsize pre.op_override w) X86_RTL.Coq_lt_op
                            zero0 p0)) (fun b0 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic
                            (test (opsize pre.op_override w)
                              X86_RTL.Coq_lt_op zero0 negp1)) (fun b1 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (test (opsize pre.op_override w)
                                X86_RTL.Coq_lt_op zero0 p2)) (fun b2 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (arith size1 X86_RTL.Coq_xor_op b0 b1))
                              (fun b3 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (arith size1 X86_RTL.Coq_xor_op up b3))
                                (fun b4 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (arith size1 X86_RTL.Coq_xor_op b0 b2))
                                  (fun b5 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (arith size1 X86_RTL.Coq_and_op b4 b5))
                                    (fun b6 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (set_flag X86_MACHINE.OF b6) (fun x ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (test (opsize pre.op_override w)
                                            X86_RTL.Coq_ltu_op p0 p1))
                                        (fun b0' ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (test (opsize pre.op_override w)
                                              X86_RTL.Coq_eq_op p0 p1))
                                          (fun b0'' ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (arith size1 X86_RTL.Coq_or_op
                                                b0' b0'')) (fun b7 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (set_flag X86_MACHINE.CF b7)
                                              (fun x0 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (test
                                                    (opsize pre.op_override
                                                      w) X86_RTL.Coq_eq_op p2
                                                    zero0)) (fun b8 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (set_flag X86_MACHINE.ZF
                                                    b8) (fun x1 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (test
                                                        (opsize
                                                          pre.op_override w)
                                                        X86_RTL.Coq_lt_op p2
                                                        zero0)) (fun b9 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (set_flag
                                                        X86_MACHINE.SF b9)
                                                      (fun x2 ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (compute_parity
                                                            (opsize
                                                              pre.op_override
                                                              w) p2))
                                                        (fun b10 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (set_flag
                                                            X86_MACHINE.PF
                                                            b10) (fun x3 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (cast_u
                                                                (opsize
                                                                  pre.op_override
                                                                  w) size4
                                                                p0))
                                                            (fun n0 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (cast_u
                                                                  (opsize
                                                                    pre.op_override
                                                                    w) size4
                                                                  p1))
                                                              (fun n1 ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (test
                                                                    (opsize
                                                                    pre.op_override
                                                                    w)
                                                                    X86_RTL.Coq_ltu_op
                                                                    p0 p1))
                                                                (fun b0'0 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (Obj.magic
                                                                    (test
                                                                    (opsize
                                                                    pre.op_override
                                                                    w)
                                                                    X86_RTL.Coq_eq_op
                                                                    p0 p1))
                                                                  (fun b0''0 ->
                                                                  bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (arith
                                                                    size1
                                                                    X86_RTL.Coq_or_op
                                                                    b0'0
                                                                    b0''0))
                                                                    (fun b11 ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (set_flag
                                                                    X86_MACHINE.AF
                                                                    b11)
                                                                    (fun x4 ->
                                                                    set0 seg
                                                                    p2 op1)))))))))))))))))))))))))))))))))
  
  (** val conv_DIV : prefix -> bool -> operand -> unit coq_Conv **)
  
  let conv_DIV pre w op =
    let seg = get_segment_op pre DS op in
    bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.CF) (fun x ->
      bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.OF) (fun x0 ->
        bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.SF)
          (fun x1 ->
          bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.ZF)
            (fun x2 ->
            bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.AF)
              (fun x3 ->
              bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.PF)
                (fun x4 ->
                if pre.op_override
                then if w
                     then bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (iload_op16 seg (Reg_op EAX)))
                            (fun dividend_lower ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (iload_op16 seg (Reg_op EDX)))
                              (fun dividend_upper ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_u size16 size32 dividend_upper))
                                (fun dividend0 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z size32 (Big.double (Big.double
                                      (Big.double (Big.double Big.one))))))
                                  (fun sixteen ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (arith size32 X86_RTL.Coq_shl_op
                                        dividend0 sixteen)) (fun dividend1 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (cast_u size16 size32 dividend_lower))
                                      (fun dividend_lower_ext ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith size32 X86_RTL.Coq_or_op
                                            dividend1 dividend_lower_ext))
                                        (fun dividend ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic (iload_op16 seg op))
                                          (fun divisor ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z size16 Big.zero))
                                            (fun zero0 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (test size16
                                                  X86_RTL.Coq_eq_op zero0
                                                  divisor))
                                              (fun divide_by_zero ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (coq_EMIT (X86_RTL.Coq_if_rtl
                                                  (divide_by_zero,
                                                  X86_RTL.Coq_trap_rtl)))
                                                (fun x5 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_u size16 size32
                                                      divisor))
                                                  (fun divisor_ext ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith size32
                                                        X86_RTL.Coq_divu_op
                                                        dividend divisor_ext))
                                                    (fun quotient ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (load_Z size32
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          Big.one)))))))))))))))))
                                                      (fun max_quotient ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (test size32
                                                            X86_RTL.Coq_ltu_op
                                                            max_quotient
                                                            quotient))
                                                        (fun div_error ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (coq_EMIT
                                                            (X86_RTL.Coq_if_rtl
                                                            (div_error,
                                                            X86_RTL.Coq_trap_rtl)))
                                                          (fun x6 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (arith size32
                                                                X86_RTL.Coq_modu_op
                                                                dividend
                                                                divisor_ext))
                                                            (fun remainder ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (cast_u
                                                                  size32
                                                                  size16
                                                                  quotient))
                                                              (fun quotient_trunc ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (cast_u
                                                                    size32
                                                                    size16
                                                                    remainder))
                                                                (fun remainder_trunc ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (iset_op16
                                                                    seg
                                                                    quotient_trunc
                                                                    (Reg_op
                                                                    EAX))
                                                                  (fun x7 ->
                                                                  iset_op16
                                                                    seg
                                                                    remainder_trunc
                                                                    (Reg_op
                                                                    EDX)))))))))))))))))))))
                     else bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (iload_op16 seg (Reg_op EAX)))
                            (fun dividend ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (iload_op8 seg op)) (fun divisor ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic (load_Z size8 Big.zero))
                                (fun zero0 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (test size8 X86_RTL.Coq_eq_op zero0
                                      divisor)) (fun divide_by_zero ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (coq_EMIT (X86_RTL.Coq_if_rtl
                                      (divide_by_zero,
                                      X86_RTL.Coq_trap_rtl))) (fun x5 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (cast_u size8 size16 divisor))
                                      (fun divisor_ext ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith size16 X86_RTL.Coq_divu_op
                                            dividend divisor_ext))
                                        (fun quotient ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (load_Z size16 (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              Big.one)))))))))
                                          (fun max_quotient ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (test size16 X86_RTL.Coq_ltu_op
                                                max_quotient quotient))
                                            (fun div_error ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (coq_EMIT (X86_RTL.Coq_if_rtl
                                                (div_error,
                                                X86_RTL.Coq_trap_rtl)))
                                              (fun x6 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (arith size16
                                                    X86_RTL.Coq_modu_op
                                                    dividend divisor_ext))
                                                (fun remainder ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_u size16 size8
                                                      quotient))
                                                  (fun quotient_trunc ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (cast_u size16 size8
                                                        remainder))
                                                    (fun remainder_trunc ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (iset_op8 seg
                                                        quotient_trunc
                                                        (Reg_op EAX))
                                                      (fun x7 ->
                                                      iset_op8 seg
                                                        remainder_trunc
                                                        (Reg_op ESP)))))))))))))))
                else if w
                     then bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (iload_op32 seg (Reg_op EAX)))
                            (fun dividend_lower ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (iload_op32 seg (Reg_op EDX)))
                              (fun dividend_upper ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_u size32 (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    dividend_upper)) (fun dividend0 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      (Big.double (Big.double (Big.double
                                      (Big.double (Big.double Big.one)))))))
                                  (fun thirtytwo ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (arith (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                        X86_RTL.Coq_shl_op dividend0
                                        thirtytwo)) (fun dividend1 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (cast_u size32 (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ
                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                          dividend_lower))
                                      (fun dividend_lower_ext ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ
                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                            X86_RTL.Coq_or_op dividend1
                                            dividend_lower_ext))
                                        (fun dividend ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic (iload_op32 seg op))
                                          (fun divisor ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z size32 Big.zero))
                                            (fun zero0 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (test size32
                                                  X86_RTL.Coq_eq_op zero0
                                                  divisor))
                                              (fun divide_by_zero ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (coq_EMIT (X86_RTL.Coq_if_rtl
                                                  (divide_by_zero,
                                                  X86_RTL.Coq_trap_rtl)))
                                                (fun x5 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_u size32 (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                      divisor))
                                                  (fun divisor_ext ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                        X86_RTL.Coq_divu_op
                                                        dividend divisor_ext))
                                                    (fun quotient ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (load_Z (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          Big.one)))))))))))))))))))))))))))))))))
                                                      (fun max_quotient ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (test (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                            X86_RTL.Coq_ltu_op
                                                            max_quotient
                                                            quotient))
                                                        (fun div_error ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (coq_EMIT
                                                            (X86_RTL.Coq_if_rtl
                                                            (div_error,
                                                            X86_RTL.Coq_trap_rtl)))
                                                          (fun x6 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (arith
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                X86_RTL.Coq_modu_op
                                                                dividend
                                                                divisor_ext))
                                                            (fun remainder ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (cast_u
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  (Big.succ
                                                                  Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                  size32
                                                                  quotient))
                                                              (fun quotient_trunc ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (Obj.magic
                                                                  (cast_u
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                    size32
                                                                    remainder))
                                                                (fun remainder_trunc ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (iset_op32
                                                                    seg
                                                                    quotient_trunc
                                                                    (Reg_op
                                                                    EAX))
                                                                  (fun x7 ->
                                                                  iset_op32
                                                                    seg
                                                                    remainder_trunc
                                                                    (Reg_op
                                                                    EDX)))))))))))))))))))))
                     else bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (iload_op16 seg (Reg_op EAX)))
                            (fun dividend ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (iload_op8 seg op)) (fun divisor ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic (load_Z size8 Big.zero))
                                (fun zero0 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (test size8 X86_RTL.Coq_eq_op zero0
                                      divisor)) (fun divide_by_zero ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (coq_EMIT (X86_RTL.Coq_if_rtl
                                      (divide_by_zero,
                                      X86_RTL.Coq_trap_rtl))) (fun x5 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (cast_u size8 size16 divisor))
                                      (fun divisor_ext ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith size16 X86_RTL.Coq_divu_op
                                            dividend divisor_ext))
                                        (fun quotient ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (load_Z size16 (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              Big.one)))))))))
                                          (fun max_quotient ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (test size16 X86_RTL.Coq_ltu_op
                                                max_quotient quotient))
                                            (fun div_error ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (coq_EMIT (X86_RTL.Coq_if_rtl
                                                (div_error,
                                                X86_RTL.Coq_trap_rtl)))
                                              (fun x6 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (arith size16
                                                    X86_RTL.Coq_modu_op
                                                    dividend divisor_ext))
                                                (fun remainder ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_u size16 size8
                                                      quotient))
                                                  (fun quotient_trunc ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (cast_u size16 size8
                                                        remainder))
                                                    (fun remainder_trunc ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (iset_op8 seg
                                                        quotient_trunc
                                                        (Reg_op EAX))
                                                      (fun x7 ->
                                                      iset_op8 seg
                                                        remainder_trunc
                                                        (Reg_op ESP)))))))))))))))))))))
  
  (** val conv_IDIV : prefix -> bool -> operand -> unit coq_Conv **)
  
  let conv_IDIV pre w op =
    let seg = get_segment_op pre DS op in
    bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.CF) (fun x ->
      bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.OF) (fun x0 ->
        bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.SF)
          (fun x1 ->
          bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.ZF)
            (fun x2 ->
            bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.AF)
              (fun x3 ->
              bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.PF)
                (fun x4 ->
                if pre.op_override
                then if w
                     then bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (iload_op16 seg (Reg_op EAX)))
                            (fun dividend_lower ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (iload_op16 seg (Reg_op EDX)))
                              (fun dividend_upper ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_s size16 size32 dividend_upper))
                                (fun dividend0 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z size32 (Big.double (Big.double
                                      (Big.double (Big.double Big.one))))))
                                  (fun sixteen ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (arith size32 X86_RTL.Coq_shl_op
                                        dividend0 sixteen)) (fun dividend1 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (cast_s size16 size32 dividend_lower))
                                      (fun dividend_lower_ext ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith size32 X86_RTL.Coq_or_op
                                            dividend1 dividend_lower_ext))
                                        (fun dividend ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic (iload_op16 seg op))
                                          (fun divisor ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z size16 Big.zero))
                                            (fun zero0 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (test size16
                                                  X86_RTL.Coq_eq_op zero0
                                                  divisor))
                                              (fun divide_by_zero ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (coq_EMIT (X86_RTL.Coq_if_rtl
                                                  (divide_by_zero,
                                                  X86_RTL.Coq_trap_rtl)))
                                                (fun x5 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_s size16 size32
                                                      divisor))
                                                  (fun divisor_ext ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith size32
                                                        X86_RTL.Coq_divs_op
                                                        dividend divisor_ext))
                                                    (fun quotient ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (load_Z size32
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          Big.one))))))))))))))))
                                                      (fun max_quotient ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (load_Z size32
                                                            (Big.opp
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            Big.one))))))))))))))))))
                                                        (fun min_quotient ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (test size32
                                                              X86_RTL.Coq_lt_op
                                                              max_quotient
                                                              quotient))
                                                          (fun div_error0 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (test size32
                                                                X86_RTL.Coq_lt_op
                                                                quotient
                                                                min_quotient))
                                                            (fun div_error1 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (arith size1
                                                                  X86_RTL.Coq_or_op
                                                                  div_error0
                                                                  div_error1))
                                                              (fun div_error ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (coq_EMIT
                                                                  (X86_RTL.Coq_if_rtl
                                                                  (div_error,
                                                                  X86_RTL.Coq_trap_rtl)))
                                                                (fun x6 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (Obj.magic
                                                                    (arith
                                                                    size32
                                                                    X86_RTL.Coq_mods_op
                                                                    dividend
                                                                    divisor_ext))
                                                                  (fun remainder ->
                                                                  bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (cast_s
                                                                    size32
                                                                    size16
                                                                    quotient))
                                                                    (fun quotient_trunc ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (cast_s
                                                                    size32
                                                                    size16
                                                                    remainder))
                                                                    (fun remainder_trunc ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (iset_op16
                                                                    seg
                                                                    quotient_trunc
                                                                    (Reg_op
                                                                    EAX))
                                                                    (fun x7 ->
                                                                    iset_op16
                                                                    seg
                                                                    remainder_trunc
                                                                    (Reg_op
                                                                    EDX))))))))))))))))))))))))
                     else bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (iload_op16 seg (Reg_op EAX)))
                            (fun dividend ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (iload_op8 seg op)) (fun divisor ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic (load_Z size8 Big.zero))
                                (fun zero0 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (test size8 X86_RTL.Coq_eq_op zero0
                                      divisor)) (fun divide_by_zero ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (coq_EMIT (X86_RTL.Coq_if_rtl
                                      (divide_by_zero,
                                      X86_RTL.Coq_trap_rtl))) (fun x5 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (cast_s size8 size16 divisor))
                                      (fun divisor_ext ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith size16 X86_RTL.Coq_divs_op
                                            dividend divisor_ext))
                                        (fun quotient ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (load_Z size16 (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              Big.one))))))))
                                          (fun max_quotient ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z size16 (Big.opp
                                                (Big.double (Big.double
                                                (Big.double (Big.double
                                                (Big.double (Big.double
                                                (Big.double Big.one))))))))))
                                            (fun min_quotient ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (test size16
                                                  X86_RTL.Coq_lt_op
                                                  max_quotient quotient))
                                              (fun div_error0 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (test size16
                                                    X86_RTL.Coq_lt_op
                                                    quotient min_quotient))
                                                (fun div_error1 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (arith size1
                                                      X86_RTL.Coq_or_op
                                                      div_error0 div_error1))
                                                  (fun div_error ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (coq_EMIT
                                                      (X86_RTL.Coq_if_rtl
                                                      (div_error,
                                                      X86_RTL.Coq_trap_rtl)))
                                                    (fun x6 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (arith size16
                                                          X86_RTL.Coq_mods_op
                                                          dividend
                                                          divisor_ext))
                                                      (fun remainder ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (cast_s size16
                                                            size8 quotient))
                                                        (fun quotient_trunc ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (cast_s size16
                                                              size8
                                                              remainder))
                                                          (fun remainder_trunc ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (iset_op8 seg
                                                              quotient_trunc
                                                              (Reg_op EAX))
                                                            (fun x7 ->
                                                            iset_op8 seg
                                                              remainder_trunc
                                                              (Reg_op ESP))))))))))))))))))
                else if w
                     then bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (iload_op32 seg (Reg_op EAX)))
                            (fun dividend_lower ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (iload_op32 seg (Reg_op EDX)))
                              (fun dividend_upper ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_s size32 (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    dividend_upper)) (fun dividend0 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      (Big.double (Big.double (Big.double
                                      (Big.double (Big.double Big.one)))))))
                                  (fun thirtytwo ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (arith (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                        X86_RTL.Coq_shl_op dividend0
                                        thirtytwo)) (fun dividend1 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (cast_s size32 (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ
                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                          dividend_lower))
                                      (fun dividend_lower_ext ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ
                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                            X86_RTL.Coq_or_op dividend1
                                            dividend_lower_ext))
                                        (fun dividend ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic (iload_op32 seg op))
                                          (fun divisor ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z size32 Big.zero))
                                            (fun zero0 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (test size32
                                                  X86_RTL.Coq_eq_op zero0
                                                  divisor))
                                              (fun divide_by_zero ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (coq_EMIT (X86_RTL.Coq_if_rtl
                                                  (divide_by_zero,
                                                  X86_RTL.Coq_trap_rtl)))
                                                (fun x5 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (cast_s size32 (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      (Big.succ (Big.succ
                                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                      divisor))
                                                  (fun divisor_ext ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        (Big.succ (Big.succ
                                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                        X86_RTL.Coq_divs_op
                                                        dividend divisor_ext))
                                                    (fun quotient ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (load_Z (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          (Big.succ (Big.succ
                                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          (Big.doubleplusone
                                                          Big.one))))))))))))))))))))))))))))))))
                                                      (fun max_quotient ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (load_Z (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            (Big.succ
                                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                            (Big.opp
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            (Big.double
                                                            Big.one))))))))))))))))))))))))))))))))))
                                                        (fun min_quotient ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (test (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              (Big.succ
                                                              Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                              X86_RTL.Coq_lt_op
                                                              max_quotient
                                                              quotient))
                                                          (fun div_error0 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (Obj.magic
                                                              (test (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                (Big.succ
                                                                Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                X86_RTL.Coq_lt_op
                                                                quotient
                                                                min_quotient))
                                                            (fun div_error1 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (arith size1
                                                                  X86_RTL.Coq_or_op
                                                                  div_error0
                                                                  div_error1))
                                                              (fun div_error ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (coq_EMIT
                                                                  (X86_RTL.Coq_if_rtl
                                                                  (div_error,
                                                                  X86_RTL.Coq_trap_rtl)))
                                                                (fun x6 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (Obj.magic
                                                                    (arith
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                    X86_RTL.Coq_mods_op
                                                                    dividend
                                                                    divisor_ext))
                                                                  (fun remainder ->
                                                                  bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (cast_s
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                    size32
                                                                    quotient))
                                                                    (fun quotient_trunc ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (Obj.magic
                                                                    (cast_s
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    (Big.succ
                                                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                                                    size32
                                                                    remainder))
                                                                    (fun remainder_trunc ->
                                                                    bind
                                                                    (Obj.magic
                                                                    coq_Conv_monad)
                                                                    (iset_op32
                                                                    seg
                                                                    quotient_trunc
                                                                    (Reg_op
                                                                    EAX))
                                                                    (fun x7 ->
                                                                    iset_op32
                                                                    seg
                                                                    remainder_trunc
                                                                    (Reg_op
                                                                    EDX))))))))))))))))))))))))
                     else bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (iload_op16 seg (Reg_op EAX)))
                            (fun dividend ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (iload_op8 seg op)) (fun divisor ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic (load_Z size8 Big.zero))
                                (fun zero0 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (test size8 X86_RTL.Coq_eq_op zero0
                                      divisor)) (fun divide_by_zero ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (coq_EMIT (X86_RTL.Coq_if_rtl
                                      (divide_by_zero,
                                      X86_RTL.Coq_trap_rtl))) (fun x5 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (cast_s size8 size16 divisor))
                                      (fun divisor_ext ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith size16 X86_RTL.Coq_divs_op
                                            dividend divisor_ext))
                                        (fun quotient ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (load_Z size16 (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              (Big.doubleplusone
                                              Big.one))))))))
                                          (fun max_quotient ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (load_Z size16 (Big.opp
                                                (Big.double (Big.double
                                                (Big.double (Big.double
                                                (Big.double (Big.double
                                                (Big.double Big.one))))))))))
                                            (fun min_quotient ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (test size16
                                                  X86_RTL.Coq_lt_op
                                                  max_quotient quotient))
                                              (fun div_error0 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (test size16
                                                    X86_RTL.Coq_lt_op
                                                    quotient min_quotient))
                                                (fun div_error1 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (arith size1
                                                      X86_RTL.Coq_or_op
                                                      div_error0 div_error1))
                                                  (fun div_error ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (coq_EMIT
                                                      (X86_RTL.Coq_if_rtl
                                                      (div_error,
                                                      X86_RTL.Coq_trap_rtl)))
                                                    (fun x6 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (arith size16
                                                          X86_RTL.Coq_mods_op
                                                          dividend
                                                          divisor_ext))
                                                      (fun remainder ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic
                                                          (cast_s size16
                                                            size8 quotient))
                                                        (fun quotient_trunc ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (cast_s size16
                                                              size8
                                                              remainder))
                                                          (fun remainder_trunc ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (iset_op8 seg
                                                              quotient_trunc
                                                              (Reg_op EAX))
                                                            (fun x7 ->
                                                            iset_op8 seg
                                                              remainder_trunc
                                                              (Reg_op ESP))))))))))))))))))))))))
  
  (** val conv_IMUL :
      prefix -> bool -> operand -> operand option -> int32 option -> unit
      coq_Conv **)
  
  let conv_IMUL pre w op1 opopt2 iopt =
    bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.SF) (fun x ->
      bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.ZF) (fun x0 ->
        bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.AF)
          (fun x1 ->
          bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.PF)
            (fun x2 ->
            match opopt2 with
            | Some op2 ->
              (match iopt with
               | Some imm3 ->
                 let load = load_op pre w in
                 let set0 = set_op pre w in
                 let seg = get_segment_op2 pre DS op1 op2 in
                 bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op2)
                   (fun p1 ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic
                       (load_int (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ
                         Big.zero))))))))))))))))))))))))))))))) imm3))
                     (fun p2 ->
                     bind (Obj.magic coq_Conv_monad)
                       (Obj.magic
                         (cast_s (opsize pre.op_override w)
                           (minus
                             (mult (Big.succ (Big.succ Big.zero))
                               (plus (opsize pre.op_override w) (Big.succ
                                 Big.zero))) (Big.succ Big.zero)) p1))
                       (fun p1ext ->
                       bind (Obj.magic coq_Conv_monad)
                         (Obj.magic
                           (cast_s (Big.succ (Big.succ (Big.succ (Big.succ
                             (Big.succ (Big.succ (Big.succ (Big.succ
                             (Big.succ (Big.succ (Big.succ (Big.succ
                             (Big.succ (Big.succ (Big.succ (Big.succ
                             (Big.succ (Big.succ (Big.succ (Big.succ
                             (Big.succ (Big.succ (Big.succ (Big.succ
                             (Big.succ (Big.succ (Big.succ (Big.succ
                             (Big.succ (Big.succ (Big.succ
                             Big.zero)))))))))))))))))))))))))))))))
                             (minus
                               (mult (Big.succ (Big.succ Big.zero))
                                 (plus (opsize pre.op_override w) (Big.succ
                                   Big.zero))) (Big.succ Big.zero)) p2))
                         (fun p2ext ->
                         bind (Obj.magic coq_Conv_monad)
                           (Obj.magic
                             (arith
                               (minus
                                 (mult (Big.succ (Big.succ Big.zero))
                                   (plus (opsize pre.op_override w) (Big.succ
                                     Big.zero))) (Big.succ Big.zero))
                               X86_RTL.Coq_mul_op p1ext p2ext)) (fun res ->
                           bind (Obj.magic coq_Conv_monad)
                             (Obj.magic
                               (cast_s
                                 (minus
                                   (mult (Big.succ (Big.succ Big.zero))
                                     (plus (opsize pre.op_override w)
                                       (Big.succ Big.zero))) (Big.succ
                                   Big.zero)) (opsize pre.op_override w) res))
                             (fun lowerhalf ->
                             bind (Obj.magic coq_Conv_monad)
                               (Obj.magic
                                 (cast_s (opsize pre.op_override w)
                                   (minus
                                     (mult (Big.succ (Big.succ Big.zero))
                                       (plus (opsize pre.op_override w)
                                         (Big.succ Big.zero))) (Big.succ
                                     Big.zero)) lowerhalf)) (fun reextend ->
                               bind (Obj.magic coq_Conv_monad)
                                 (Obj.magic
                                   (test
                                     (minus
                                       (mult (Big.succ (Big.succ Big.zero))
                                         (plus (opsize pre.op_override w)
                                           (Big.succ Big.zero))) (Big.succ
                                       Big.zero)) X86_RTL.Coq_eq_op reextend
                                     res)) (fun b0 ->
                                 bind (Obj.magic coq_Conv_monad)
                                   (Obj.magic (not size1 b0)) (fun flag0 ->
                                   bind (Obj.magic coq_Conv_monad)
                                     (set_flag X86_MACHINE.CF flag0)
                                     (fun x3 ->
                                     bind (Obj.magic coq_Conv_monad)
                                       (set_flag X86_MACHINE.OF flag0)
                                       (fun x4 -> set0 seg lowerhalf op1)))))))))))
               | None ->
                 let load = load_op pre w in
                 let set0 = set_op pre w in
                 let seg = get_segment_op2 pre DS op1 op2 in
                 bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1)
                   (fun p1 ->
                   bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op2)
                     (fun p2 ->
                     bind (Obj.magic coq_Conv_monad)
                       (Obj.magic
                         (cast_s (opsize pre.op_override w)
                           (minus
                             (mult (Big.succ (Big.succ Big.zero))
                               (plus (opsize pre.op_override w) (Big.succ
                                 Big.zero))) (Big.succ Big.zero)) p1))
                       (fun p1ext ->
                       bind (Obj.magic coq_Conv_monad)
                         (Obj.magic
                           (cast_s (opsize pre.op_override w)
                             (minus
                               (mult (Big.succ (Big.succ Big.zero))
                                 (plus (opsize pre.op_override w) (Big.succ
                                   Big.zero))) (Big.succ Big.zero)) p2))
                         (fun p2ext ->
                         bind (Obj.magic coq_Conv_monad)
                           (Obj.magic
                             (arith
                               (minus
                                 (mult (Big.succ (Big.succ Big.zero))
                                   (plus (opsize pre.op_override w) (Big.succ
                                     Big.zero))) (Big.succ Big.zero))
                               X86_RTL.Coq_mul_op p1ext p2ext)) (fun res ->
                           bind (Obj.magic coq_Conv_monad)
                             (Obj.magic
                               (cast_s
                                 (minus
                                   (mult (Big.succ (Big.succ Big.zero))
                                     (plus (opsize pre.op_override w)
                                       (Big.succ Big.zero))) (Big.succ
                                   Big.zero)) (opsize pre.op_override w) res))
                             (fun lowerhalf ->
                             bind (Obj.magic coq_Conv_monad)
                               (Obj.magic
                                 (cast_s (opsize pre.op_override w)
                                   (minus
                                     (mult (Big.succ (Big.succ Big.zero))
                                       (plus (opsize pre.op_override w)
                                         (Big.succ Big.zero))) (Big.succ
                                     Big.zero)) lowerhalf)) (fun reextend ->
                               bind (Obj.magic coq_Conv_monad)
                                 (Obj.magic
                                   (test
                                     (minus
                                       (mult (Big.succ (Big.succ Big.zero))
                                         (plus (opsize pre.op_override w)
                                           (Big.succ Big.zero))) (Big.succ
                                       Big.zero)) X86_RTL.Coq_eq_op reextend
                                     res)) (fun b0 ->
                                 bind (Obj.magic coq_Conv_monad)
                                   (Obj.magic (not size1 b0)) (fun flag0 ->
                                   bind (Obj.magic coq_Conv_monad)
                                     (set_flag X86_MACHINE.CF flag0)
                                     (fun x3 ->
                                     bind (Obj.magic coq_Conv_monad)
                                       (set_flag X86_MACHINE.OF flag0)
                                       (fun x4 -> set0 seg lowerhalf op1))))))))))))
            | None ->
              let load = load_op pre w in
              let seg = get_segment_op pre DS op1 in
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic load seg (Reg_op EAX)) (fun p1 ->
                bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1)
                  (fun p2 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic
                      (cast_s (opsize pre.op_override w)
                        (minus
                          (mult (Big.succ (Big.succ Big.zero))
                            (plus (opsize pre.op_override w) (Big.succ
                              Big.zero))) (Big.succ Big.zero)) p1))
                    (fun p1ext ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic
                        (cast_s (opsize pre.op_override w)
                          (minus
                            (mult (Big.succ (Big.succ Big.zero))
                              (plus (opsize pre.op_override w) (Big.succ
                                Big.zero))) (Big.succ Big.zero)) p2))
                      (fun p2ext ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (arith
                            (minus
                              (mult (Big.succ (Big.succ Big.zero))
                                (plus (opsize pre.op_override w) (Big.succ
                                  Big.zero))) (Big.succ Big.zero))
                            X86_RTL.Coq_mul_op p1ext p2ext)) (fun res ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic
                            (cast_s
                              (minus
                                (mult (Big.succ (Big.succ Big.zero))
                                  (plus (opsize pre.op_override w) (Big.succ
                                    Big.zero))) (Big.succ Big.zero))
                              (opsize pre.op_override w) res))
                          (fun lowerhalf ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (load_Z
                                (minus
                                  (mult (Big.succ (Big.succ Big.zero))
                                    (plus (opsize pre.op_override w)
                                      (Big.succ Big.zero))) (Big.succ
                                  Big.zero))
                                (Z.of_nat
                                  (plus (opsize pre.op_override w) (Big.succ
                                    Big.zero))))) (fun shift ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  (minus
                                    (mult (Big.succ (Big.succ Big.zero))
                                      (plus (opsize pre.op_override w)
                                        (Big.succ Big.zero))) (Big.succ
                                    Big.zero)) X86_RTL.Coq_shr_op res shift))
                              (fun res_shifted ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_s
                                    (minus
                                      (mult (Big.succ (Big.succ Big.zero))
                                        (plus (opsize pre.op_override w)
                                          (Big.succ Big.zero))) (Big.succ
                                      Big.zero)) (opsize pre.op_override w)
                                    res_shifted)) (fun upperhalf ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (load_Z (opsize pre.op_override w)
                                      Big.zero)) (fun zero0 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (load_Z (opsize pre.op_override w)
                                        (Word.max_unsigned
                                          (opsize pre.op_override w))))
                                    (fun max0 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (test (opsize pre.op_override w)
                                          X86_RTL.Coq_eq_op upperhalf zero0))
                                      (fun b0 ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (test (opsize pre.op_override w)
                                            X86_RTL.Coq_eq_op upperhalf max0))
                                        (fun b1 ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (arith size1 X86_RTL.Coq_or_op b0
                                              b1)) (fun b2 ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic (not size1 b2))
                                            (fun flag0 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (set_flag X86_MACHINE.CF flag0)
                                              (fun x3 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (set_flag X86_MACHINE.OF
                                                  flag0) (fun x4 ->
                                                if w
                                                then let set0 = set_op pre w
                                                     in
                                                     bind
                                                       (Obj.magic
                                                         coq_Conv_monad)
                                                       (set0 seg lowerhalf
                                                         (Reg_op EAX))
                                                       (fun x5 ->
                                                       set0 seg upperhalf
                                                         (Reg_op EDX))
                                                else iset_op16 seg res
                                                       (Reg_op EAX))))))))))))))))))))))
  
  (** val conv_MUL : prefix -> bool -> operand -> unit coq_Conv **)
  
  let conv_MUL pre w op =
    let seg = get_segment_op pre DS op in
    bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.SF) (fun x ->
      bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.ZF) (fun x0 ->
        bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.AF)
          (fun x1 ->
          bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.PF)
            (fun x2 ->
            if pre.op_override
            then if w
                 then bind (Obj.magic coq_Conv_monad)
                        (Obj.magic (iload_op16 seg op)) (fun p1 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic (iload_op16 seg (Reg_op EAX)))
                          (fun p2 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (cast_u size16 size32 p1))
                            (fun p1ext ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (cast_u size16 size32 p2))
                              (fun p2ext ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (arith size32 X86_RTL.Coq_mul_op p1ext
                                    p2ext)) (fun res ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic (cast_u size32 size16 res))
                                  (fun res_lower ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (load_Z size32 (Big.double (Big.double
                                        (Big.double (Big.double Big.one))))))
                                    (fun sixteen ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (arith size32 X86_RTL.Coq_shru_op res
                                          sixteen)) (fun res_shifted ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (cast_u size32 size16 res_shifted))
                                        (fun res_upper ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (iset_op16 seg res_lower (Reg_op
                                            EAX)) (fun x3 ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (iset_op16 seg res_upper (Reg_op
                                              EDX)) (fun x4 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (load_Z size16 Big.zero))
                                              (fun zero0 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (test size16
                                                    X86_RTL.Coq_ltu_op zero0
                                                    res_upper))
                                                (fun cf_test ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (set_flag X86_MACHINE.CF
                                                    cf_test) (fun x5 ->
                                                  set_flag X86_MACHINE.OF
                                                    cf_test))))))))))))))
                 else bind (Obj.magic coq_Conv_monad)
                        (Obj.magic (iload_op8 seg op)) (fun p1 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic (iload_op8 seg (Reg_op EAX))) (fun p2 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (cast_u size8 size16 p1))
                            (fun p1ext ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (cast_u size8 size16 p2))
                              (fun p2ext ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (arith size16 X86_RTL.Coq_mul_op p1ext
                                    p2ext)) (fun res ->
                                bind (Obj.magic coq_Conv_monad)
                                  (iset_op16 seg res (Reg_op EAX)) (fun x3 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (load_Z size16 (Big.doubleplusone
                                        (Big.doubleplusone (Big.doubleplusone
                                        (Big.doubleplusone (Big.doubleplusone
                                        (Big.doubleplusone (Big.doubleplusone
                                        Big.one))))))))) (fun max0 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (test size16 X86_RTL.Coq_ltu_op max0
                                          res)) (fun cf_test ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (set_flag X86_MACHINE.CF cf_test)
                                        (fun x4 ->
                                        set_flag X86_MACHINE.OF cf_test)))))))))
            else if w
                 then bind (Obj.magic coq_Conv_monad)
                        (Obj.magic (iload_op32 seg op)) (fun p1 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic (iload_op32 seg (Reg_op EAX)))
                          (fun p2 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (cast_u size32 (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                p1)) (fun p1ext ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (cast_u size32 (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                  p2)) (fun p2ext ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (arith (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    X86_RTL.Coq_mul_op p1ext p2ext))
                                (fun res ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (cast_u (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      size32 res)) (fun res_lower ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (load_Z (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                        (Big.double (Big.double (Big.double
                                        (Big.double (Big.double Big.one)))))))
                                    (fun thirtytwo ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (arith (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                          X86_RTL.Coq_shru_op res thirtytwo))
                                      (fun res_shifted ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (cast_u (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ
                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                            size32 res_shifted))
                                        (fun res_upper ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (iset_op32 seg res_lower (Reg_op
                                            EAX)) (fun x3 ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (iset_op32 seg res_upper (Reg_op
                                              EDX)) (fun x4 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (load_Z size32 Big.zero))
                                              (fun zero0 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (test size32
                                                    X86_RTL.Coq_ltu_op zero0
                                                    res_upper))
                                                (fun cf_test ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (set_flag X86_MACHINE.CF
                                                    cf_test) (fun x5 ->
                                                  set_flag X86_MACHINE.OF
                                                    cf_test))))))))))))))
                 else bind (Obj.magic coq_Conv_monad)
                        (Obj.magic (iload_op8 seg op)) (fun p1 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic (iload_op8 seg (Reg_op EAX))) (fun p2 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (cast_u size8 size16 p1))
                            (fun p1ext ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (cast_u size8 size16 p2))
                              (fun p2ext ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (arith size16 X86_RTL.Coq_mul_op p1ext
                                    p2ext)) (fun res ->
                                bind (Obj.magic coq_Conv_monad)
                                  (iset_op16 seg res (Reg_op EAX)) (fun x3 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (load_Z size16 (Big.doubleplusone
                                        (Big.doubleplusone (Big.doubleplusone
                                        (Big.doubleplusone (Big.doubleplusone
                                        (Big.doubleplusone (Big.doubleplusone
                                        Big.one))))))))) (fun max0 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (test size16 X86_RTL.Coq_ltu_op max0
                                          res)) (fun cf_test ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (set_flag X86_MACHINE.CF cf_test)
                                        (fun x4 ->
                                        set_flag X86_MACHINE.OF cf_test)))))))))))))
  
  (** val conv_shift :
      X86_RTL.bit_vector_op -> prefix -> bool -> operand -> reg_or_immed ->
      unit coq_Conv **)
  
  let conv_shift shift pre w op1 op2 =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op pre DS op1 in
    bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.OF) (fun x ->
      bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.CF) (fun x0 ->
        bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.SF)
          (fun x1 ->
          bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.ZF)
            (fun x2 ->
            bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.PF)
              (fun x3 ->
              bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.AF)
                (fun x4 ->
                bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1)
                  (fun p1 ->
                  bind (Obj.magic coq_Conv_monad)
                    (match op2 with
                     | Reg_ri r2 -> Obj.magic (iload_op8 seg (Reg_op r2))
                     | Imm_ri i ->
                       Obj.magic
                         (load_int (Big.succ (Big.succ (Big.succ (Big.succ
                           (Big.succ (Big.succ (Big.succ Big.zero))))))) i))
                    (fun p2 ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic
                        (load_Z size8 (Big.doubleplusone (Big.doubleplusone
                          (Big.doubleplusone (Big.doubleplusone Big.one))))))
                      (fun mask0 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic (arith size8 X86_RTL.Coq_and_op p2 mask0))
                        (fun p3 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic
                            (cast_u size8 (opsize pre.op_override w) p3))
                          (fun p2cast ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (arith (opsize pre.op_override w) shift p1
                                p2cast)) (fun p4 -> set0 seg p4 op1))))))))))))
  
  (** val conv_SHL :
      prefix -> bool -> operand -> reg_or_immed -> unit coq_Conv **)
  
  let conv_SHL pre w op1 op2 =
    conv_shift X86_RTL.Coq_shl_op pre w op1 op2
  
  (** val conv_SAR :
      prefix -> bool -> operand -> reg_or_immed -> unit coq_Conv **)
  
  let conv_SAR pre w op1 op2 =
    conv_shift X86_RTL.Coq_shr_op pre w op1 op2
  
  (** val conv_SHR :
      prefix -> bool -> operand -> reg_or_immed -> unit coq_Conv **)
  
  let conv_SHR pre w op1 op2 =
    conv_shift X86_RTL.Coq_shru_op pre w op1 op2
  
  (** val conv_ROR :
      prefix -> bool -> operand -> reg_or_immed -> unit coq_Conv **)
  
  let conv_ROR pre w op1 op2 =
    conv_shift X86_RTL.Coq_ror_op pre w op1 op2
  
  (** val conv_ROL :
      prefix -> bool -> operand -> reg_or_immed -> unit coq_Conv **)
  
  let conv_ROL pre w op1 op2 =
    conv_shift X86_RTL.Coq_rol_op pre w op1 op2
  
  (** val conv_RCL :
      prefix -> bool -> operand -> reg_or_immed -> unit coq_Conv **)
  
  let conv_RCL pre w op1 op2 =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op pre DS op1 in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1) (fun p1 ->
      bind (Obj.magic coq_Conv_monad)
        (match op2 with
         | Reg_ri r2 -> Obj.magic (iload_op8 seg (Reg_op r2))
         | Imm_ri i ->
           Obj.magic
             (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ Big.zero))))))) i)) (fun p2 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic
            (load_Z size8 (Big.doubleplusone (Big.doubleplusone
              (Big.doubleplusone (Big.doubleplusone Big.one))))))
          (fun mask0 ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size8 X86_RTL.Coq_and_op p2 mask0)) (fun p3 ->
            bind (Obj.magic coq_Conv_monad)
              (Big.nat_case
                 (fun _ ->
                 return (Obj.magic coq_Conv_monad) ())
                 (fun n ->
                 Big.nat_case
                   (fun _ ->
                   return (Obj.magic coq_Conv_monad) ())
                   (fun n0 ->
                   Big.nat_case
                     (fun _ ->
                     return (Obj.magic coq_Conv_monad) ())
                     (fun n1 ->
                     Big.nat_case
                       (fun _ ->
                       return (Obj.magic coq_Conv_monad) ())
                       (fun n2 ->
                       Big.nat_case
                         (fun _ ->
                         return (Obj.magic coq_Conv_monad) ())
                         (fun n3 ->
                         Big.nat_case
                           (fun _ ->
                           return (Obj.magic coq_Conv_monad) ())
                           (fun n4 ->
                           Big.nat_case
                             (fun _ ->
                             return (Obj.magic coq_Conv_monad) ())
                             (fun n5 ->
                             Big.nat_case
                               (fun _ ->
                               bind (Obj.magic coq_Conv_monad)
                                 (Obj.magic
                                   (load_Z size8 (Big.doubleplusone
                                     (Big.double (Big.double Big.one)))))
                                 (fun modmask ->
                                 bind (Obj.magic coq_Conv_monad)
                                   (Obj.magic
                                     (arith size8 X86_RTL.Coq_modu_op p3
                                       modmask)) (fun p4 ->
                                   return (Obj.magic coq_Conv_monad) ())))
                               (fun n6 ->
                               Big.nat_case
                                 (fun _ ->
                                 return (Obj.magic coq_Conv_monad) ())
                                 (fun n7 ->
                                 Big.nat_case
                                   (fun _ ->
                                   return (Obj.magic coq_Conv_monad) ())
                                   (fun n8 ->
                                   Big.nat_case
                                     (fun _ ->
                                     return (Obj.magic coq_Conv_monad) ())
                                     (fun n9 ->
                                     Big.nat_case
                                       (fun _ ->
                                       return (Obj.magic coq_Conv_monad) ())
                                       (fun n10 ->
                                       Big.nat_case
                                         (fun _ ->
                                         return (Obj.magic coq_Conv_monad) ())
                                         (fun n11 ->
                                         Big.nat_case
                                           (fun _ ->
                                           return (Obj.magic coq_Conv_monad)
                                             ())
                                           (fun n12 ->
                                           Big.nat_case
                                             (fun _ ->
                                             return
                                               (Obj.magic coq_Conv_monad) ())
                                             (fun n13 ->
                                             Big.nat_case
                                               (fun _ ->
                                               bind
                                                 (Obj.magic coq_Conv_monad)
                                                 (Obj.magic
                                                   (load_Z size8
                                                     (Big.doubleplusone
                                                     (Big.double (Big.double
                                                     (Big.double Big.one))))))
                                                 (fun modmask ->
                                                 bind
                                                   (Obj.magic coq_Conv_monad)
                                                   (Obj.magic
                                                     (arith size8
                                                       X86_RTL.Coq_modu_op p3
                                                       modmask)) (fun p4 ->
                                                   return
                                                     (Obj.magic
                                                       coq_Conv_monad) ())))
                                               (fun n14 ->
                                               return
                                                 (Obj.magic coq_Conv_monad)
                                                 ())
                                               n13)
                                             n12)
                                           n11)
                                         n10)
                                       n9)
                                     n8)
                                   n7)
                                 n6)
                               n5)
                             n4)
                           n3)
                         n2)
                       n1)
                     n0)
                   n)
                 (opsize pre.op_override w)) (fun x ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic
                  (cast_u size8
                    (plus (opsize pre.op_override w) (Big.succ Big.zero)) p3))
                (fun p2cast ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic
                    (cast_u (opsize pre.op_override w)
                      (plus (opsize pre.op_override w) (Big.succ Big.zero))
                      p1)) (fun tmp ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic (get_flag X86_MACHINE.CF)) (fun cf ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic
                        (cast_u size1
                          (plus (opsize pre.op_override w) (Big.succ
                            Big.zero)) cf)) (fun cf0 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (load_Z
                            (plus (opsize pre.op_override w) (Big.succ
                              Big.zero))
                            (Z.of_nat
                              (plus (opsize pre.op_override w) (Big.succ
                                Big.zero))))) (fun tt ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic
                            (arith
                              (plus (opsize pre.op_override w) (Big.succ
                                Big.zero)) X86_RTL.Coq_shl_op cf0 tt))
                          (fun cf1 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (arith
                                (plus (opsize pre.op_override w) (Big.succ
                                  Big.zero)) X86_RTL.Coq_or_op tmp cf1))
                            (fun tmp0 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  (plus (opsize pre.op_override w) (Big.succ
                                    Big.zero)) X86_RTL.Coq_rol_op tmp0
                                  p2cast)) (fun tmp1 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_u
                                    (plus (opsize pre.op_override w)
                                      (Big.succ Big.zero))
                                    (opsize pre.op_override w) tmp1))
                                (fun p4 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      (plus (opsize pre.op_override w)
                                        (Big.succ Big.zero))
                                      X86_RTL.Coq_shr_op tmp1 tt))
                                  (fun cf2 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (cast_u
                                        (plus (opsize pre.op_override w)
                                          (Big.succ Big.zero)) size1 cf2))
                                    (fun cf3 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (undef_flag X86_MACHINE.OF) (fun x0 ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (set_flag X86_MACHINE.CF cf3)
                                        (fun x1 -> set0 seg p4 op1))))))))))))))))))
  
  (** val conv_RCR :
      prefix -> bool -> operand -> reg_or_immed -> unit coq_Conv **)
  
  let conv_RCR pre w op1 op2 =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op pre DS op1 in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1) (fun p1 ->
      bind (Obj.magic coq_Conv_monad)
        (match op2 with
         | Reg_ri r2 -> Obj.magic (iload_op8 seg (Reg_op r2))
         | Imm_ri i ->
           Obj.magic
             (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ Big.zero))))))) i)) (fun p2 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic
            (load_Z size8 (Big.doubleplusone (Big.doubleplusone
              (Big.doubleplusone (Big.doubleplusone Big.one))))))
          (fun mask0 ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size8 X86_RTL.Coq_and_op p2 mask0)) (fun p3 ->
            bind (Obj.magic coq_Conv_monad)
              (Big.nat_case
                 (fun _ ->
                 return (Obj.magic coq_Conv_monad) ())
                 (fun n ->
                 Big.nat_case
                   (fun _ ->
                   return (Obj.magic coq_Conv_monad) ())
                   (fun n0 ->
                   Big.nat_case
                     (fun _ ->
                     return (Obj.magic coq_Conv_monad) ())
                     (fun n1 ->
                     Big.nat_case
                       (fun _ ->
                       return (Obj.magic coq_Conv_monad) ())
                       (fun n2 ->
                       Big.nat_case
                         (fun _ ->
                         return (Obj.magic coq_Conv_monad) ())
                         (fun n3 ->
                         Big.nat_case
                           (fun _ ->
                           return (Obj.magic coq_Conv_monad) ())
                           (fun n4 ->
                           Big.nat_case
                             (fun _ ->
                             return (Obj.magic coq_Conv_monad) ())
                             (fun n5 ->
                             Big.nat_case
                               (fun _ ->
                               bind (Obj.magic coq_Conv_monad)
                                 (Obj.magic
                                   (load_Z size8 (Big.doubleplusone
                                     (Big.double (Big.double Big.one)))))
                                 (fun modmask ->
                                 bind (Obj.magic coq_Conv_monad)
                                   (Obj.magic
                                     (arith size8 X86_RTL.Coq_modu_op p3
                                       modmask)) (fun p4 ->
                                   return (Obj.magic coq_Conv_monad) ())))
                               (fun n6 ->
                               Big.nat_case
                                 (fun _ ->
                                 return (Obj.magic coq_Conv_monad) ())
                                 (fun n7 ->
                                 Big.nat_case
                                   (fun _ ->
                                   return (Obj.magic coq_Conv_monad) ())
                                   (fun n8 ->
                                   Big.nat_case
                                     (fun _ ->
                                     return (Obj.magic coq_Conv_monad) ())
                                     (fun n9 ->
                                     Big.nat_case
                                       (fun _ ->
                                       return (Obj.magic coq_Conv_monad) ())
                                       (fun n10 ->
                                       Big.nat_case
                                         (fun _ ->
                                         return (Obj.magic coq_Conv_monad) ())
                                         (fun n11 ->
                                         Big.nat_case
                                           (fun _ ->
                                           return (Obj.magic coq_Conv_monad)
                                             ())
                                           (fun n12 ->
                                           Big.nat_case
                                             (fun _ ->
                                             return
                                               (Obj.magic coq_Conv_monad) ())
                                             (fun n13 ->
                                             Big.nat_case
                                               (fun _ ->
                                               bind
                                                 (Obj.magic coq_Conv_monad)
                                                 (Obj.magic
                                                   (load_Z size8
                                                     (Big.doubleplusone
                                                     (Big.double (Big.double
                                                     (Big.double Big.one))))))
                                                 (fun modmask ->
                                                 bind
                                                   (Obj.magic coq_Conv_monad)
                                                   (Obj.magic
                                                     (arith size8
                                                       X86_RTL.Coq_modu_op p3
                                                       modmask)) (fun p4 ->
                                                   return
                                                     (Obj.magic
                                                       coq_Conv_monad) ())))
                                               (fun n14 ->
                                               return
                                                 (Obj.magic coq_Conv_monad)
                                                 ())
                                               n13)
                                             n12)
                                           n11)
                                         n10)
                                       n9)
                                     n8)
                                   n7)
                                 n6)
                               n5)
                             n4)
                           n3)
                         n2)
                       n1)
                     n0)
                   n)
                 (opsize pre.op_override w)) (fun x ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic
                  (cast_u size8
                    (plus (opsize pre.op_override w) (Big.succ Big.zero)) p3))
                (fun p2cast ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic
                    (load_Z
                      (plus (opsize pre.op_override w) (Big.succ Big.zero))
                      Big.one)) (fun oneshift ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic
                      (cast_u (opsize pre.op_override w)
                        (plus (opsize pre.op_override w) (Big.succ Big.zero))
                        p1)) (fun tmp ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic
                        (arith
                          (plus (opsize pre.op_override w) (Big.succ
                            Big.zero)) X86_RTL.Coq_shl_op tmp oneshift))
                      (fun tmp0 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic (get_flag X86_MACHINE.CF)) (fun cf ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic
                            (cast_u size1
                              (plus (opsize pre.op_override w) (Big.succ
                                Big.zero)) cf)) (fun cf0 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (arith
                                (plus (opsize pre.op_override w) (Big.succ
                                  Big.zero)) X86_RTL.Coq_or_op tmp0 cf0))
                            (fun tmp1 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (arith
                                  (plus (opsize pre.op_override w) (Big.succ
                                    Big.zero)) X86_RTL.Coq_ror_op tmp1
                                  p2cast)) (fun tmp2 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_u
                                    (plus (opsize pre.op_override w)
                                      (Big.succ Big.zero)) size1 tmp2))
                                (fun cf1 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (arith
                                      (plus (opsize pre.op_override w)
                                        (Big.succ Big.zero))
                                      X86_RTL.Coq_shr_op tmp2 oneshift))
                                  (fun p4 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (cast_u
                                        (plus (opsize pre.op_override w)
                                          (Big.succ Big.zero))
                                        (opsize pre.op_override w) p4))
                                    (fun p5 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (undef_flag X86_MACHINE.OF) (fun x0 ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (set_flag X86_MACHINE.CF cf1)
                                        (fun x1 -> set0 seg p5 op1))))))))))))))))))
  
  (** val conv_SHLD :
      prefix -> operand -> register -> reg_or_immed -> unit coq_Conv **)
  
  let conv_SHLD pre op1 r2 ri =
    let load = load_op pre true in
    let set0 = set_op pre true in
    let seg = get_segment_op pre DS op1 in
    bind (Obj.magic coq_Conv_monad)
      (match ri with
       | Reg_ri r3 -> Obj.magic (iload_op8 seg (Reg_op r3))
       | Imm_ri i ->
         Obj.magic
           (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ Big.zero))))))) i)) (fun count ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic
          (load_Z size8 (Big.double (Big.double (Big.double (Big.double
            (Big.double Big.one))))))) (fun thirtytwo ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (arith size8 X86_RTL.Coq_modu_op count thirtytwo))
          (fun count0 ->
          bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.CF)
            (fun x ->
            bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.SF)
              (fun x0 ->
              bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.ZF)
                (fun x1 ->
                bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.PF)
                  (fun x2 ->
                  bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.AF)
                    (fun x3 ->
                    bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1)
                      (fun p1 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic load seg (Reg_op r2)) (fun p2 ->
                        bind (Obj.magic coq_Conv_monad)
                          (if pre.op_override
                           then Obj.magic
                                  (load_Z (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    (Big.double (Big.double (Big.double
                                    (Big.double Big.one)))))
                           else Obj.magic
                                  (load_Z (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    (Big.double (Big.double (Big.double
                                    (Big.double (Big.double Big.one)))))))
                          (fun shiftup ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (cast_u (opsize pre.op_override true) (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ (Big.succ (Big.succ
                                (Big.succ (Big.succ
                                Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                p1)) (fun wide_p1 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (arith (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                  X86_RTL.Coq_shl_op wide_p1 shiftup))
                              (fun wide_p2 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_u (opsize pre.op_override true)
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    p2)) (fun wide_p3 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (arith (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      X86_RTL.Coq_or_op wide_p2 wide_p3))
                                  (fun combined ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (cast_u size8 (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ
                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                        count0)) (fun wide_count ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (arith (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                          X86_RTL.Coq_shl_op combined
                                          wide_count)) (fun shifted ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ
                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                            X86_RTL.Coq_shru_op shifted
                                            shiftup)) (fun shifted0 ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (cast_u (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ (Big.succ (Big.succ
                                              (Big.succ
                                              Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                              (opsize pre.op_override true)
                                              shifted0)) (fun newdest0 ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (if pre.op_override
                                             then Obj.magic
                                                    (load_Z size8 (Big.double
                                                      (Big.double (Big.double
                                                      (Big.double
                                                      Big.one)))))
                                             else Obj.magic
                                                    (load_Z size8 (Big.double
                                                      (Big.double (Big.double
                                                      (Big.double (Big.double
                                                      Big.one)))))))
                                            (fun maxcount ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (test size8
                                                  X86_RTL.Coq_ltu_op maxcount
                                                  count0)) (fun guard1 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (test size8
                                                    X86_RTL.Coq_eq_op
                                                    maxcount count0))
                                                (fun guard2 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (arith size1
                                                      X86_RTL.Coq_or_op
                                                      guard1 guard2))
                                                  (fun guard ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (choose
                                                        (opsize
                                                          pre.op_override
                                                          true)))
                                                    (fun newdest1 ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (if_exp
                                                          (opsize
                                                            pre.op_override
                                                            true) guard
                                                          newdest1 newdest0))
                                                      (fun newdest ->
                                                      set0 seg newdest op1)))))))))))))))))))))))))
  
  (** val conv_SHRD :
      prefix -> operand -> register -> reg_or_immed -> unit coq_Conv **)
  
  let conv_SHRD pre op1 r2 ri =
    let load = load_op pre true in
    let set0 = set_op pre true in
    let seg = get_segment_op pre DS op1 in
    bind (Obj.magic coq_Conv_monad)
      (match ri with
       | Reg_ri r3 -> Obj.magic (iload_op8 seg (Reg_op r3))
       | Imm_ri i ->
         Obj.magic
           (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ Big.zero))))))) i)) (fun count ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic
          (load_Z size8 (Big.double (Big.double (Big.double (Big.double
            (Big.double Big.one))))))) (fun thirtytwo ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (arith size8 X86_RTL.Coq_modu_op count thirtytwo))
          (fun count0 ->
          bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.CF)
            (fun x ->
            bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.SF)
              (fun x0 ->
              bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.ZF)
                (fun x1 ->
                bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.PF)
                  (fun x2 ->
                  bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.AF)
                    (fun x3 ->
                    bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1)
                      (fun p1 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic load seg (Reg_op r2)) (fun p2 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic
                            (cast_u (opsize pre.op_override true) (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ
                              Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                              p1)) (fun wide_p1 ->
                          bind (Obj.magic coq_Conv_monad)
                            (if pre.op_override
                             then Obj.magic
                                    (load_Z (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      (Big.double (Big.double (Big.double
                                      (Big.double Big.one)))))
                             else Obj.magic
                                    (load_Z (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      (Big.double (Big.double (Big.double
                                      (Big.double (Big.double Big.one)))))))
                            (fun shiftup ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (cast_u (opsize pre.op_override true)
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ
                                  Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                  p2)) (fun wide_p2 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (arith (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                    X86_RTL.Coq_shl_op wide_p2 shiftup))
                                (fun wide_p3 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (arith (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      (Big.succ (Big.succ (Big.succ (Big.succ
                                      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                      X86_RTL.Coq_or_op wide_p1 wide_p3))
                                  (fun combined ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (cast_u size8 (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ (Big.succ (Big.succ
                                        (Big.succ
                                        Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                        count0)) (fun wide_count ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (arith (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          (Big.succ (Big.succ (Big.succ
                                          Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                          X86_RTL.Coq_shru_op combined
                                          wide_count)) (fun shifted ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (cast_u (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ (Big.succ (Big.succ
                                            (Big.succ
                                            Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                                            (opsize pre.op_override true)
                                            shifted)) (fun newdest0 ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (if pre.op_override
                                           then Obj.magic
                                                  (load_Z size8 (Big.double
                                                    (Big.double (Big.double
                                                    (Big.double Big.one)))))
                                           else Obj.magic
                                                  (load_Z size8 (Big.double
                                                    (Big.double (Big.double
                                                    (Big.double (Big.double
                                                    Big.one)))))))
                                          (fun maxcount ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (test size8 X86_RTL.Coq_ltu_op
                                                maxcount count0))
                                            (fun guard1 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (test size8 X86_RTL.Coq_eq_op
                                                  maxcount count0))
                                              (fun guard2 ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (arith size1
                                                    X86_RTL.Coq_or_op guard1
                                                    guard2)) (fun guard ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (choose
                                                      (opsize pre.op_override
                                                        true)))
                                                  (fun newdest1 ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (if_exp
                                                        (opsize
                                                          pre.op_override
                                                          true) guard
                                                        newdest1 newdest0))
                                                    (fun newdest ->
                                                    set0 seg newdest op1))))))))))))))))))))))))
  
  (** val get_AH : X86_RTL.rtl_exp coq_Conv **)
  
  let get_AH =
    iload_op8 DS (Reg_op ESP)
  
  (** val set_AH : X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_AH v =
    iset_op8 DS v (Reg_op ESP)
  
  (** val get_AL : X86_RTL.rtl_exp coq_Conv **)
  
  let get_AL =
    iload_op8 DS (Reg_op EAX)
  
  (** val set_AL : X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_AL v =
    iset_op8 DS v (Reg_op EAX)
  
  (** val conv_AAA_AAS : X86_RTL.bit_vector_op -> unit coq_Conv **)
  
  let conv_AAA_AAS op1 =
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_Z size8 (Big.doubleplusone (Big.double (Big.double Big.one)))))
      (fun pnine ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic
          (load_Z size8 (Big.doubleplusone (Big.doubleplusone
            (Big.doubleplusone Big.one))))) (fun p0Fmask ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (get_flag X86_MACHINE.AF))
          (fun paf ->
          bind (Obj.magic coq_Conv_monad) (Obj.magic get_AL) (fun pal ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (arith size8 X86_RTL.Coq_and_op pal p0Fmask))
              (fun digit1 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (test size8 X86_RTL.Coq_lt_op pnine digit1))
                (fun cond1 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (arith size1 X86_RTL.Coq_or_op cond1 paf))
                  (fun cond ->
                  bind (Obj.magic coq_Conv_monad) (Obj.magic get_AH)
                    (fun pah ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic (load_Z size1 Big.zero)) (fun pfalse ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic (copy_ps size8 pah)) (fun v_ah0 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic (copy_ps size1 pfalse)) (fun v_af0 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (copy_ps size1 pfalse)) (fun v_cf0 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (arith size8 X86_RTL.Coq_and_op pal p0Fmask))
                              (fun v_al0 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (load_Z size8 (Big.double
                                    (Big.doubleplusone Big.one))))
                                (fun psix ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic (load_Z size8 Big.one))
                                  (fun pone ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic (load_Z size1 Big.one))
                                    (fun ptrue ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic (arith size8 op1 pal psix))
                                      (fun pal_c ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith size8 X86_RTL.Coq_and_op
                                            pal_c p0Fmask)) (fun pal_cmask ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (if_exp size8 cond pal_cmask
                                              v_al0)) (fun v_al ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic get_AH) (fun pah0 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (arith size8 op1 pah0 pone))
                                              (fun pah_c ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (if_exp size8 cond pah_c
                                                    v_ah0)) (fun v_ah ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (if_exp size1 cond ptrue
                                                      v_af0)) (fun v_af ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (if_exp size1 cond
                                                        ptrue v_cf0))
                                                    (fun v_cf ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (set_AL v_al) (fun x ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (set_AH v_ah)
                                                        (fun x0 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (set_flag
                                                            X86_MACHINE.AF
                                                            v_af) (fun x1 ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (set_flag
                                                              X86_MACHINE.CF
                                                              v_cf)
                                                            (fun x2 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (undef_flag
                                                                X86_MACHINE.OF)
                                                              (fun x3 ->
                                                              bind
                                                                (Obj.magic
                                                                  coq_Conv_monad)
                                                                (undef_flag
                                                                  X86_MACHINE.SF)
                                                                (fun x4 ->
                                                                bind
                                                                  (Obj.magic
                                                                    coq_Conv_monad)
                                                                  (undef_flag
                                                                    X86_MACHINE.ZF)
                                                                  (fun x5 ->
                                                                  undef_flag
                                                                    X86_MACHINE.PF)))))))))))))))))))))))))))))))
  
  (** val conv_AAD : unit coq_Conv **)
  
  let conv_AAD =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_AL) (fun pal ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic get_AH) (fun pah ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic
            (load_Z size8 (Big.double (Big.doubleplusone (Big.double
              Big.one))))) (fun pten ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic
              (load_Z size8 (Big.doubleplusone (Big.doubleplusone
                (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
                (Big.doubleplusone (Big.doubleplusone Big.one)))))))))
            (fun pFF ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (load_Z size8 Big.zero)) (fun pzero ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (arith size8 X86_RTL.Coq_mul_op pah pten))
                (fun tensval ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (arith size8 X86_RTL.Coq_add_op pal tensval))
                  (fun pal_c ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic (arith size8 X86_RTL.Coq_and_op pal_c pFF))
                    (fun pal_cmask ->
                    bind (Obj.magic coq_Conv_monad) (set_AL pal_cmask)
                      (fun x ->
                      bind (Obj.magic coq_Conv_monad) (set_AH pzero)
                        (fun x0 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic
                            (test size8 X86_RTL.Coq_eq_op pal_cmask pzero))
                          (fun b0 ->
                          bind (Obj.magic coq_Conv_monad)
                            (set_flag X86_MACHINE.ZF b0) (fun x1 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (test size8 X86_RTL.Coq_lt_op pal_cmask
                                  pzero)) (fun b1 ->
                              bind (Obj.magic coq_Conv_monad)
                                (set_flag X86_MACHINE.SF b1) (fun x2 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (compute_parity size8 pal_cmask))
                                  (fun b2 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (set_flag X86_MACHINE.PF b2) (fun x3 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (undef_flag X86_MACHINE.OF) (fun x4 ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (undef_flag X86_MACHINE.AF)
                                        (fun x5 -> undef_flag X86_MACHINE.CF))))))))))))))))))
  
  (** val conv_AAM : unit coq_Conv **)
  
  let conv_AAM =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_AL) (fun pal ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic
          (load_Z size8 (Big.double (Big.doubleplusone (Big.double
            Big.one))))) (fun pten ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (arith size8 X86_RTL.Coq_divu_op pal pten))
          (fun digit1 ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size8 X86_RTL.Coq_modu_op pal pten))
            (fun digit2 ->
            bind (Obj.magic coq_Conv_monad) (set_AH digit1) (fun x ->
              bind (Obj.magic coq_Conv_monad) (set_AL digit2) (fun x0 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (load_Z size8 Big.zero)) (fun pzero ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic (test size8 X86_RTL.Coq_eq_op digit2 pzero))
                    (fun b0 ->
                    bind (Obj.magic coq_Conv_monad)
                      (set_flag X86_MACHINE.ZF b0) (fun x1 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (test size8 X86_RTL.Coq_lt_op digit2 pzero))
                        (fun b1 ->
                        bind (Obj.magic coq_Conv_monad)
                          (set_flag X86_MACHINE.SF b1) (fun x2 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (compute_parity size8 digit2))
                            (fun b2 ->
                            bind (Obj.magic coq_Conv_monad)
                              (set_flag X86_MACHINE.PF b2) (fun x3 ->
                              bind (Obj.magic coq_Conv_monad)
                                (undef_flag X86_MACHINE.OF) (fun x4 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (undef_flag X86_MACHINE.AF) (fun x5 ->
                                  undef_flag X86_MACHINE.CF)))))))))))))))
  
  (** val testcarryAdd :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let testcarryAdd s p1 p2 p3 =
    bind (Obj.magic coq_Conv_monad) (test s X86_RTL.Coq_ltu_op p3 p1)
      (fun b0 ->
      bind (Obj.magic coq_Conv_monad) (test s X86_RTL.Coq_ltu_op p3 p2)
        (fun b1 -> arith size1 X86_RTL.Coq_or_op b0 b1))
  
  (** val testcarrySub :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let testcarrySub s p1 p2 p3 =
    test s X86_RTL.Coq_ltu_op p1 p2
  
  (** val conv_DAA_DAS :
      X86_RTL.bit_vector_op -> (X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv) -> unit coq_Conv **)
  
  let conv_DAA_DAS op1 tester =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (choose size8)) (fun pal ->
      bind (Obj.magic coq_Conv_monad) (set_AL pal) (fun x ->
        bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.CF)
          (fun x0 ->
          bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.AF)
            (fun x1 ->
            bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.SF)
              (fun x2 ->
              bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.ZF)
                (fun x3 ->
                bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.PF)
                  (fun x4 -> undef_flag X86_MACHINE.OF)))))))
  
  (** val conv_logical_op :
      bool -> X86_RTL.bit_vector_op -> prefix -> bool -> operand -> operand
      -> unit coq_Conv **)
  
  let conv_logical_op do_effect b pre w op1 op2 =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op2 pre DS op1 op2 in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1) (fun p0 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op2) (fun p1 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (arith (opsize pre.op_override w) b p0 p1)) (fun p2 ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (load_Z (opsize pre.op_override w) Big.zero))
            (fun zero0 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic
                (test (opsize pre.op_override w) X86_RTL.Coq_eq_op zero0 p2))
              (fun zfp ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic
                  (test (opsize pre.op_override w) X86_RTL.Coq_lt_op p2
                    zero0)) (fun sfp ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (compute_parity (opsize pre.op_override w) p2))
                  (fun pfp ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic (load_Z size1 Big.zero)) (fun zero1 ->
                    bind (Obj.magic coq_Conv_monad)
                      (set_flag X86_MACHINE.OF zero1) (fun x ->
                      bind (Obj.magic coq_Conv_monad)
                        (set_flag X86_MACHINE.CF zero1) (fun x0 ->
                        bind (Obj.magic coq_Conv_monad)
                          (set_flag X86_MACHINE.ZF zfp) (fun x1 ->
                          bind (Obj.magic coq_Conv_monad)
                            (set_flag X86_MACHINE.SF sfp) (fun x2 ->
                            bind (Obj.magic coq_Conv_monad)
                              (set_flag X86_MACHINE.PF pfp) (fun x3 ->
                              bind (Obj.magic coq_Conv_monad)
                                (undef_flag X86_MACHINE.AF) (fun x4 ->
                                if do_effect
                                then set0 seg p2 op1
                                else return (Obj.magic coq_Conv_monad) ()))))))))))))))
  
  (** val conv_AND :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_AND p w op1 op2 =
    conv_logical_op true X86_RTL.Coq_and_op p w op1 op2
  
  (** val conv_OR : prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_OR p w op1 op2 =
    conv_logical_op true X86_RTL.Coq_or_op p w op1 op2
  
  (** val conv_XOR :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_XOR p w op1 op2 =
    conv_logical_op true X86_RTL.Coq_xor_op p w op1 op2
  
  (** val conv_TEST :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_TEST p w op1 op2 =
    conv_logical_op false X86_RTL.Coq_and_op p w op1 op2
  
  (** val conv_NOT : prefix -> bool -> operand -> unit coq_Conv **)
  
  let conv_NOT pre w op =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op pre DS op in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op) (fun p0 ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic
          (load_Z (opsize pre.op_override w) (Word.max_unsigned size32)))
        (fun max_unsigned0 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic
            (arith (opsize pre.op_override w) X86_RTL.Coq_xor_op p0
              max_unsigned0)) (fun p1 -> set0 seg p1 op)))
  
  (** val conv_POP : prefix -> operand -> unit coq_Conv **)
  
  let conv_POP pre op =
    let seg = SS in
    let set0 = set_op pre true seg in
    let loadmem = load_mem pre true seg in
    let espoffset =
      if pre.op_override
      then (Big.double Big.one)
      else (Big.double (Big.double Big.one))
    in
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_reg ESP)) (fun oldesp ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic loadmem oldesp)
        (fun value0 ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size32 espoffset))
          (fun offset ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size32 X86_RTL.Coq_add_op oldesp offset))
            (fun newesp ->
            bind (Obj.magic coq_Conv_monad) (set_reg newesp ESP) (fun x ->
              set0 value0 op)))))
  
  (** val conv_POPA : prefix -> unit coq_Conv **)
  
  let conv_POPA pre =
    let espoffset =
      if pre.op_override
      then (Big.double Big.one)
      else (Big.double (Big.double Big.one))
    in
    let poprtl = fun r2 -> conv_POP pre (Reg_op r2) in
    bind (Obj.magic coq_Conv_monad) (poprtl EDI) (fun x ->
      bind (Obj.magic coq_Conv_monad) (poprtl ESI) (fun x0 ->
        bind (Obj.magic coq_Conv_monad) (poprtl EBP) (fun x1 ->
          bind (Obj.magic coq_Conv_monad) (Obj.magic (load_reg ESP))
            (fun oldesp ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (load_Z size32 espoffset)) (fun offset ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (arith size32 X86_RTL.Coq_add_op oldesp offset))
                (fun newesp ->
                bind (Obj.magic coq_Conv_monad) (set_reg newesp ESP)
                  (fun x2 ->
                  bind (Obj.magic coq_Conv_monad) (poprtl EBX) (fun x3 ->
                    bind (Obj.magic coq_Conv_monad) (poprtl EDX) (fun x4 ->
                      bind (Obj.magic coq_Conv_monad) (poprtl ECX) (fun x5 ->
                        poprtl EAX))))))))))
  
  (** val conv_PUSH : prefix -> bool -> operand -> unit coq_Conv **)
  
  let conv_PUSH pre w op =
    let seg = SS in
    let load = load_op pre true seg in
    let setmem = set_mem pre true seg in
    let espoffset =
      if pre.op_override
      then (Big.double Big.one)
      else (Big.double (Big.double Big.one))
    in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load op) (fun p0 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_reg ESP))
        (fun oldesp ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size32 espoffset))
          (fun offset ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size32 X86_RTL.Coq_sub_op oldesp offset))
            (fun newesp ->
            bind (Obj.magic coq_Conv_monad) (setmem p0 newesp) (fun x ->
              set_reg newesp ESP)))))
  
  (** val conv_PUSH_pseudo :
      prefix -> bool -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let conv_PUSH_pseudo pre w pr =
    let seg = SS in
    let setmem = set_mem pre w seg in
    let espoffset =
      if pre.op_override
      then if w then (Big.double Big.one) else Big.one
      else if w then (Big.double (Big.double Big.one)) else Big.one
    in
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_reg ESP)) (fun oldesp ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size32 espoffset))
        (fun offset ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (arith size32 X86_RTL.Coq_sub_op oldesp offset))
          (fun newesp ->
          bind (Obj.magic coq_Conv_monad) (setmem pr newesp) (fun x ->
            set_reg newesp ESP))))
  
  (** val conv_PUSHA : prefix -> unit coq_Conv **)
  
  let conv_PUSHA pre =
    let load = load_op pre true SS in
    let pushrtl = fun r2 -> conv_PUSH pre true (Reg_op r2) in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load (Reg_op ESP))
      (fun oldesp ->
      bind (Obj.magic coq_Conv_monad) (pushrtl EAX) (fun x ->
        bind (Obj.magic coq_Conv_monad) (pushrtl ECX) (fun x0 ->
          bind (Obj.magic coq_Conv_monad) (pushrtl EDX) (fun x1 ->
            bind (Obj.magic coq_Conv_monad) (pushrtl EBX) (fun x2 ->
              bind (Obj.magic coq_Conv_monad)
                (conv_PUSH_pseudo pre true oldesp) (fun x3 ->
                bind (Obj.magic coq_Conv_monad) (pushrtl EBP) (fun x4 ->
                  bind (Obj.magic coq_Conv_monad) (pushrtl ESI) (fun x5 ->
                    pushrtl EDI))))))))
  
  (** val get_and_place :
      Big.big_int -> X86_RTL.rtl_exp -> Big.big_int -> X86_MACHINE.flag ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let get_and_place t0 dst pos fl =
    bind (Obj.magic coq_Conv_monad) (get_flag fl) (fun fl0 ->
      bind (Obj.magic coq_Conv_monad) (load_Z t0 pos) (fun pos0 ->
        bind (Obj.magic coq_Conv_monad) (cast_u size1 t0 fl0) (fun byt ->
          bind (Obj.magic coq_Conv_monad)
            (arith t0 X86_RTL.Coq_shl_op byt pos0) (fun tmp ->
            bind (Obj.magic coq_Conv_monad)
              (arith t0 X86_RTL.Coq_or_op dst tmp) (fun dst0 ->
              return (Obj.magic coq_Conv_monad) dst0)))))
  
  (** val conv_POP_pseudo : prefix -> X86_RTL.rtl_exp coq_Conv **)
  
  let conv_POP_pseudo pre =
    let seg = SS in
    let loadmem = load_mem pre true seg in
    let espoffset =
      if pre.op_override
      then (Big.double Big.one)
      else (Big.double (Big.double Big.one))
    in
    bind (Obj.magic coq_Conv_monad) (load_reg ESP) (fun oldesp ->
      bind (Obj.magic coq_Conv_monad) (loadmem oldesp) (fun value0 ->
        bind (Obj.magic coq_Conv_monad) (load_Z size32 espoffset)
          (fun offset ->
          bind (Obj.magic coq_Conv_monad)
            (arith size32 X86_RTL.Coq_add_op oldesp offset) (fun newesp ->
            bind (Obj.magic coq_Conv_monad) (Obj.magic (set_reg newesp ESP))
              (fun x -> return (Obj.magic coq_Conv_monad) value0)))))
  
  (** val extract_and_set :
      Big.big_int -> X86_RTL.rtl_exp -> Big.big_int -> X86_MACHINE.flag ->
      unit coq_Conv **)
  
  let extract_and_set t0 value0 pos fl =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z t0 Big.one))
      (fun one0 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z t0 pos))
        (fun pos0 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (arith t0 X86_RTL.Coq_shr_op value0 pos0)) (fun tmp ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith t0 X86_RTL.Coq_and_op tmp one0)) (fun tmp0 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (test t0 X86_RTL.Coq_eq_op one0 tmp0)) (fun b ->
              set_flag fl b)))))
  
  (** val conv_JMP :
      prefix -> bool -> bool -> operand -> selector option -> unit coq_Conv **)
  
  let conv_JMP pre near absolute op sel =
    let seg = get_segment_op pre DS op in
    if near
    then bind (Obj.magic coq_Conv_monad) (Obj.magic (iload_op32 seg op))
           (fun disp ->
           bind (Obj.magic coq_Conv_monad)
             (if absolute
              then Obj.magic (load_Z size32 Big.zero)
              else Obj.magic get_pc) (fun base ->
             bind (Obj.magic coq_Conv_monad)
               (Obj.magic (arith size32 X86_RTL.Coq_add_op base disp))
               (fun newpc -> set_pc newpc)))
    else coq_EMIT X86_RTL.Coq_error_rtl
  
  (** val conv_Jcc : prefix -> condition_type -> int32 -> unit coq_Conv **)
  
  let conv_Jcc pre ct disp =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_cc ct)) (fun guard ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic get_pc) (fun oldpc ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic
            (load_int (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
              (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
              disp)) (fun pdisp ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size32 X86_RTL.Coq_add_op oldpc pdisp))
            (fun newpc ->
            coq_EMIT (X86_RTL.Coq_if_rtl (guard, (X86_RTL.Coq_set_loc_rtl
              (size32, newpc, X86_MACHINE.Coq_pc_loc))))))))
  
  (** val conv_CALL :
      prefix -> bool -> bool -> operand -> selector option -> unit coq_Conv **)
  
  let conv_CALL pre near absolute op sel =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_pc) (fun oldpc ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_reg ESP))
        (fun oldesp ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (load_Z size32 (Big.double (Big.double Big.one))))
          (fun four ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size32 X86_RTL.Coq_sub_op oldesp four))
            (fun newesp ->
            bind (Obj.magic coq_Conv_monad) (set_mem32 SS oldpc newesp)
              (fun x ->
              bind (Obj.magic coq_Conv_monad) (set_reg newesp ESP) (fun x0 ->
                conv_JMP pre near absolute op sel))))))
  
  (** val conv_RET : prefix -> bool -> int16 option -> unit coq_Conv **)
  
  let conv_RET pre same_segment disp =
    if same_segment
    then bind (Obj.magic coq_Conv_monad) (Obj.magic (load_reg ESP))
           (fun oldesp ->
           bind (Obj.magic coq_Conv_monad) (Obj.magic (load_mem32 SS oldesp))
             (fun value0 ->
             bind (Obj.magic coq_Conv_monad)
               (Obj.magic (load_Z size32 (Big.double (Big.double Big.one))))
               (fun four ->
               bind (Obj.magic coq_Conv_monad)
                 (Obj.magic (arith size32 X86_RTL.Coq_add_op oldesp four))
                 (fun newesp ->
                 bind (Obj.magic coq_Conv_monad)
                   (match disp with
                    | Some imm ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (load_int (Big.succ (Big.succ (Big.succ (Big.succ
                            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                            (Big.succ Big.zero))))))))))))))) imm))
                        (fun imm0 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic
                            (cast_u (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ (Big.succ
                              (Big.succ (Big.succ (Big.succ
                              Big.zero))))))))))))))) size32 imm0))
                          (fun imm1 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (arith size32 X86_RTL.Coq_add_op newesp imm1))
                            (fun newesp2 -> set_reg newesp2 ESP)))
                    | None -> set_reg newesp ESP) (fun x -> set_pc value0)))))
    else coq_EMIT X86_RTL.Coq_error_rtl
  
  (** val conv_LEAVE : prefix -> unit coq_Conv **)
  
  let conv_LEAVE pre =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_reg EBP))
      (fun ebp_val ->
      bind (Obj.magic coq_Conv_monad) (set_reg ebp_val ESP) (fun x ->
        conv_POP pre (Reg_op EBP)))
  
  (** val conv_LOOP : prefix -> bool -> bool -> int8 -> unit coq_Conv **)
  
  let conv_LOOP pre flagged testz disp =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 Big.one))
      (fun ptrue ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_reg ECX)) (fun p0 ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size32 Big.one))
          (fun p1 ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size32 X86_RTL.Coq_sub_op p0 p1)) (fun p2 ->
            bind (Obj.magic coq_Conv_monad) (set_reg p2 ECX) (fun x ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (load_Z size32 Big.zero)) (fun pzero ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (test size32 X86_RTL.Coq_eq_op p2 pzero))
                  (fun pcz ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic (arith size1 X86_RTL.Coq_xor_op pcz ptrue))
                    (fun pcnz ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic (get_flag X86_MACHINE.ZF)) (fun pzf ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (arith size1 X86_RTL.Coq_xor_op pzf ptrue))
                        (fun pnzf ->
                        bind (Obj.magic coq_Conv_monad)
                          (if flagged
                           then if testz
                                then Obj.magic
                                       (arith size1 X86_RTL.Coq_and_op pzf
                                         pcnz)
                                else Obj.magic
                                       (arith size1 X86_RTL.Coq_and_op pnzf
                                         pcnz)
                           else Obj.magic
                                  (arith size1 X86_RTL.Coq_or_op pcnz pcnz))
                          (fun bcond ->
                          bind (Obj.magic coq_Conv_monad) (Obj.magic get_pc)
                            (fun eip0 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (load_int (Big.succ (Big.succ (Big.succ
                                  (Big.succ (Big.succ (Big.succ (Big.succ
                                  Big.zero))))))) disp)) (fun doffset0 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_s (Big.succ (Big.succ (Big.succ
                                    (Big.succ (Big.succ (Big.succ (Big.succ
                                    Big.zero))))))) size32 doffset0))
                                (fun doffset1 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (arith size32 X86_RTL.Coq_add_op eip0
                                      doffset1)) (fun eip1 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (if pre.op_override
                                     then Obj.magic
                                            (load_Z size32 (Big.double
                                              (Big.double (Big.double
                                              (Big.double (Big.double
                                              (Big.double (Big.double
                                              (Big.double (Big.double
                                              (Big.double (Big.double
                                              (Big.double (Big.double
                                              (Big.double (Big.double
                                              (Big.double
                                              Big.one)))))))))))))))))
                                     else Obj.magic
                                            (load_Z size32 (Z.opp Big.one)))
                                    (fun eipmask ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (arith size32 X86_RTL.Coq_and_op eip1
                                          eipmask)) (fun eip2 ->
                                      coq_EMIT (X86_RTL.Coq_if_rtl (bcond,
                                        (X86_RTL.Coq_set_loc_rtl (size32,
                                        eip2, X86_MACHINE.Coq_pc_loc)))))))))))))))))))))
  
  (** val conv_BS_aux :
      Big.big_int -> bool -> Big.big_int -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let rec conv_BS_aux s d n op =
    let curr_int =
      if d
      then Word.repr s (Z.of_nat (minus s n))
      else Word.repr s (Z.of_nat n)
    in
    (Big.nat_case
       (fun _ ->
       load_int s curr_int)
       (fun n' ->
       bind (Obj.magic coq_Conv_monad) (load_int s curr_int) (fun bcount ->
         bind (Obj.magic coq_Conv_monad) (conv_BS_aux s d n' op) (fun rec0 ->
           bind (Obj.magic coq_Conv_monad)
             (arith s X86_RTL.Coq_shru_op op bcount) (fun ps ->
             bind (Obj.magic coq_Conv_monad) (cast_u s size1 ps)
               (fun curr_bit ->
               bind (Obj.magic coq_Conv_monad) (load_int s curr_int)
                 (fun rec1 ->
                 bind (Obj.magic coq_Conv_monad)
                   (if_exp s curr_bit rec1 rec0) (fun rec2 ->
                   return (Obj.magic coq_Conv_monad) rec2)))))))
       n)
  
  (** val conv_BS : bool -> prefix -> operand -> operand -> unit coq_Conv **)
  
  let conv_BS d pre op1 op2 =
    let seg = get_segment_op2 pre DS op1 op2 in
    bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.AF) (fun x ->
      bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.CF) (fun x0 ->
        bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.SF)
          (fun x1 ->
          bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.OF)
            (fun x2 ->
            bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.PF)
              (fun x3 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (iload_op32 seg op1)) (fun des ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (iload_op32 seg op2)) (fun src ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic (load_Z size32 Big.zero)) (fun zero0 ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic (test size32 X86_RTL.Coq_eq_op src zero0))
                      (fun zf ->
                      bind (Obj.magic coq_Conv_monad)
                        (set_flag X86_MACHINE.ZF zf) (fun x4 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic (conv_BS_aux size32 d size32 src))
                          (fun res0 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (choose size32)) (fun res1 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (if_exp size32 zf res1 res0))
                              (fun res -> iset_op32 seg res op1)))))))))))))
  
  (** val conv_BSF : prefix -> operand -> operand -> unit coq_Conv **)
  
  let conv_BSF p op1 op2 =
    conv_BS true p op1 op2
  
  (** val conv_BSR : prefix -> operand -> operand -> unit coq_Conv **)
  
  let conv_BSR p op1 op2 =
    conv_BS false p op1 op2
  
  (** val get_Bit :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let get_Bit s pb poff =
    bind (Obj.magic coq_Conv_monad) (load_Z s Big.one) (fun omask ->
      bind (Obj.magic coq_Conv_monad) (arith s X86_RTL.Coq_shr_op pb poff)
        (fun shr_pb ->
        bind (Obj.magic coq_Conv_monad)
          (arith s X86_RTL.Coq_and_op shr_pb omask) (fun mask_pb ->
          bind (Obj.magic coq_Conv_monad) (cast_u s size1 mask_pb) (fun tb ->
            return (Obj.magic coq_Conv_monad) tb))))
  
  (** val modify_Bit :
      Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp coq_Conv **)
  
  let modify_Bit s value0 poff bitval =
    bind (Obj.magic coq_Conv_monad) (load_Z s Big.one) (fun obit ->
      bind (Obj.magic coq_Conv_monad) (arith s X86_RTL.Coq_shl_op obit poff)
        (fun one_shifted ->
        bind (Obj.magic coq_Conv_monad) (not s one_shifted)
          (fun inv_one_shifted ->
          bind (Obj.magic coq_Conv_monad) (cast_u size1 s bitval)
            (fun bitvalword ->
            bind (Obj.magic coq_Conv_monad)
              (arith s X86_RTL.Coq_shl_op bitvalword poff)
              (fun bit_shifted ->
              bind (Obj.magic coq_Conv_monad)
                (arith s X86_RTL.Coq_and_op value0 inv_one_shifted)
                (fun newval -> arith s X86_RTL.Coq_or_op newval bit_shifted))))))
  
  (** val set_Bit :
      prefix -> bool -> operand -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit
      coq_Conv **)
  
  let set_Bit pre w op poff bitval =
    let seg = get_segment_op pre DS op in
    let load = load_op pre w seg in
    let set0 = set_op pre w seg in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load op) (fun value0 ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic
          (modify_Bit (opsize pre.op_override w) value0 poff bitval))
        (fun newvalue -> set0 newvalue op))
  
  (** val set_Bit_mem :
      prefix -> bool -> operand -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_Bit_mem pre w op addr poff bitval =
    let seg = get_segment_op pre DS op in
    let load = load_mem pre w seg in
    let set0 = set_mem pre w seg in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load addr) (fun value0 ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic
          (modify_Bit (opsize pre.op_override w) value0 poff bitval))
        (fun newvalue ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (copy_ps size32 addr))
          (fun newaddr -> set0 newvalue newaddr)))
  
  (** val fbit :
      bool -> bool -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let fbit param1 param2 v =
    bind (Obj.magic coq_Conv_monad) (load_Z size1 Big.one) (fun pone ->
      bind (Obj.magic coq_Conv_monad) (load_Z size1 Big.zero) (fun pzero ->
        if param1
        then if param2
             then return (Obj.magic coq_Conv_monad) pone
             else return (Obj.magic coq_Conv_monad) pzero
        else if param2
             then return (Obj.magic coq_Conv_monad) v
             else bind (Obj.magic coq_Conv_monad) (not size1 v) (fun v1 ->
                    return (Obj.magic coq_Conv_monad) v1)))
  
  (** val conv_BT :
      bool -> bool -> prefix -> operand -> operand -> unit coq_Conv **)
  
  let conv_BT param1 param2 pre op1 regimm =
    let seg = get_segment_op pre DS op1 in
    let load = load_op pre true seg in
    let lmem0 = load_mem pre true seg in
    let opsz = opsize pre.op_override true in
    bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.OF) (fun x ->
      bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.SF) (fun x0 ->
        bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.AF)
          (fun x1 ->
          bind (Obj.magic coq_Conv_monad) (undef_flag X86_MACHINE.PF)
            (fun x2 ->
            bind (Obj.magic coq_Conv_monad) (Obj.magic load regimm)
              (fun pi0 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (load_Z opsz (Z.add (Z.of_nat opsz) Big.one)))
                (fun popsz ->
                bind (Obj.magic coq_Conv_monad)
                  (match regimm with
                   | Imm_op i ->
                     Obj.magic
                       (arith (opsize pre.op_override true)
                         X86_RTL.Coq_modu_op pi0 popsz)
                   | _ ->
                     Obj.magic (copy_ps (opsize pre.op_override true) pi0))
                  (fun rawoffset ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic
                      (load_Z size32
                        (Z.div (Z.of_nat (plus opsz (Big.succ Big.zero)))
                          (Big.double (Big.double (Big.double Big.one))))))
                    (fun popsz_bytes ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic (load_Z opsz Big.zero)) (fun pzero ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic (load_Z size32 (Big.opp Big.one)))
                        (fun pneg1 ->
                        let btmem = fun psaddr ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic
                              (arith (opsize pre.op_override true)
                                X86_RTL.Coq_mods_op rawoffset popsz))
                            (fun bitoffset ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic
                                (arith (opsize pre.op_override true)
                                  X86_RTL.Coq_divs_op rawoffset popsz))
                              (fun wordoffset' ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (cast_s (opsize pre.op_override true)
                                    size32 wordoffset')) (fun wordoffset ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (test (opsize pre.op_override true)
                                      X86_RTL.Coq_lt_op bitoffset pzero))
                                  (fun isneg ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (copy_ps (opsize pre.op_override true)
                                        bitoffset)) (fun nbitoffset0 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic (copy_ps size32 wordoffset))
                                      (fun nwordoffset0 ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith opsz X86_RTL.Coq_add_op
                                            popsz bitoffset))
                                        (fun negbitoffset ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (arith size32 X86_RTL.Coq_add_op
                                              pneg1 wordoffset))
                                          (fun negwordoffset ->
                                          bind (Obj.magic coq_Conv_monad)
                                            (Obj.magic
                                              (cast_u opsz
                                                (opsize pre.op_override true)
                                                negbitoffset))
                                            (fun nbitoffset1 ->
                                            bind (Obj.magic coq_Conv_monad)
                                              (Obj.magic
                                                (if_exp
                                                  (opsize pre.op_override
                                                    true) isneg nbitoffset1
                                                  nbitoffset0))
                                              (fun nbitoffset ->
                                              bind (Obj.magic coq_Conv_monad)
                                                (Obj.magic
                                                  (cast_u size32 size32
                                                    negwordoffset))
                                                (fun nwordoffset1 ->
                                                bind
                                                  (Obj.magic coq_Conv_monad)
                                                  (Obj.magic
                                                    (if_exp size32 isneg
                                                      nwordoffset1
                                                      nwordoffset0))
                                                  (fun nwordoffset ->
                                                  bind
                                                    (Obj.magic
                                                      coq_Conv_monad)
                                                    (Obj.magic
                                                      (arith size32
                                                        X86_RTL.Coq_mul_op
                                                        nwordoffset
                                                        popsz_bytes))
                                                    (fun newaddrdelta ->
                                                    bind
                                                      (Obj.magic
                                                        coq_Conv_monad)
                                                      (Obj.magic
                                                        (arith size32
                                                          X86_RTL.Coq_add_op
                                                          newaddrdelta
                                                          psaddr))
                                                      (fun newaddr ->
                                                      bind
                                                        (Obj.magic
                                                          coq_Conv_monad)
                                                        (Obj.magic lmem0
                                                          newaddr)
                                                        (fun value0 ->
                                                        bind
                                                          (Obj.magic
                                                            coq_Conv_monad)
                                                          (Obj.magic
                                                            (get_Bit
                                                              (opsize
                                                                pre.op_override
                                                                true) value0
                                                              nbitoffset))
                                                          (fun bt ->
                                                          bind
                                                            (Obj.magic
                                                              coq_Conv_monad)
                                                            (set_flag
                                                              X86_MACHINE.CF
                                                              bt) (fun x3 ->
                                                            bind
                                                              (Obj.magic
                                                                coq_Conv_monad)
                                                              (Obj.magic
                                                                (fbit param1
                                                                  param2 bt))
                                                              (fun newbt ->
                                                              set_Bit_mem pre
                                                                true op1
                                                                newaddr
                                                                nbitoffset
                                                                newbt))))))))))))))))))
                        in
                        (match op1 with
                         | Imm_op i -> coq_EMIT X86_RTL.Coq_error_rtl
                         | Reg_op r2 ->
                           bind (Obj.magic coq_Conv_monad)
                             (Obj.magic load (Reg_op r2)) (fun value0 ->
                             bind (Obj.magic coq_Conv_monad)
                               (Obj.magic
                                 (arith (opsize pre.op_override true)
                                   X86_RTL.Coq_modu_op rawoffset popsz))
                               (fun bitoffset ->
                               bind (Obj.magic coq_Conv_monad)
                                 (Obj.magic
                                   (get_Bit (opsize pre.op_override true)
                                     value0 bitoffset)) (fun bt ->
                                 bind (Obj.magic coq_Conv_monad)
                                   (set_flag X86_MACHINE.CF bt) (fun x3 ->
                                   bind (Obj.magic coq_Conv_monad)
                                     (Obj.magic (fbit param1 param2 bt))
                                     (fun newbt ->
                                     set_Bit pre true op1 bitoffset newbt)))))
                         | Address_op a ->
                           bind (Obj.magic coq_Conv_monad)
                             (Obj.magic (compute_addr a)) (fun psaddr ->
                             btmem psaddr)
                         | Offset_op ioff ->
                           bind (Obj.magic coq_Conv_monad)
                             (Obj.magic
                               (load_int (Big.succ (Big.succ (Big.succ
                                 (Big.succ (Big.succ (Big.succ (Big.succ
                                 (Big.succ (Big.succ (Big.succ (Big.succ
                                 (Big.succ (Big.succ (Big.succ (Big.succ
                                 (Big.succ (Big.succ (Big.succ (Big.succ
                                 (Big.succ (Big.succ (Big.succ (Big.succ
                                 (Big.succ (Big.succ (Big.succ (Big.succ
                                 (Big.succ (Big.succ (Big.succ (Big.succ
                                 Big.zero)))))))))))))))))))))))))))))))
                                 ioff)) (fun psaddr -> btmem psaddr))))))))))))
  
  (** val conv_BSWAP : prefix -> register -> unit coq_Conv **)
  
  let conv_BSWAP pre r2 =
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_Z size32 (Big.double (Big.double (Big.double Big.one)))))
      (fun eight ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_reg r2)) (fun ps0 ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (cast_u size32 size8 ps0))
          (fun b0 ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size32 X86_RTL.Coq_shru_op ps0 eight))
            (fun ps1 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (cast_u size32 size8 ps1)) (fun b1 ->
              bind (Obj.magic coq_Conv_monad)
                (Obj.magic (cast_u size8 size32 b1)) (fun w1 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (arith size32 X86_RTL.Coq_shru_op ps1 eight))
                  (fun ps2 ->
                  bind (Obj.magic coq_Conv_monad)
                    (Obj.magic (cast_u size32 size8 ps2)) (fun b2 ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic (cast_u size8 size32 b2)) (fun w2 ->
                      bind (Obj.magic coq_Conv_monad)
                        (Obj.magic
                          (arith size32 X86_RTL.Coq_shru_op ps2 eight))
                        (fun ps3 ->
                        bind (Obj.magic coq_Conv_monad)
                          (Obj.magic (cast_u size32 size8 ps3)) (fun b3 ->
                          bind (Obj.magic coq_Conv_monad)
                            (Obj.magic (cast_u size8 size32 b3)) (fun w3 ->
                            bind (Obj.magic coq_Conv_monad)
                              (Obj.magic (cast_u size8 size32 b0))
                              (fun res0 ->
                              bind (Obj.magic coq_Conv_monad)
                                (Obj.magic
                                  (arith size32 X86_RTL.Coq_shl_op res0
                                    eight)) (fun res1 ->
                                bind (Obj.magic coq_Conv_monad)
                                  (Obj.magic
                                    (arith size32 X86_RTL.Coq_add_op res1 w1))
                                  (fun res2 ->
                                  bind (Obj.magic coq_Conv_monad)
                                    (Obj.magic
                                      (arith size32 X86_RTL.Coq_shl_op res2
                                        eight)) (fun res3 ->
                                    bind (Obj.magic coq_Conv_monad)
                                      (Obj.magic
                                        (arith size32 X86_RTL.Coq_add_op res3
                                          w2)) (fun res4 ->
                                      bind (Obj.magic coq_Conv_monad)
                                        (Obj.magic
                                          (arith size32 X86_RTL.Coq_shl_op
                                            res4 eight)) (fun res5 ->
                                        bind (Obj.magic coq_Conv_monad)
                                          (Obj.magic
                                            (arith size32 X86_RTL.Coq_add_op
                                              res5 w3)) (fun res6 ->
                                          set_reg res6 r2)))))))))))))))))))
  
  (** val conv_CWDE : prefix -> unit coq_Conv **)
  
  let conv_CWDE pre =
    let seg = get_segment pre DS in
    if pre.op_override
    then bind (Obj.magic coq_Conv_monad)
           (Obj.magic (iload_op8 seg (Reg_op EAX))) (fun p1 ->
           bind (Obj.magic coq_Conv_monad)
             (Obj.magic (cast_s size8 size16 p1)) (fun p2 ->
             iset_op16 seg p2 (Reg_op EAX)))
    else bind (Obj.magic coq_Conv_monad)
           (Obj.magic (iload_op16 seg (Reg_op EAX))) (fun p1 ->
           bind (Obj.magic coq_Conv_monad)
             (Obj.magic (cast_s size16 size32 p1)) (fun p2 ->
             iset_op32 seg p2 (Reg_op EAX)))
  
  (** val conv_CDQ : prefix -> unit coq_Conv **)
  
  let conv_CDQ pre =
    let seg = get_segment pre DS in
    if pre.op_override
    then bind (Obj.magic coq_Conv_monad)
           (Obj.magic (iload_op16 seg (Reg_op EAX))) (fun p1 ->
           bind (Obj.magic coq_Conv_monad)
             (Obj.magic (cast_s size16 size32 p1)) (fun p2 ->
             bind (Obj.magic coq_Conv_monad)
               (Obj.magic (cast_s size32 size16 p2)) (fun p2_bottom ->
               bind (Obj.magic coq_Conv_monad)
                 (Obj.magic
                   (load_Z size32 (Big.double (Big.double (Big.double
                     (Big.double Big.one)))))) (fun sixteen ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic (arith size32 X86_RTL.Coq_shr_op p2 sixteen))
                   (fun p2_top0 ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (cast_s size32 size16 p2_top0))
                     (fun p2_top ->
                     bind (Obj.magic coq_Conv_monad)
                       (iset_op16 seg p2_bottom (Reg_op EAX)) (fun x ->
                       iset_op16 seg p2_top (Reg_op EDX))))))))
    else bind (Obj.magic coq_Conv_monad)
           (Obj.magic (iload_op32 seg (Reg_op EAX))) (fun p1 ->
           bind (Obj.magic coq_Conv_monad)
             (Obj.magic
               (cast_s size32 (Big.succ (Big.succ (Big.succ (Big.succ
                 (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                 (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                 (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                 (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                 (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                 (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                 (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                 (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                 (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                 (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                 Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                 p1)) (fun p2 ->
             bind (Obj.magic coq_Conv_monad)
               (Obj.magic
                 (cast_s (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                   (Big.succ (Big.succ (Big.succ
                   Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                   size32 p2)) (fun p2_bottom ->
               bind (Obj.magic coq_Conv_monad)
                 (Obj.magic
                   (load_Z (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                     (Big.succ (Big.succ (Big.succ
                     Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                     (Big.double (Big.double (Big.double (Big.double
                     (Big.double Big.one))))))) (fun thirtytwo ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic
                     (arith (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                       (Big.succ (Big.succ (Big.succ
                       Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                       X86_RTL.Coq_shr_op p2 thirtytwo)) (fun p2_top0 ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic
                       (cast_s (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
                         (Big.succ (Big.succ (Big.succ (Big.succ
                         Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                         size32 p2_top0)) (fun p2_top ->
                     bind (Obj.magic coq_Conv_monad)
                       (iset_op32 seg p2_bottom (Reg_op EAX)) (fun x ->
                       iset_op32 seg p2_top (Reg_op EDX))))))))
  
  (** val conv_MOV :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_MOV pre w op1 op2 =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op2 pre DS op1 op2 in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op2) (fun res ->
      set0 seg res op1)
  
  (** val conv_CMOV :
      prefix -> bool -> condition_type -> operand -> operand -> unit coq_Conv **)
  
  let conv_CMOV pre w cc op1 op2 =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op2 pre DS op1 op2 in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1) (fun tmp0 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op2) (fun src ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_cc cc))
          (fun cc0 ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic
              (cast_u (opsize pre.op_override w) (opsize pre.op_override w)
                src)) (fun tmp1 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (if_exp (opsize pre.op_override w) cc0 tmp1 tmp0))
              (fun tmp -> set0 seg tmp op1)))))
  
  (** val conv_MOV_extend :
      (Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv) -> prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_MOV_extend extend_op pre w op1 op2 =
    let seg = get_segment_op2 pre DS op1 op2 in
    if pre.op_override
    then if w
         then bind (Obj.magic coq_Conv_monad)
                (Obj.magic (iload_op16 seg op2)) (fun p1 ->
                iset_op16 seg p1 op1)
         else bind (Obj.magic coq_Conv_monad) (Obj.magic (iload_op8 seg op2))
                (fun p1 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic extend_op size8 size16 p1) (fun p2 ->
                  iset_op16 seg p2 op1))
    else if w
         then bind (Obj.magic coq_Conv_monad)
                (Obj.magic (iload_op16 seg op2)) (fun p1 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic extend_op size16 size32 p1) (fun p2 ->
                  iset_op32 seg p2 op1))
         else bind (Obj.magic coq_Conv_monad) (Obj.magic (iload_op8 seg op2))
                (fun p1 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic extend_op size8 size32 p1) (fun p2 ->
                  iset_op32 seg p2 op1))
  
  (** val conv_MOVZX :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_MOVZX pre w op1 op2 =
    conv_MOV_extend cast_u pre w op1 op2
  
  (** val conv_MOVSX :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_MOVSX pre w op1 op2 =
    conv_MOV_extend cast_s pre w op1 op2
  
  (** val conv_XCHG :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_XCHG pre w op1 op2 =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg = get_segment_op2 pre DS op1 op2 in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op1) (fun p1 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic load seg op2) (fun p2 ->
        bind (Obj.magic coq_Conv_monad) (set0 seg p2 op1) (fun x ->
          set0 seg p1 op2)))
  
  (** val conv_XADD :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_XADD pre w op1 op2 =
    bind (Obj.magic coq_Conv_monad) (conv_XCHG pre w op1 op2) (fun x ->
      conv_ADD pre w op1 op2)
  
  (** val conv_CMPXCHG :
      prefix -> bool -> operand -> operand -> unit coq_Conv **)
  
  let conv_CMPXCHG pre w op1 op2 =
    bind (Obj.magic coq_Conv_monad) (conv_CMP pre w (Reg_op EAX) op1)
      (fun x ->
      bind (Obj.magic coq_Conv_monad) (conv_CMOV pre w E_ct op1 op2)
        (fun x0 -> conv_CMOV pre w NE_ct (Reg_op EAX) op1))
  
  (** val string_op_reg_shift :
      register -> prefix -> bool -> unit coq_Conv **)
  
  let string_op_reg_shift reg0 pre w =
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic
        (load_Z size32
          (if pre.op_override
           then if w then (Big.double Big.one) else Big.one
           else if w then (Big.double (Big.double Big.one)) else Big.one)))
      (fun offset ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (get_flag X86_MACHINE.DF))
        (fun df ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (iload_op32 DS (Reg_op reg0))) (fun old_reg ->
          bind (Obj.magic coq_Conv_monad)
            (Obj.magic (arith size32 X86_RTL.Coq_add_op old_reg offset))
            (fun new_reg1 ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (arith size32 X86_RTL.Coq_sub_op old_reg offset))
              (fun new_reg2 ->
              bind (Obj.magic coq_Conv_monad)
                (coq_EMIT (X86_RTL.Coq_set_loc_rtl (size32, new_reg1,
                  (X86_MACHINE.Coq_reg_loc reg0)))) (fun x ->
                coq_EMIT (X86_RTL.Coq_if_rtl (df, (X86_RTL.Coq_set_loc_rtl
                  (size32, new_reg2, (X86_MACHINE.Coq_reg_loc reg0)))))))))))
  
  (** val conv_MOVS : prefix -> bool -> unit coq_Conv **)
  
  let conv_MOVS pre w =
    let load = load_op pre w in
    let set0 = set_op pre w in
    let seg_load = get_segment pre DS in
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic load seg_load (Address_op { addrDisp =
        (Word.zero (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))));
        addrBase = (Some ESI); addrIndex = None })) (fun p1 ->
      bind (Obj.magic coq_Conv_monad)
        (set0 ES p1 (Address_op { addrDisp =
          (Word.zero (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))));
          addrBase = (Some EDI); addrIndex = None })) (fun x ->
        bind (Obj.magic coq_Conv_monad) (string_op_reg_shift EDI pre w)
          (fun x0 -> string_op_reg_shift ESI pre w)))
  
  (** val conv_STOS : prefix -> bool -> unit coq_Conv **)
  
  let conv_STOS pre w =
    let load = load_op pre w in
    let set0 = set_op pre w in
    bind (Obj.magic coq_Conv_monad) (Obj.magic load DS (Reg_op EAX))
      (fun p1 ->
      bind (Obj.magic coq_Conv_monad)
        (set0 ES p1 (Address_op { addrDisp =
          (Word.zero (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))));
          addrBase = (Some EDI); addrIndex = None })) (fun x ->
        string_op_reg_shift EDI pre w))
  
  (** val conv_CMPS : prefix -> bool -> unit coq_Conv **)
  
  let conv_CMPS pre w =
    let seg1 = get_segment pre DS in
    let op1 = Address_op { addrDisp =
      (Word.zero (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero)))))))))))))))))))))))))))))))); addrBase = (Some ESI);
      addrIndex = None }
    in
    let op2 = Address_op { addrDisp =
      (Word.zero (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero)))))))))))))))))))))))))))))))); addrBase = (Some EDI);
      addrIndex = None }
    in
    bind (Obj.magic coq_Conv_monad)
      (conv_SUB_CMP_generic false pre w op1 op2 op2 seg1 seg1 ES) (fun x ->
      bind (Obj.magic coq_Conv_monad) (string_op_reg_shift EDI pre w)
        (fun x0 -> string_op_reg_shift ESI pre w))
  
  (** val conv_LEA : prefix -> operand -> operand -> unit coq_Conv **)
  
  let conv_LEA pre op1 op2 =
    let seg = get_segment_op pre DS op1 in
    (match op2 with
     | Address_op a ->
       bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a))
         (fun r2 -> iset_op32 seg r2 op1)
     | _ -> coq_EMIT X86_RTL.Coq_error_rtl)
  
  (** val conv_HLT : prefix -> unit coq_Conv **)
  
  let conv_HLT pre =
    coq_EMIT X86_RTL.Coq_trap_rtl
  
  (** val conv_SETcc :
      prefix -> condition_type -> operand -> unit coq_Conv **)
  
  let conv_SETcc pre ct op =
    let seg = get_segment_op pre DS op in
    bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_cc ct)) (fun ccval ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (cast_u size1 size8 ccval))
        (fun ccext -> iset_op8 seg ccext op))
  
  (** val check_prefix : prefix -> unit coq_Conv **)
  
  let check_prefix p =
    if p.addr_override
    then coq_EMIT X86_RTL.Coq_error_rtl
    else return (Obj.magic coq_Conv_monad) ()
  
  (** val int_to_bin32 : Word.int -> binary32 **)
  
  let int_to_bin32 i =
    b32_of_bits (Word.intval size32 i)
  
  (** val bin32_to_int : binary32 -> Word.int **)
  
  let bin32_to_int b =
    Word.repr size32 (bits_of_b32 b)
  
  (** val int_to_bin64 : Word.int -> binary64 **)
  
  let int_to_bin64 i =
    b64_of_bits (Word.intval size64 i)
  
  (** val bin64_to_int : binary64 -> Word.int **)
  
  let bin64_to_int b =
    Word.repr size64 (bits_of_b64 b)
  
  (** val int_to_de_float : Word.int -> de_float **)
  
  let int_to_de_float i =
    de_float_of_bits (Word.intval size80 i)
  
  (** val de_float_to_int : de_float -> Word.int **)
  
  let de_float_to_int b =
    Word.repr size80 (bits_of_de_float b)
  
  (** val string_to_de_float : char list -> de_float **)
  
  let string_to_de_float s =
    let intval0 = Word.string_to_int size80 s in int_to_de_float intval0
  
  (** val s2bf : char list -> de_float **)
  
  let s2bf s =
    string_to_de_float s
  
  (** val s2int80 : char list -> int0 **)
  
  let s2int80 s =
    Word.string_to_int size80 s
  
  (** val integer_to_de_float : Word.int -> de_float **)
  
  let integer_to_de_float i =
    let bin = int_to_de_float i in
    (match bin with
     | B754_finite (s, m, e) ->
       let mant_val = Word.intval size80 i in
       let (rec0, shifted_m) =
         shr0 { shr_m = mant_val; shr_r = false; shr_s = false } mant_val
           Big.one
       in
       let exp_val = Z.of_nat size80 in
       let joined =
         join_bits (Big.double (Big.double (Big.double (Big.double
           (Big.double (Big.double Big.one)))))) (Big.double (Big.double
           (Big.double (Big.double (Big.double (Big.double (Big.double
           (Big.double (Big.double (Big.double (Big.double (Big.double
           (Big.double (Big.double Big.one)))))))))))))) s
           (Z.sub shifted_m Big.one) exp_val
       in
       de_float_of_bits joined
     | x -> x)
  
  (** val enc_rounding_mode : X86_RTL.rounding_mode -> Big.big_int **)
  
  let enc_rounding_mode = function
  | Mode_ZR -> (Big.doubleplusone Big.one)
  | Mode_DN -> Big.one
  | Mode_UP -> (Big.double Big.one)
  | _ -> Big.zero
  
  type fpu_precision_control =
  | PC_single
  | PC_reserved
  | PC_double
  | PC_double_extended
  
  (** val fpu_precision_control_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> fpu_precision_control -> 'a1 **)
  
  let fpu_precision_control_rect f f0 f1 f2 = function
  | PC_single -> f
  | PC_reserved -> f0
  | PC_double -> f1
  | PC_double_extended -> f2
  
  (** val fpu_precision_control_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> fpu_precision_control -> 'a1 **)
  
  let fpu_precision_control_rec f f0 f1 f2 = function
  | PC_single -> f
  | PC_reserved -> f0
  | PC_double -> f1
  | PC_double_extended -> f2
  
  (** val enc_fpu_precision_control :
      fpu_precision_control -> Big.big_int **)
  
  let enc_fpu_precision_control = function
  | PC_single -> Big.zero
  | PC_reserved -> Big.one
  | PC_double -> (Big.double Big.one)
  | PC_double_extended -> (Big.doubleplusone Big.one)
  
  type fpu_tag_mode =
  | TM_valid
  | TM_zero
  | TM_special
  | TM_empty
  
  (** val fpu_tag_mode_rect :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> fpu_tag_mode -> 'a1 **)
  
  let fpu_tag_mode_rect f f0 f1 f2 = function
  | TM_valid -> f
  | TM_zero -> f0
  | TM_special -> f1
  | TM_empty -> f2
  
  (** val fpu_tag_mode_rec :
      'a1 -> 'a1 -> 'a1 -> 'a1 -> fpu_tag_mode -> 'a1 **)
  
  let fpu_tag_mode_rec f f0 f1 f2 = function
  | TM_valid -> f
  | TM_zero -> f0
  | TM_special -> f1
  | TM_empty -> f2
  
  (** val enc_fpu_tag_mode : fpu_tag_mode -> Big.big_int **)
  
  let enc_fpu_tag_mode = function
  | TM_valid -> Big.zero
  | TM_zero -> Big.one
  | TM_special -> (Big.double Big.one)
  | TM_empty -> (Big.doubleplusone Big.one)
  
  (** val get_stktop : X86_RTL.rtl_exp coq_Conv **)
  
  let get_stktop =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size3,
      X86_MACHINE.Coq_fpu_stktop_loc))
  
  (** val get_fpu_rctrl : X86_RTL.rtl_exp coq_Conv **)
  
  let get_fpu_rctrl =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_loc_rtl_exp (size2,
      X86_MACHINE.Coq_fpu_rctrl_loc))
  
  (** val get_fpu_reg : X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let get_fpu_reg i =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_array_rtl_exp (size3,
      size80, X86_MACHINE.Coq_fpu_datareg, i))
  
  (** val get_fpu_tag : X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let get_fpu_tag i =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_get_array_rtl_exp (size3,
      size2, X86_MACHINE.Coq_fpu_tag, i))
  
  (** val set_stktop : X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_stktop t0 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (size3, t0,
      X86_MACHINE.Coq_fpu_stktop_loc))
  
  (** val set_stktop_const : Big.big_int -> unit coq_Conv **)
  
  let set_stktop_const t0 =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size3 t0)) (fun r2 ->
      set_stktop r2)
  
  (** val set_fpu_flag :
      X86_MACHINE.fpu_flag -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_fpu_flag fl r2 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (size1, r2,
      (X86_MACHINE.Coq_fpu_flag_loc fl)))
  
  (** val set_fpu_flag_const :
      X86_MACHINE.fpu_flag -> Big.big_int -> unit coq_Conv **)
  
  let set_fpu_flag_const fl bit0 =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 bit0))
      (fun r2 -> set_fpu_flag fl r2)
  
  (** val set_fpu_ctrl :
      X86_MACHINE.fpu_ctrl_flag -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_fpu_ctrl cf r2 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (size1, r2,
      (X86_MACHINE.Coq_fpu_ctrl_flag_loc cf)))
  
  (** val set_fpu_ctrl_const :
      X86_MACHINE.fpu_ctrl_flag -> Big.big_int -> unit coq_Conv **)
  
  let set_fpu_ctrl_const cf bit0 =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size1 bit0))
      (fun r2 -> set_fpu_ctrl cf r2)
  
  (** val set_fpu_rctrl : X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_fpu_rctrl r2 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (size2, r2,
      X86_MACHINE.Coq_fpu_rctrl_loc))
  
  (** val set_fpu_rctrl_const : mode -> unit coq_Conv **)
  
  let set_fpu_rctrl_const rm =
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic (load_Z size2 (enc_rounding_mode rm))) (fun r2 ->
      set_fpu_rctrl r2)
  
  (** val set_fpu_pctrl : X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_fpu_pctrl r2 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (size2, r2,
      X86_MACHINE.Coq_fpu_pctrl_loc))
  
  (** val set_fpu_pctrl_const : fpu_precision_control -> unit coq_Conv **)
  
  let set_fpu_pctrl_const pc =
    bind (Obj.magic coq_Conv_monad)
      (Obj.magic (load_Z size2 (enc_fpu_precision_control pc))) (fun r2 ->
      set_fpu_pctrl r2)
  
  (** val set_fpu_lastInstrPtr : X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_fpu_lastInstrPtr r2 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (X86_MACHINE.size48, r2,
      X86_MACHINE.Coq_fpu_lastInstrPtr_loc))
  
  (** val set_fpu_lastInstrPtr_const : Big.big_int -> unit coq_Conv **)
  
  let set_fpu_lastInstrPtr_const v =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z X86_MACHINE.size48 v))
      (fun r2 -> set_fpu_lastInstrPtr r2)
  
  (** val set_fpu_lastDataPtr : X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_fpu_lastDataPtr r2 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (X86_MACHINE.size48, r2,
      X86_MACHINE.Coq_fpu_lastDataPtr_loc))
  
  (** val set_fpu_lastDataPtr_const : Big.big_int -> unit coq_Conv **)
  
  let set_fpu_lastDataPtr_const v =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z X86_MACHINE.size48 v))
      (fun r2 -> set_fpu_lastDataPtr r2)
  
  (** val set_fpu_lastOpcode : X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_fpu_lastOpcode r2 =
    coq_EMIT (X86_RTL.Coq_set_loc_rtl (X86_MACHINE.size11, r2,
      X86_MACHINE.Coq_fpu_lastOpcode_loc))
  
  (** val set_fpu_lastOpcode_const : Big.big_int -> unit coq_Conv **)
  
  let set_fpu_lastOpcode_const v =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z X86_MACHINE.size11 v))
      (fun r2 -> set_fpu_lastOpcode r2)
  
  (** val set_fpu_reg :
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_fpu_reg i v =
    coq_EMIT (X86_RTL.Coq_set_array_rtl (size3, size80,
      X86_MACHINE.Coq_fpu_datareg, i, v))
  
  (** val set_fpu_tag :
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let set_fpu_tag i v =
    coq_EMIT (X86_RTL.Coq_set_array_rtl (size3, size2,
      X86_MACHINE.Coq_fpu_tag, i, v))
  
  (** val set_fpu_tag_const :
      Big.big_int -> fpu_tag_mode -> unit coq_Conv **)
  
  let set_fpu_tag_const loc0 tm =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size3 loc0)) (fun i ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic (load_Z size2 (enc_fpu_tag_mode tm))) (fun v ->
        set_fpu_tag i v))
  
  (** val inc_stktop : unit coq_Conv **)
  
  let inc_stktop =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun st ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size3 Big.one))
        (fun one0 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (arith size3 X86_RTL.Coq_add_op st one0)) (fun newst ->
          set_stktop newst)))
  
  (** val dec_stktop : unit coq_Conv **)
  
  let dec_stktop =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun st ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (load_Z size3 Big.one))
        (fun one0 ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (arith size3 X86_RTL.Coq_sub_op st one0)) (fun newst ->
          set_stktop newst)))
  
  (** val stk_push : X86_RTL.rtl_exp -> unit coq_Conv **)
  
  let stk_push f =
    bind (Obj.magic coq_Conv_monad) dec_stktop (fun x ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun topp ->
        set_fpu_reg topp f))
  
  (** val freg_of_offset : int3 -> X86_RTL.rtl_exp coq_Conv **)
  
  let freg_of_offset offset =
    bind (Obj.magic coq_Conv_monad) get_stktop (fun topp ->
      bind (Obj.magic coq_Conv_monad)
        (load_Z size3 (Word.unsigned (Big.succ (Big.succ Big.zero)) offset))
        (fun ri -> arith size3 X86_RTL.Coq_add_op topp ri))
  
  (** val undef_fpu_flag : X86_MACHINE.fpu_flag -> unit coq_Conv **)
  
  let undef_fpu_flag f =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (choose size1)) (fun v ->
      set_fpu_flag f v)
  
  (** val is_empty_tag : X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let is_empty_tag i =
    bind (Obj.magic coq_Conv_monad) (get_fpu_tag i) (fun tag ->
      bind (Obj.magic coq_Conv_monad)
        (load_Z size2 (Big.doubleplusone Big.one)) (fun empty_tag ->
        test size2 X86_RTL.Coq_eq_op tag empty_tag))
  
  (** val is_nonempty_tag : X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let is_nonempty_tag i =
    bind (Obj.magic coq_Conv_monad) (is_empty_tag i) (fun isempty ->
      not size1 isempty)
  
  (** val test_pos_zero :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_pos_zero ew mw f =
    bind (Obj.magic coq_Conv_monad)
      (load_Z (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw)) Big.zero)
      (fun poszero ->
      test (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw)) X86_RTL.Coq_eq_op f
        poszero)
  
  (** val test_neg_zero :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_neg_zero ew mw f =
    bind (Obj.magic coq_Conv_monad)
      (load_Z (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
        (two_power_nat (plus (Coq_Pos.to_nat mw) (Coq_Pos.to_nat ew))))
      (fun negzero ->
      test (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw)) X86_RTL.Coq_eq_op f
        negzero)
  
  (** val test_zero :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_zero ew mw f =
    bind (Obj.magic coq_Conv_monad) (test_pos_zero ew mw f) (fun isposzero ->
      bind (Obj.magic coq_Conv_monad) (test_neg_zero ew mw f)
        (fun isnegzero -> arith size1 X86_RTL.Coq_or_op isposzero isnegzero))
  
  (** val test_pos_inf :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_pos_inf ew mw f =
    bind (Obj.magic coq_Conv_monad)
      (load_Z (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
        (Z.mul (two_power_nat (Coq_Pos.to_nat mw))
          (Z.sub (two_power_nat (Coq_Pos.to_nat ew)) Big.one)))
      (fun posinf ->
      test (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw)) X86_RTL.Coq_eq_op f
        posinf)
  
  (** val test_neg_inf :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_neg_inf ew mw f =
    bind (Obj.magic coq_Conv_monad)
      (load_Z (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
        (Z.mul (two_power_nat (Coq_Pos.to_nat mw))
          (Z.sub
            (two_power_nat (plus (Coq_Pos.to_nat ew) (Big.succ Big.zero)))
            Big.one))) (fun neginf ->
      test (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw)) X86_RTL.Coq_eq_op f
        neginf)
  
  (** val test_inf :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_inf ew mw f =
    bind (Obj.magic coq_Conv_monad) (test_pos_inf ew mw f) (fun isposinf ->
      bind (Obj.magic coq_Conv_monad) (test_neg_inf ew mw f) (fun isneginf ->
        arith size1 X86_RTL.Coq_or_op isposinf isneginf))
  
  (** val test_qnan :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_qnan ew mw f =
    bind (Obj.magic coq_Conv_monad)
      (load_Z (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
        (Z.mul
          (two_power_nat (minus (Coq_Pos.to_nat mw) (Big.succ Big.zero)))
          (Z.sub
            (two_power_nat (plus (Coq_Pos.to_nat ew) (Big.succ Big.zero)))
            Big.one))) (fun mask0 ->
      bind (Obj.magic coq_Conv_monad)
        (arith (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
          X86_RTL.Coq_and_op f mask0) (fun maskRes ->
        test (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw)) X86_RTL.Coq_eq_op
          maskRes mask0))
  
  (** val test_snan :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_snan ew mw f =
    bind (Obj.magic coq_Conv_monad) (test_inf ew mw f) (fun isinf ->
      bind (Obj.magic coq_Conv_monad) (not size1 isinf) (fun isnotinf ->
        bind (Obj.magic coq_Conv_monad)
          (load_Z (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
            (Z.mul
              (two_power_nat (minus (Coq_Pos.to_nat mw) (Big.succ Big.zero)))
              (Z.sub
                (two_power_nat
                  (plus (Coq_Pos.to_nat ew) (Big.succ Big.zero))) Big.one)))
          (fun mask0 ->
          bind (Obj.magic coq_Conv_monad)
            (arith (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
              X86_RTL.Coq_and_op f mask0) (fun maskRes ->
            bind (Obj.magic coq_Conv_monad)
              (load_Z (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
                (Z.mul (two_power_nat (Coq_Pos.to_nat mw))
                  (Z.sub (two_power_nat (Coq_Pos.to_nat ew)) Big.one)))
              (fun expected ->
              bind (Obj.magic coq_Conv_monad)
                (test (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
                  X86_RTL.Coq_eq_op maskRes expected) (fun is_snan ->
                arith size1 X86_RTL.Coq_and_op isnotinf is_snan))))))
  
  (** val test_nan :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_nan ew mw f =
    bind (Obj.magic coq_Conv_monad) (test_qnan ew mw f) (fun isqnan ->
      bind (Obj.magic coq_Conv_monad) (test_snan ew mw f) (fun issnan ->
        arith size1 X86_RTL.Coq_or_op isqnan issnan))
  
  (** val test_denormal :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_denormal ew mw f =
    bind (Obj.magic coq_Conv_monad) (test_zero ew mw f) (fun iszero ->
      bind (Obj.magic coq_Conv_monad) (not size1 iszero) (fun isnotzero ->
        bind (Obj.magic coq_Conv_monad)
          (load_Z (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
            (Z.mul (two_power_nat (Coq_Pos.to_nat mw))
              (Z.sub (two_power_nat (Coq_Pos.to_nat ew)) Big.one)))
          (fun mask0 ->
          bind (Obj.magic coq_Conv_monad)
            (arith (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
              X86_RTL.Coq_and_op f mask0) (fun maskRes ->
            bind (Obj.magic coq_Conv_monad)
              (load_Z (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
                Big.zero) (fun zero0 ->
              bind (Obj.magic coq_Conv_monad)
                (test (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
                  X86_RTL.Coq_eq_op maskRes zero0) (fun expZero ->
                arith size1 X86_RTL.Coq_and_op isnotzero expZero))))))
  
  (** val test_normal_fin :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_normal_fin ew mw f =
    bind (Obj.magic coq_Conv_monad)
      (load_Z (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
        (Z.mul (two_power_nat (Coq_Pos.to_nat mw))
          (Z.sub (two_power_nat (Coq_Pos.to_nat ew)) Big.one))) (fun mask0 ->
      bind (Obj.magic coq_Conv_monad)
        (arith (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
          X86_RTL.Coq_and_op f mask0) (fun maskRes ->
        bind (Obj.magic coq_Conv_monad)
          (load_Z (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw)) Big.zero)
          (fun zero0 ->
          bind (Obj.magic coq_Conv_monad)
            (test (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
              X86_RTL.Coq_eq_op maskRes zero0) (fun iszero ->
            bind (Obj.magic coq_Conv_monad) (not size1 iszero)
              (fun notzero ->
              bind (Obj.magic coq_Conv_monad)
                (test (plus (Coq_Pos.to_nat ew) (Coq_Pos.to_nat mw))
                  X86_RTL.Coq_eq_op maskRes mask0) (fun maxexpo ->
                bind (Obj.magic coq_Conv_monad) (not size1 maxexpo)
                  (fun notmaxexpo ->
                  arith size1 X86_RTL.Coq_and_op notzero notmaxexpo)))))))
  
  (** val test_fin :
      Big.big_int -> Big.big_int -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp
      coq_Conv **)
  
  let test_fin ew mw f =
    bind (Obj.magic coq_Conv_monad) (test_denormal ew mw f) (fun isdefin ->
      bind (Obj.magic coq_Conv_monad) (test_normal_fin ew mw f)
        (fun isnorfin -> arith size1 X86_RTL.Coq_or_op isdefin isnorfin))
  
  (** val size63 : Big.big_int **)
  
  let size63 =
    Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
      Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
  
  (** val de_float_of_float79 :
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let de_float_of_float79 f =
    bind (Obj.magic coq_Conv_monad) (first_bits size16 size79 f)
      (fun signAndExpo ->
      bind (Obj.magic coq_Conv_monad) (last_bits size63 size79 f)
        (fun mantissa ->
        bind (Obj.magic coq_Conv_monad)
          (test_inf (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
            (Big.doubleplusone (Big.doubleplusone Big.one)))))
            (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
            Big.one))) f) (fun isInf ->
          bind (Obj.magic coq_Conv_monad)
            (test_normal_fin (Big.doubleplusone (Big.doubleplusone
              (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
              Big.one))))) (Big.doubleplusone (Big.doubleplusone
              (Big.doubleplusone Big.one))) f) (fun isNorFin ->
            bind (Obj.magic coq_Conv_monad)
              (arith size1 X86_RTL.Coq_or_op isInf isNorFin) (fun intSig ->
              bind (Obj.magic coq_Conv_monad)
                (concat_bits size1 size63 intSig mantissa) (fun r2 ->
                concat_bits size16
                  (plus (plus size1 size63) (Big.succ Big.zero)) signAndExpo
                  r2))))))
  
  (** val float79_of_de_float :
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let float79_of_de_float f =
    bind (Obj.magic coq_Conv_monad) (first_bits size16 size80 f)
      (fun signAndExpo ->
      bind (Obj.magic coq_Conv_monad) (last_bits size63 size80 f)
        (fun mantissa -> concat_bits size16 size63 signAndExpo mantissa))
  
  (** val fcast :
      Big.big_int -> Big.big_int -> Big.big_int -> Big.big_int ->
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let fcast ew1 mw1 ew2 mw2 rm e =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_fcast_rtl_exp (ew1, mw1,
      ew2, mw2, rm, e))
  
  (** val de_float_of_float32 :
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let de_float_of_float32 f rm =
    bind (Obj.magic coq_Conv_monad)
      (fcast (Big.double (Big.double (Big.double Big.one)))
        (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone (Big.double
        Big.one)))) (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
        Big.one))) (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
        (Big.doubleplusone (Big.doubleplusone Big.one))))) rm f) (fun f' ->
      de_float_of_float79 f')
  
  (** val de_float_of_float64 :
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let de_float_of_float64 f rm =
    bind (Obj.magic coq_Conv_monad)
      (fcast (Big.doubleplusone (Big.doubleplusone (Big.double Big.one)))
        (Big.double (Big.double (Big.doubleplusone (Big.double
        (Big.doubleplusone Big.one))))) (Big.doubleplusone (Big.doubleplusone
        (Big.doubleplusone Big.one))) (Big.doubleplusone (Big.doubleplusone
        (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one)))))
        rm f) (fun f' -> de_float_of_float79 f')
  
  (** val float32_of_de_float :
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let float32_of_de_float f rm =
    bind (Obj.magic coq_Conv_monad) (float79_of_de_float f) (fun f' ->
      fcast (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
        Big.one))) (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
        (Big.doubleplusone (Big.doubleplusone Big.one))))) (Big.double
        (Big.double (Big.double Big.one))) (Big.doubleplusone
        (Big.doubleplusone (Big.doubleplusone (Big.double Big.one)))) rm f')
  
  (** val float64_of_de_float :
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let float64_of_de_float f rm =
    bind (Obj.magic coq_Conv_monad) (float79_of_de_float f) (fun f' ->
      fcast (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
        Big.one))) (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
        (Big.doubleplusone (Big.doubleplusone Big.one))))) (Big.doubleplusone
        (Big.doubleplusone (Big.double Big.one))) (Big.double (Big.double
        (Big.doubleplusone (Big.double (Big.doubleplusone Big.one))))) rm f')
  
  (** val enc_tag : X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let enc_tag f =
    bind (Obj.magic coq_Conv_monad) (float79_of_de_float f) (fun nf ->
      bind (Obj.magic coq_Conv_monad)
        (test_zero (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
          Big.one))) (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
          (Big.doubleplusone (Big.doubleplusone Big.one))))) nf)
        (fun iszero ->
        bind (Obj.magic coq_Conv_monad)
          (test_normal_fin (Big.doubleplusone (Big.doubleplusone
            (Big.doubleplusone Big.one))) (Big.doubleplusone
            (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
            (Big.doubleplusone Big.one))))) nf) (fun isnorfin ->
          bind (Obj.magic coq_Conv_monad)
            (load_Z size2 (enc_fpu_tag_mode TM_valid)) (fun enc_valid ->
            bind (Obj.magic coq_Conv_monad)
              (load_Z size2 (enc_fpu_tag_mode TM_zero)) (fun enc_zero ->
              bind (Obj.magic coq_Conv_monad)
                (load_Z size2 (enc_fpu_tag_mode TM_special))
                (fun enc_special ->
                bind (Obj.magic coq_Conv_monad)
                  (if_exp size2 iszero enc_zero enc_special) (fun z_or_s ->
                  if_exp size2 isnorfin enc_valid z_or_s)))))))
  
  (** val load_fp_op :
      prefix -> segment_register -> fp_operand -> X86_RTL.rtl_exp coq_Conv **)
  
  let load_fp_op pre seg op =
    let sr = get_segment pre seg in
    bind (Obj.magic coq_Conv_monad) get_fpu_rctrl (fun rm ->
      match op with
      | FPS_op i ->
        bind (Obj.magic coq_Conv_monad) (freg_of_offset i) (fun fi ->
          get_fpu_reg fi)
      | FPM16_op a ->
        bind (Obj.magic coq_Conv_monad)
          (Obj.magic (coq_EMIT X86_RTL.Coq_error_rtl)) (fun x ->
          choose size80)
      | FPM32_op a ->
        bind (Obj.magic coq_Conv_monad) (compute_addr a) (fun addr ->
          bind (Obj.magic coq_Conv_monad) (load_mem32 sr addr) (fun val0 ->
            de_float_of_float32 val0 rm))
      | FPM64_op a ->
        bind (Obj.magic coq_Conv_monad) (compute_addr a) (fun addr ->
          bind (Obj.magic coq_Conv_monad) (load_mem64 sr addr) (fun val0 ->
            de_float_of_float64 val0 rm))
      | FPM80_op a ->
        bind (Obj.magic coq_Conv_monad) (compute_addr a) (fun addr ->
          load_mem80 sr addr))
  
  (** val conv_FNCLEX : unit coq_Conv **)
  
  let conv_FNCLEX =
    bind (Obj.magic coq_Conv_monad)
      (set_fpu_flag_const X86_MACHINE.F_PE Big.zero) (fun x ->
      bind (Obj.magic coq_Conv_monad)
        (set_fpu_flag_const X86_MACHINE.F_UE Big.zero) (fun x0 ->
        bind (Obj.magic coq_Conv_monad)
          (set_fpu_flag_const X86_MACHINE.F_OE Big.zero) (fun x1 ->
          bind (Obj.magic coq_Conv_monad)
            (set_fpu_flag_const X86_MACHINE.F_ZE Big.zero) (fun x2 ->
            bind (Obj.magic coq_Conv_monad)
              (set_fpu_flag_const X86_MACHINE.F_DE Big.zero) (fun x3 ->
              bind (Obj.magic coq_Conv_monad)
                (set_fpu_flag_const X86_MACHINE.F_IE Big.zero) (fun x4 ->
                bind (Obj.magic coq_Conv_monad)
                  (set_fpu_flag_const X86_MACHINE.F_ES Big.zero) (fun x5 ->
                  set_fpu_flag_const X86_MACHINE.F_Busy Big.zero)))))))
  
  (** val init_control_word : unit coq_Conv **)
  
  let init_control_word =
    bind (Obj.magic coq_Conv_monad)
      (set_fpu_ctrl_const X86_MACHINE.F_Res15 Big.zero) (fun x ->
      bind (Obj.magic coq_Conv_monad)
        (set_fpu_ctrl_const X86_MACHINE.F_Res14 Big.zero) (fun x0 ->
        bind (Obj.magic coq_Conv_monad)
          (set_fpu_ctrl_const X86_MACHINE.F_Res13 Big.zero) (fun x1 ->
          bind (Obj.magic coq_Conv_monad)
            (set_fpu_ctrl_const X86_MACHINE.F_IC Big.zero) (fun x2 ->
            bind (Obj.magic coq_Conv_monad) (set_fpu_rctrl_const Mode_NE)
              (fun x3 ->
              bind (Obj.magic coq_Conv_monad)
                (set_fpu_pctrl_const PC_double_extended) (fun x4 ->
                bind (Obj.magic coq_Conv_monad)
                  (set_fpu_ctrl_const X86_MACHINE.F_Res6 Big.zero) (fun x5 ->
                  bind (Obj.magic coq_Conv_monad)
                    (set_fpu_ctrl_const X86_MACHINE.F_Res7 Big.one)
                    (fun x6 ->
                    bind (Obj.magic coq_Conv_monad)
                      (set_fpu_ctrl_const X86_MACHINE.F_PM Big.one)
                      (fun x7 ->
                      bind (Obj.magic coq_Conv_monad)
                        (set_fpu_ctrl_const X86_MACHINE.F_UM Big.one)
                        (fun x8 ->
                        bind (Obj.magic coq_Conv_monad)
                          (set_fpu_ctrl_const X86_MACHINE.F_OM Big.one)
                          (fun x9 ->
                          bind (Obj.magic coq_Conv_monad)
                            (set_fpu_ctrl_const X86_MACHINE.F_ZM Big.one)
                            (fun x10 ->
                            bind (Obj.magic coq_Conv_monad)
                              (set_fpu_ctrl_const X86_MACHINE.F_DM Big.one)
                              (fun x11 ->
                              set_fpu_ctrl_const X86_MACHINE.F_IM Big.one)))))))))))))
  
  (** val init_status_word : unit coq_Conv **)
  
  let init_status_word =
    bind (Obj.magic coq_Conv_monad)
      (set_fpu_flag_const X86_MACHINE.F_Busy Big.zero) (fun x ->
      bind (Obj.magic coq_Conv_monad)
        (set_fpu_flag_const X86_MACHINE.F_C3 Big.zero) (fun x0 ->
        bind (Obj.magic coq_Conv_monad) (set_stktop_const Big.zero)
          (fun x1 ->
          bind (Obj.magic coq_Conv_monad)
            (set_fpu_flag_const X86_MACHINE.F_C2 Big.zero) (fun x2 ->
            bind (Obj.magic coq_Conv_monad)
              (set_fpu_flag_const X86_MACHINE.F_C1 Big.zero) (fun x3 ->
              bind (Obj.magic coq_Conv_monad)
                (set_fpu_flag_const X86_MACHINE.F_C0 Big.zero) (fun x4 ->
                bind (Obj.magic coq_Conv_monad)
                  (set_fpu_flag_const X86_MACHINE.F_ES Big.zero) (fun x5 ->
                  bind (Obj.magic coq_Conv_monad)
                    (set_fpu_flag_const X86_MACHINE.F_SF Big.zero) (fun x6 ->
                    bind (Obj.magic coq_Conv_monad)
                      (set_fpu_flag_const X86_MACHINE.F_PE Big.zero)
                      (fun x7 ->
                      bind (Obj.magic coq_Conv_monad)
                        (set_fpu_flag_const X86_MACHINE.F_UE Big.zero)
                        (fun x8 ->
                        bind (Obj.magic coq_Conv_monad)
                          (set_fpu_flag_const X86_MACHINE.F_OE Big.zero)
                          (fun x9 ->
                          bind (Obj.magic coq_Conv_monad)
                            (set_fpu_flag_const X86_MACHINE.F_ZE Big.zero)
                            (fun x10 ->
                            bind (Obj.magic coq_Conv_monad)
                              (set_fpu_flag_const X86_MACHINE.F_DE Big.zero)
                              (fun x11 ->
                              set_fpu_flag_const X86_MACHINE.F_IE Big.zero)))))))))))))
  
  (** val init_tag_word : unit coq_Conv **)
  
  let init_tag_word =
    bind (Obj.magic coq_Conv_monad) (set_fpu_tag_const Big.zero TM_empty)
      (fun x ->
      bind (Obj.magic coq_Conv_monad) (set_fpu_tag_const Big.one TM_empty)
        (fun x0 ->
        bind (Obj.magic coq_Conv_monad)
          (set_fpu_tag_const (Big.double Big.one) TM_empty) (fun x1 ->
          bind (Obj.magic coq_Conv_monad)
            (set_fpu_tag_const (Big.doubleplusone Big.one) TM_empty)
            (fun x2 ->
            bind (Obj.magic coq_Conv_monad)
              (set_fpu_tag_const (Big.double (Big.double Big.one)) TM_empty)
              (fun x3 ->
              bind (Obj.magic coq_Conv_monad)
                (set_fpu_tag_const (Big.doubleplusone (Big.double Big.one))
                  TM_empty) (fun x4 ->
                bind (Obj.magic coq_Conv_monad)
                  (set_fpu_tag_const (Big.double (Big.doubleplusone Big.one))
                    TM_empty) (fun x5 ->
                  set_fpu_tag_const (Big.doubleplusone (Big.doubleplusone
                    Big.one)) TM_empty)))))))
  
  (** val init_last_ptrs : unit coq_Conv **)
  
  let init_last_ptrs =
    bind (Obj.magic coq_Conv_monad) (set_fpu_lastInstrPtr_const Big.zero)
      (fun x ->
      bind (Obj.magic coq_Conv_monad) (set_fpu_lastDataPtr_const Big.zero)
        (fun x0 -> set_fpu_lastOpcode_const Big.zero))
  
  (** val conv_FNINIT : unit coq_Conv **)
  
  let conv_FNINIT =
    bind (Obj.magic coq_Conv_monad) init_control_word (fun x ->
      bind (Obj.magic coq_Conv_monad) init_status_word (fun x0 ->
        bind (Obj.magic coq_Conv_monad) init_tag_word (fun x1 ->
          init_last_ptrs)))
  
  (** val conv_FINCSTP : unit coq_Conv **)
  
  let conv_FINCSTP =
    bind (Obj.magic coq_Conv_monad) inc_stktop (fun x ->
      bind (Obj.magic coq_Conv_monad)
        (set_fpu_flag_const X86_MACHINE.F_C1 Big.zero) (fun x0 ->
        bind (Obj.magic coq_Conv_monad) (undef_fpu_flag X86_MACHINE.F_C0)
          (fun x1 ->
          bind (Obj.magic coq_Conv_monad) (undef_fpu_flag X86_MACHINE.F_C2)
            (fun x2 -> undef_fpu_flag X86_MACHINE.F_C3))))
  
  (** val conv_FDECSTP : unit coq_Conv **)
  
  let conv_FDECSTP =
    bind (Obj.magic coq_Conv_monad) dec_stktop (fun x ->
      bind (Obj.magic coq_Conv_monad)
        (set_fpu_flag_const X86_MACHINE.F_C1 Big.zero) (fun x0 ->
        bind (Obj.magic coq_Conv_monad) (undef_fpu_flag X86_MACHINE.F_C0)
          (fun x1 ->
          bind (Obj.magic coq_Conv_monad) (undef_fpu_flag X86_MACHINE.F_C2)
            (fun x2 -> undef_fpu_flag X86_MACHINE.F_C3))))
  
  (** val stk_push_and_set_tag :
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let stk_push_and_set_tag f =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (stk_push f)) (fun x ->
      bind (Obj.magic coq_Conv_monad) get_stktop (fun topp ->
        bind (Obj.magic coq_Conv_monad) (is_nonempty_tag topp)
          (fun notempty ->
          bind (Obj.magic coq_Conv_monad) (enc_tag f) (fun tag ->
            bind (Obj.magic coq_Conv_monad)
              (Obj.magic (set_fpu_tag topp tag)) (fun x0 ->
              return (Obj.magic coq_Conv_monad) notempty)))))
  
  (** val conv_FLD : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FLD pre op =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_fp_op pre DS op))
      (fun v ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (stk_push_and_set_tag v))
        (fun overflow ->
        bind (Obj.magic coq_Conv_monad)
          (set_fpu_flag X86_MACHINE.F_C1 overflow) (fun x ->
          bind (Obj.magic coq_Conv_monad) (undef_fpu_flag X86_MACHINE.F_C0)
            (fun x0 ->
            bind (Obj.magic coq_Conv_monad) (undef_fpu_flag X86_MACHINE.F_C2)
              (fun x1 -> undef_fpu_flag X86_MACHINE.F_C3)))))
  
  (** val load_stktop : X86_RTL.rtl_exp coq_Conv **)
  
  let load_stktop =
    bind (Obj.magic coq_Conv_monad) get_stktop (fun topp -> get_fpu_reg topp)
  
  (** val conv_FST : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FST pre op =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun topp ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (get_fpu_reg topp))
        (fun v ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (is_empty_tag topp))
          (fun underflow ->
          bind (Obj.magic coq_Conv_monad) (Obj.magic get_fpu_rctrl)
            (fun rm ->
            let sr = get_segment pre DS in
            bind (Obj.magic coq_Conv_monad)
              (match op with
               | FPS_op i ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic (freg_of_offset i)) (fun fi ->
                   set_fpu_reg fi v)
               | FPM16_op a -> coq_EMIT X86_RTL.Coq_error_rtl
               | FPM32_op a ->
                 bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a))
                   (fun addr ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (float32_of_de_float v rm)) (fun f32 ->
                     set_mem32 sr f32 addr))
               | FPM64_op a ->
                 bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a))
                   (fun addr ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (float64_of_de_float v rm)) (fun f64 ->
                     set_mem64 sr f64 addr))
               | FPM80_op a ->
                 bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr a))
                   (fun addr -> set_mem80 sr v addr)) (fun x ->
              bind (Obj.magic coq_Conv_monad)
                (undef_fpu_flag X86_MACHINE.F_C1) (fun x0 ->
                bind (Obj.magic coq_Conv_monad)
                  (Obj.magic (load_Z size1 Big.zero)) (fun zero0 ->
                  bind (Obj.magic coq_Conv_monad)
                    (if_test underflow (X86_RTL.Coq_set_loc_rtl (size1,
                      zero0, (X86_MACHINE.Coq_fpu_flag_loc
                      X86_MACHINE.F_C1)))) (fun x1 ->
                    bind (Obj.magic coq_Conv_monad)
                      (undef_fpu_flag X86_MACHINE.F_C0) (fun x2 ->
                      bind (Obj.magic coq_Conv_monad)
                        (undef_fpu_flag X86_MACHINE.F_C2) (fun x3 ->
                        undef_fpu_flag X86_MACHINE.F_C3))))))))))
  
  (** val stk_pop_and_set_tag : unit coq_Conv **)
  
  let stk_pop_and_set_tag =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun topp ->
      bind (Obj.magic coq_Conv_monad)
        (Obj.magic (load_Z size2 (enc_fpu_tag_mode TM_empty)))
        (fun tag_emp ->
        bind (Obj.magic coq_Conv_monad) (set_fpu_tag topp tag_emp) (fun x ->
          inc_stktop)))
  
  (** val conv_FSTP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FSTP pre op =
    bind (Obj.magic coq_Conv_monad) (conv_FST pre op) (fun x ->
      stk_pop_and_set_tag)
  
  (** val pos1 : int0 **)
  
  let pos1 =
    s2int80
      (append ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
        (append ('1'::('1'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
          (append ('1'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
            (append
              ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
              (append
                ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
                (append
                  ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
                  (append
                    ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
                    (append
                      ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
                      (append
                        ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
                        ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[])))))))))))))))))
  
  (** val log2_10 : int0 **)
  
  let log2_10 =
    s2int80
      (append ('0'::('1'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
        (append ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
          (append ('1'::('1'::('0'::('1'::('0'::('1'::('0'::('0'::[]))))))))
            (append
              ('1'::('0'::('0'::('1'::('1'::('0'::('1'::('0'::[]))))))))
              (append
                ('0'::('1'::('1'::('1'::('1'::('0'::('0'::('0'::[]))))))))
                (append
                  ('0'::('1'::('0'::('0'::('1'::('0'::('1'::('1'::[]))))))))
                  (append
                    ('1'::('1'::('0'::('0'::('1'::('1'::('0'::('1'::[]))))))))
                    (append
                      ('0'::('0'::('0'::('1'::('1'::('0'::('1'::('1'::[]))))))))
                      (append
                        ('1'::('0'::('0'::('0'::('1'::('0'::('1'::('0'::[]))))))))
                        ('1'::('1'::('1'::('1'::('1'::('1'::('1'::('0'::[])))))))))))))))))
  
  (** val log2_e : int0 **)
  
  let log2_e =
    s2int80
      (append ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
        (append ('1'::('1'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
          (append ('1'::('0'::('1'::('1'::('1'::('0'::('0'::('0'::[]))))))))
            (append
              ('1'::('0'::('1'::('0'::('1'::('0'::('1'::('0'::[]))))))))
              (append
                ('0'::('0'::('1'::('1'::('1'::('0'::('1'::('1'::[]))))))))
                (append
                  ('0'::('0'::('1'::('0'::('1'::('0'::('0'::('1'::[]))))))))
                  (append
                    ('0'::('1'::('0'::('1'::('1'::('1'::('0'::('0'::[]))))))))
                    (append
                      ('0'::('0'::('0'::('1'::('0'::('1'::('1'::('1'::[]))))))))
                      (append
                        ('1'::('1'::('1'::('1'::('0'::('0'::('0'::('0'::[]))))))))
                        ('1'::('0'::('1'::('1'::('1'::('1'::('0'::('0'::[])))))))))))))))))
  
  (** val pi : int0 **)
  
  let pi =
    s2int80
      (append ('0'::('1'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
        (append ('0'::('0'::('0'::('0'::('0'::('0'::('0'::('0'::[]))))))))
          (append ('1'::('1'::('0'::('0'::('1'::('0'::('0'::('1'::[]))))))))
            (append
              ('0'::('0'::('0'::('0'::('1'::('1'::('1'::('1'::[]))))))))
              (append
                ('1'::('1'::('0'::('1'::('1'::('0'::('1'::('0'::[]))))))))
                (append
                  ('1'::('0'::('1'::('0'::('0'::('0'::('1'::('0'::[]))))))))
                  (append
                    ('0'::('0'::('1'::('0'::('0'::('0'::('0'::('1'::[]))))))))
                    (append
                      ('0'::('1'::('1'::('0'::('1'::('0'::('0'::('0'::[]))))))))
                      (append
                        ('1'::('1'::('0'::('0'::('0'::('0'::('1'::('0'::[]))))))))
                        ('0'::('0'::('1'::('1'::('0'::('1'::('0'::('1'::[])))))))))))))))))
  
  (** val log10_2 : int0 **)
  
  let log10_2 =
    s2int80
      (append ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
        (append ('1'::('1'::('1'::('1'::('1'::('1'::('0'::('1'::[]))))))))
          (append ('1'::('0'::('0'::('1'::('1'::('0'::('1'::('0'::[]))))))))
            (append
              ('0'::('0'::('1'::('0'::('0'::('0'::('0'::('0'::[]))))))))
              (append
                ('1'::('0'::('0'::('1'::('1'::('0'::('1'::('0'::[]))))))))
                (append
                  ('1'::('0'::('0'::('0'::('0'::('1'::('0'::('0'::[]))))))))
                  (append
                    ('1'::('1'::('1'::('1'::('1'::('0'::('1'::('1'::[]))))))))
                    (append
                      ('1'::('1'::('0'::('0'::('1'::('1'::('1'::('1'::[]))))))))
                      (append
                        ('1'::('1'::('1'::('1'::('0'::('1'::('1'::('1'::[]))))))))
                        ('1'::('0'::('0'::('1'::('1'::('0'::('0'::('1'::[])))))))))))))))))
  
  (** val loge_2 : int0 **)
  
  let loge_2 =
    s2int80
      (append ('0'::('0'::('1'::('1'::('1'::('1'::('1'::('1'::[]))))))))
        (append ('1'::('1'::('1'::('1'::('1'::('1'::('1'::('0'::[]))))))))
          (append ('1'::('0'::('1'::('1'::('0'::('0'::('0'::('1'::[]))))))))
            (append
              ('0'::('1'::('1'::('1'::('0'::('0'::('1'::('0'::[]))))))))
              (append
                ('0'::('0'::('0'::('1'::('0'::('1'::('1'::('1'::[]))))))))
                (append
                  ('1'::('1'::('1'::('1'::('0'::('1'::('1'::('1'::[]))))))))
                  (append
                    ('1'::('1'::('0'::('1'::('0'::('0'::('0'::('1'::[]))))))))
                    (append
                      ('1'::('1'::('0'::('0'::('1'::('1'::('1'::('1'::[]))))))))
                      (append
                        ('0'::('1'::('1'::('1'::('1'::('0'::('0'::('1'::[]))))))))
                        ('1'::('0'::('1'::('0'::('1'::('1'::('0'::('0'::[])))))))))))))))))
  
  (** val conv_load_fpconstant : int0 -> unit coq_Conv **)
  
  let conv_load_fpconstant c =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_int size80 c))
      (fun r2 ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (stk_push_and_set_tag r2))
        (fun overflow ->
        bind (Obj.magic coq_Conv_monad)
          (set_fpu_flag X86_MACHINE.F_C1 overflow) (fun x ->
          bind (Obj.magic coq_Conv_monad) (undef_fpu_flag X86_MACHINE.F_C0)
            (fun x0 ->
            bind (Obj.magic coq_Conv_monad) (undef_fpu_flag X86_MACHINE.F_C2)
              (fun x1 -> undef_fpu_flag X86_MACHINE.F_C3)))))
  
  (** val conv_FLDZ : unit coq_Conv **)
  
  let conv_FLDZ =
    conv_load_fpconstant (Word.repr size80 Big.zero)
  
  (** val conv_FLD1 : unit coq_Conv **)
  
  let conv_FLD1 =
    conv_load_fpconstant pos1
  
  (** val conv_FLDPI : unit coq_Conv **)
  
  let conv_FLDPI =
    conv_load_fpconstant pi
  
  (** val conv_FLDL2T : unit coq_Conv **)
  
  let conv_FLDL2T =
    conv_load_fpconstant log2_10
  
  (** val conv_FLDL2E : unit coq_Conv **)
  
  let conv_FLDL2E =
    conv_load_fpconstant log2_e
  
  (** val conv_FLDLG2 : unit coq_Conv **)
  
  let conv_FLDLG2 =
    conv_load_fpconstant log10_2
  
  (** val conv_FLDLN2 : unit coq_Conv **)
  
  let conv_FLDLN2 =
    conv_load_fpconstant loge_2
  
  (** val farith_float79 :
      X86_RTL.float_arith_op -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let farith_float79 op rm e1 e2 =
    return (Obj.magic coq_Conv_monad) (X86_RTL.Coq_farith_rtl_exp
      ((Big.doubleplusone (Big.doubleplusone (Big.doubleplusone Big.one))),
      (Big.doubleplusone (Big.doubleplusone (Big.doubleplusone
      (Big.doubleplusone (Big.doubleplusone Big.one))))), op, rm, e1, e2))
  
  (** val farith_de :
      X86_RTL.float_arith_op -> X86_RTL.rtl_exp -> X86_RTL.rtl_exp ->
      X86_RTL.rtl_exp -> X86_RTL.rtl_exp coq_Conv **)
  
  let farith_de op rm e1 e2 =
    bind (Obj.magic coq_Conv_monad) (float79_of_de_float e1) (fun e1' ->
      bind (Obj.magic coq_Conv_monad) (float79_of_de_float e2) (fun e2' ->
        bind (Obj.magic coq_Conv_monad) (farith_float79 op rm e1' e2')
          (fun res -> de_float_of_float79 res)))
  
  (** val conv_farith :
      X86_RTL.float_arith_op -> bool -> prefix -> bool -> fp_operand -> unit
      coq_Conv **)
  
  let conv_farith fop noreverse pre zerod op =
    bind (Obj.magic coq_Conv_monad) (Obj.magic (load_fp_op pre DS op))
      (fun opv ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun topp ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic (get_fpu_reg topp))
          (fun st0 ->
          bind (Obj.magic coq_Conv_monad) (Obj.magic (is_empty_tag topp))
            (fun underflow ->
            bind (Obj.magic coq_Conv_monad) (Obj.magic get_fpu_rctrl)
              (fun rm ->
              bind (Obj.magic coq_Conv_monad)
                (if zerod
                 then if noreverse
                      then Obj.magic (farith_de fop rm st0 opv)
                      else Obj.magic (farith_de fop rm opv st0)
                 else if noreverse
                      then Obj.magic (farith_de fop rm opv st0)
                      else Obj.magic (farith_de fop rm st0 opv)) (fun res ->
                bind (Obj.magic coq_Conv_monad)
                  (if zerod
                   then (match op with
                         | FPM16_op a -> coq_EMIT X86_RTL.Coq_error_rtl
                         | FPM80_op a -> coq_EMIT X86_RTL.Coq_error_rtl
                         | _ -> set_fpu_reg topp res)
                   else (match op with
                         | FPS_op i ->
                           bind (Obj.magic coq_Conv_monad)
                             (Obj.magic (freg_of_offset i)) (fun fi ->
                             set_fpu_reg fi res)
                         | _ -> coq_EMIT X86_RTL.Coq_error_rtl)) (fun x ->
                  bind (Obj.magic coq_Conv_monad)
                    (undef_fpu_flag X86_MACHINE.F_C1) (fun x0 ->
                    bind (Obj.magic coq_Conv_monad)
                      (Obj.magic (load_Z size1 Big.zero)) (fun zero0 ->
                      bind (Obj.magic coq_Conv_monad)
                        (if_test underflow (X86_RTL.Coq_set_loc_rtl (size1,
                          zero0, (X86_MACHINE.Coq_fpu_flag_loc
                          X86_MACHINE.F_C1)))) (fun x1 ->
                        bind (Obj.magic coq_Conv_monad)
                          (undef_fpu_flag X86_MACHINE.F_C0) (fun x2 ->
                          bind (Obj.magic coq_Conv_monad)
                            (undef_fpu_flag X86_MACHINE.F_C2) (fun x3 ->
                            undef_fpu_flag X86_MACHINE.F_C3))))))))))))
  
  (** val conv_farith_and_pop :
      X86_RTL.float_arith_op -> bool -> prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_farith_and_pop fop noreverse pre op = match op with
  | FPS_op i ->
    bind (Obj.magic coq_Conv_monad) (conv_farith fop noreverse pre false op)
      (fun x -> stk_pop_and_set_tag)
  | _ -> coq_EMIT X86_RTL.Coq_error_rtl
  
  (** val conv_FADD : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FADD =
    conv_farith X86_RTL.Coq_fadd_op true
  
  (** val conv_FSUB : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FSUB =
    conv_farith X86_RTL.Coq_fsub_op true
  
  (** val conv_FMUL : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FMUL =
    conv_farith X86_RTL.Coq_fmul_op true
  
  (** val conv_FDIV : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FDIV =
    conv_farith X86_RTL.Coq_fdiv_op true
  
  (** val conv_FADDP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FADDP =
    conv_farith_and_pop X86_RTL.Coq_fadd_op true
  
  (** val conv_FSUBP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FSUBP =
    conv_farith_and_pop X86_RTL.Coq_fsub_op true
  
  (** val conv_FMULP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FMULP =
    conv_farith_and_pop X86_RTL.Coq_fmul_op true
  
  (** val conv_FDIVP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FDIVP =
    conv_farith_and_pop X86_RTL.Coq_fdiv_op true
  
  (** val conv_FSUBR : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FSUBR =
    conv_farith X86_RTL.Coq_fsub_op false
  
  (** val conv_FDIVR : prefix -> bool -> fp_operand -> unit coq_Conv **)
  
  let conv_FDIVR =
    conv_farith X86_RTL.Coq_fdiv_op false
  
  (** val conv_FSUBRP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FSUBRP =
    conv_farith_and_pop X86_RTL.Coq_fsub_op false
  
  (** val conv_FDIVRP : prefix -> fp_operand -> unit coq_Conv **)
  
  let conv_FDIVRP =
    conv_farith_and_pop X86_RTL.Coq_fdiv_op false
  
  (** val float_compare : de_float -> de_float -> comparison **)
  
  let float_compare a b =
    let aR =
      b2R (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double Big.one)))))) (Big.double (Big.double (Big.double
        (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double Big.one)))))))))))))) a
    in
    let bR =
      b2R (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double Big.one)))))) (Big.double (Big.double (Big.double
        (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double (Big.double (Big.double (Big.double (Big.double
        (Big.double Big.one)))))))))))))) b
    in
    rcompare aR bR
  
  (** val set_CC_flags : comparison -> unit coq_Conv **)
  
  let set_CC_flags = function
  | Eq ->
    bind (Obj.magic coq_Conv_monad)
      (set_fpu_flag_const X86_MACHINE.F_C3 Big.one) (fun x ->
      bind (Obj.magic coq_Conv_monad)
        (set_fpu_flag_const X86_MACHINE.F_C2 Big.zero) (fun x0 ->
        set_fpu_flag_const X86_MACHINE.F_C0 Big.zero))
  | Lt ->
    bind (Obj.magic coq_Conv_monad)
      (set_fpu_flag_const X86_MACHINE.F_C3 Big.zero) (fun x ->
      bind (Obj.magic coq_Conv_monad)
        (set_fpu_flag_const X86_MACHINE.F_C2 Big.zero) (fun x0 ->
        set_fpu_flag_const X86_MACHINE.F_C0 Big.one))
  | Gt ->
    bind (Obj.magic coq_Conv_monad)
      (set_fpu_flag_const X86_MACHINE.F_C3 Big.zero) (fun x ->
      bind (Obj.magic coq_Conv_monad)
        (set_fpu_flag_const X86_MACHINE.F_C2 Big.zero) (fun x0 ->
        set_fpu_flag_const X86_MACHINE.F_C0 Big.zero))
  
  (** val conv_FCOM : fp_operand option -> unit coq_Conv **)
  
  let conv_FCOM op1 =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun topp ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (get_fpu_reg topp))
        (fun st0 ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic get_fpu_rctrl) (fun rm ->
          match op1 with
          | Some op ->
            (match op with
             | FPM32_op adr ->
               bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr adr))
                 (fun addr ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic (load_mem32 DS addr)) (fun val0 ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (de_float_of_float32 val0 rm)) (fun d_val ->
                     undef_fpu_flag X86_MACHINE.F_C3)))
             | FPM64_op adr ->
               bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr adr))
                 (fun addr ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic (load_mem64 DS addr)) (fun val0 ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (de_float_of_float64 val0 rm)) (fun d_val ->
                     undef_fpu_flag X86_MACHINE.F_C3)))
             | _ -> undef_fpu_flag X86_MACHINE.F_C3)
          | None -> undef_fpu_flag X86_MACHINE.F_C3)))
  
  (** val conv_FICOM : fp_operand option -> unit coq_Conv **)
  
  let conv_FICOM op1 =
    bind (Obj.magic coq_Conv_monad) (Obj.magic get_stktop) (fun topp ->
      bind (Obj.magic coq_Conv_monad) (Obj.magic (get_fpu_reg topp))
        (fun st0 ->
        bind (Obj.magic coq_Conv_monad) (Obj.magic get_fpu_rctrl) (fun rm ->
          match op1 with
          | Some op ->
            (match op with
             | FPM32_op adr ->
               bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr adr))
                 (fun addr ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic (load_mem32 DS addr)) (fun val0 ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (de_float_of_float32 val0 rm)) (fun d_val ->
                     undef_fpu_flag X86_MACHINE.F_C3)))
             | FPM64_op adr ->
               bind (Obj.magic coq_Conv_monad) (Obj.magic (compute_addr adr))
                 (fun addr ->
                 bind (Obj.magic coq_Conv_monad)
                   (Obj.magic (load_mem64 DS addr)) (fun val0 ->
                   bind (Obj.magic coq_Conv_monad)
                     (Obj.magic (de_float_of_float64 val0 rm)) (fun d_val ->
                     undef_fpu_flag X86_MACHINE.F_C3)))
             | _ -> undef_fpu_flag X86_MACHINE.F_C3)
          | None -> undef_fpu_flag X86_MACHINE.F_C3)))
  
  (** val conv_FCOMP : fp_operand option -> unit coq_Conv **)
  
  let conv_FCOMP op1 =
    bind (Obj.magic coq_Conv_monad) (conv_FCOM op1) (fun x ->
      stk_pop_and_set_tag)
  
  (** val conv_FCOMPP : unit coq_Conv **)
  
  let conv_FCOMPP =
    bind (Obj.magic coq_Conv_monad) (conv_FCOMP None) (fun x ->
      stk_pop_and_set_tag)
  
  (** val conv_FICOMP : fp_operand option -> unit coq_Conv **)
  
  let conv_FICOMP op1 =
    bind (Obj.magic coq_Conv_monad) (conv_FICOM op1) (fun x ->
      stk_pop_and_set_tag)
  
  (** val conv_FICOMPP : unit coq_Conv **)
  
  let conv_FICOMPP =
    bind (Obj.magic coq_Conv_monad) (conv_FICOMP None) (fun x ->
      stk_pop_and_set_tag)
  
  (** val instr_to_rtl : prefix -> instr -> X86_RTL.rtl_instr list **)
  
  let instr_to_rtl pre i =
    runConv
      (bind (Obj.magic coq_Conv_monad) (check_prefix pre) (fun x ->
        match i with
        | AAA -> conv_AAA_AAS X86_RTL.Coq_add_op
        | AAD -> conv_AAD
        | AAM -> conv_AAM
        | AAS -> conv_AAA_AAS X86_RTL.Coq_sub_op
        | ADC (w, op1, op2) -> conv_ADC pre w op1 op2
        | ADD (w, op1, op2) -> conv_ADD pre w op1 op2
        | AND (w, op1, op2) -> conv_AND pre w op1 op2
        | BSF (op1, op2) -> conv_BSF pre op1 op2
        | BSR (op1, op2) -> conv_BSR pre op1 op2
        | BSWAP r2 -> conv_BSWAP pre r2
        | BT (op1, op2) -> conv_BT false true pre op1 op2
        | BTC (op1, op2) -> conv_BT false false pre op1 op2
        | BTR (op1, op2) -> conv_BT true false pre op1 op2
        | BTS (op1, op2) -> conv_BT true true pre op1 op2
        | CALL (near, abs0, op1, sel) -> conv_CALL pre near abs0 op1 sel
        | CDQ -> conv_CDQ pre
        | CLC -> conv_CLC
        | CLD -> conv_CLD
        | CMC -> conv_CMC
        | CMOVcc (ct, op1, op2) -> conv_CMOV pre true ct op1 op2
        | CMP (w, op1, op2) -> conv_CMP pre w op1 op2
        | CMPS w -> conv_CMPS pre w
        | CMPXCHG (w, op1, op2) -> conv_CMPXCHG pre w op1 op2
        | CWDE -> conv_CWDE pre
        | DAA -> conv_DAA_DAS X86_RTL.Coq_add_op (testcarryAdd size8)
        | DAS -> conv_DAA_DAS X86_RTL.Coq_sub_op (testcarrySub size8)
        | DEC (w, op1) -> conv_DEC pre w op1
        | DIV (w, op) -> conv_DIV pre w op
        | FADD (d, op1) -> conv_FADD pre d op1
        | FADDP op1 -> conv_FADDP pre op1
        | FDECSTP -> conv_FDECSTP
        | FDIV (d, op) -> conv_FDIV pre d op
        | FDIVP op -> conv_FDIVP pre op
        | FDIVR (d, op) -> conv_FDIVR pre d op
        | FDIVRP op -> conv_FDIVRP pre op
        | FINCSTP -> conv_FINCSTP
        | FLD op -> conv_FLD pre op
        | FLDL2E -> conv_FLDL2E
        | FLDL2T -> conv_FLDL2T
        | FLDLG2 -> conv_FLDLG2
        | FLDLN2 -> conv_FLDLN2
        | FLDPI -> conv_FLDPI
        | FLDZ -> conv_FLDZ
        | FMUL (d, op1) -> conv_FMUL pre d op1
        | FMULP op1 -> conv_FMULP pre op1
        | FNCLEX -> conv_FNCLEX
        | FNINIT -> conv_FNINIT
        | FST op1 -> conv_FST pre op1
        | FSTP op1 -> conv_FSTP pre op1
        | FSUB (d, op1) -> conv_FSUB pre d op1
        | FSUBP op1 -> conv_FSUBP pre op1
        | FSUBR (d, op) -> conv_FSUBR pre d op
        | FSUBRP op -> conv_FSUBRP pre op
        | HLT -> conv_HLT pre
        | IDIV (w, op) -> conv_IDIV pre w op
        | IMUL (w, op1, op2, i0) -> conv_IMUL pre w op1 op2 i0
        | INC (w, op1) -> conv_INC pre w op1
        | Jcc (ct, disp) -> conv_Jcc pre ct disp
        | JMP (near, abs0, op1, sel) -> conv_JMP pre near abs0 op1 sel
        | LAHF -> conv_LAHF
        | LEA (op1, op2) -> conv_LEA pre op1 op2
        | LEAVE -> conv_LEAVE pre
        | LOOP disp -> conv_LOOP pre false false disp
        | LOOPZ disp -> conv_LOOP pre true true disp
        | LOOPNZ disp -> conv_LOOP pre true false disp
        | MOV (w, op1, op2) -> conv_MOV pre w op1 op2
        | MOVS w -> conv_MOVS pre w
        | MOVSX (w, op1, op2) -> conv_MOVSX pre w op1 op2
        | MOVZX (w, op1, op2) -> conv_MOVZX pre w op1 op2
        | MUL (w, op) -> conv_MUL pre w op
        | NEG (w, op1) -> conv_NEG pre w op1
        | NOP op -> return (Obj.magic coq_Conv_monad) ()
        | NOT (w, op1) -> conv_NOT pre w op1
        | OR (w, op1, op2) -> conv_OR pre w op1 op2
        | POP op -> conv_POP pre op
        | POPA -> conv_POPA pre
        | PUSH (w, op) -> conv_PUSH pre w op
        | PUSHA -> conv_PUSHA pre
        | RCL (w, op1, op2) -> conv_RCL pre w op1 op2
        | RCR (w, op1, op2) -> conv_RCR pre w op1 op2
        | RET (ss, disp) -> conv_RET pre ss disp
        | ROL (w, op1, op2) -> conv_ROL pre w op1 op2
        | ROR (w, op1, op2) -> conv_ROR pre w op1 op2
        | SAHF -> conv_SAHF
        | SAR (w, op1, op2) -> conv_SAR pre w op1 op2
        | SBB (w, op1, op2) -> conv_SBB pre w op1 op2
        | SETcc (ct, op) -> conv_SETcc pre ct op
        | SHL (w, op1, op2) -> conv_SHL pre w op1 op2
        | SHLD (op1, op2, ri) -> conv_SHLD pre op1 op2 ri
        | SHR (w, op1, op2) -> conv_SHR pre w op1 op2
        | SHRD (op1, op2, ri) -> conv_SHRD pre op1 op2 ri
        | STC -> conv_STC
        | STD -> conv_STD
        | STOS w -> conv_STOS pre w
        | SUB (w, op1, op2) -> conv_SUB pre w op1 op2
        | TEST (w, op1, op2) -> conv_TEST pre w op1 op2
        | XADD (w, op1, op2) -> conv_XADD pre w op1 op2
        | XCHG (w, op1, op2) -> conv_XCHG pre w op1 op2
        | XOR (w, op1, op2) -> conv_XOR pre w op1 op2
        | _ -> coq_EMIT X86_RTL.Coq_error_rtl))
 end

(** val in_seg_bounds : segment_register -> int32 -> bool X86_RTL.coq_RTL **)

let in_seg_bounds s o1 =
  bind (Obj.magic X86_RTL.coq_RTL_monad)
    (Obj.magic
      (X86_RTL.get_loc size32 (X86_MACHINE.Coq_seg_reg_limit_loc s)))
    (fun seg_limit ->
    return (Obj.magic X86_RTL.coq_RTL_monad)
      (Word.lequ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) o1 seg_limit))

(** val in_seg_bounds_rng :
    segment_register -> int32 -> int32 -> bool X86_RTL.coq_RTL **)

let in_seg_bounds_rng s o1 offset =
  bind (Obj.magic X86_RTL.coq_RTL_monad)
    (Obj.magic
      (X86_RTL.get_loc size32 (X86_MACHINE.Coq_seg_reg_limit_loc s)))
    (fun seg_limit ->
    let o2 =
      Word.add (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
        (Big.succ (Big.succ (Big.succ (Big.succ
        Big.zero))))))))))))))))))))))))))))))) o1 offset
    in
    return (Obj.magic X86_RTL.coq_RTL_monad)
      ((&&)
        (Word.lequ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))) o1 o2)
        (Word.lequ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
          (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))) o2
          seg_limit)))

type parseState_t = instParserState

(** val parse_instr_aux :
    Big.big_int -> int32 -> Big.big_int -> parseState_t ->
    ((prefix * instr) * Big.big_int) X86_RTL.coq_RTL **)

let rec parse_instr_aux n loc0 len ps =
  Big.nat_case
    (fun _ ->
    X86_RTL.coq_Fail)
    (fun m ->
    bind (Obj.magic X86_RTL.coq_RTL_monad)
      (Obj.magic (X86_RTL.get_byte loc0)) (fun b ->
      let (ps', l) = X86_PARSER.parse_byte ps b in
      (match l with
       | [] ->
         parse_instr_aux m
           (Word.add (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
             (Big.succ (Big.succ Big.zero))))))))))))))))))))))))))))))) loc0
             (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
               (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
               Big.one)) (Coq_Pos.add len Big.one) ps'
       | v :: l0 -> return (Obj.magic X86_RTL.coq_RTL_monad) (v, len))))
    n

(** val initial_parser_state : parseState_t option **)

let initial_parser_state =
  X86_PARSER.opt_initial_decoder_state (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
    Big.zero)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(** val parse_instr' :
    parseState_t option -> int32 -> ((prefix * instr) * Big.big_int)
    X86_RTL.coq_RTL **)

let parse_instr' ps pc =
  bind (Obj.magic X86_RTL.coq_RTL_monad)
    (Obj.magic
      (X86_RTL.get_loc size32 (X86_MACHINE.Coq_seg_reg_start_loc CS)))
    (fun seg_start ->
    let real_pc = Word.add size32 seg_start pc in
    (match ps with
     | Some ps0 ->
       parse_instr_aux (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
         (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
         (Big.succ (Big.succ (Big.succ (Big.succ Big.zero)))))))))))))))
         real_pc Big.one ps0
     | None -> X86_RTL.coq_Fail))

(** val parse_instr :
    int32 -> ((prefix * instr) * Big.big_int) X86_RTL.coq_RTL **)

let parse_instr =
  parse_instr' initial_parser_state

(** val fetch_instruction :
    int32 -> ((prefix * instr) * Big.big_int) X86_RTL.coq_RTL **)

let fetch_instruction pc =
Printf.printf "pc_fetch:  %s\n" (string_of_big_int  pc);
  bind (Obj.magic X86_RTL.coq_RTL_monad) (parse_instr pc) (fun v ->
    let (pi0, len) = v in
    bind (Obj.magic X86_RTL.coq_RTL_monad)
      (Obj.magic
        (in_seg_bounds_rng CS pc
          (Word.repr (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ (Big.succ
            (Big.succ (Big.succ Big.zero)))))))))))))))))))))))))))))))
            (Z.sub len Big.one)))) (fun in_bounds_rng ->
      if in_bounds_rng
      then return (Obj.magic X86_RTL.coq_RTL_monad) (pi0, len)
      else X86_RTL.coq_Trap))

(** val rTL_step_list : X86_RTL.rtl_instr list -> unit X86_RTL.coq_RTL **)

let rec rTL_step_list = function
| [] -> return (Obj.magic X86_RTL.coq_RTL_monad) ()
| i :: l' ->
  bind (Obj.magic X86_RTL.coq_RTL_monad) (X86_RTL.interp_rtl i) (fun x ->
    rTL_step_list l')

(** val check_rep_instr : instr -> unit X86_RTL.coq_RTL **)

let check_rep_instr = function
| CMPS w -> return (Obj.magic X86_RTL.coq_RTL_monad) ()
| MOVS w -> return (Obj.magic X86_RTL.coq_RTL_monad) ()
| STOS w -> return (Obj.magic X86_RTL.coq_RTL_monad) ()
| _ -> X86_RTL.coq_Fail

(** val run_rep : prefix -> instr -> int32 -> unit X86_RTL.coq_RTL **)

let run_rep pre ins default_new_pc =
  bind (Obj.magic X86_RTL.coq_RTL_monad) (check_rep_instr ins) (fun x ->
    bind (Obj.magic X86_RTL.coq_RTL_monad)
      (Obj.magic (X86_RTL.get_loc size32 (X86_MACHINE.Coq_reg_loc ECX)))
      (fun ecx ->
      if Word.eq size32 ecx (Word.zero size32)
      then X86_RTL.set_loc size32 X86_MACHINE.Coq_pc_loc default_new_pc
      else bind (Obj.magic X86_RTL.coq_RTL_monad)
             (X86_RTL.set_loc size32 (X86_MACHINE.Coq_reg_loc ECX)
               (Word.sub size32 ecx (Word.one size32))) (fun x0 ->
             bind (Obj.magic X86_RTL.coq_RTL_monad)
               (rTL_step_list (X86_Compile.instr_to_rtl pre ins)) (fun x1 ->
               bind (Obj.magic X86_RTL.coq_RTL_monad)
                 (Obj.magic
                   (X86_RTL.get_loc size32 (X86_MACHINE.Coq_reg_loc ECX)))
                 (fun ecx' ->
                 bind (Obj.magic X86_RTL.coq_RTL_monad)
                   (if Word.eq size32 ecx' (Word.zero size32)
                    then X86_RTL.set_loc size32 X86_MACHINE.Coq_pc_loc
                           default_new_pc
                    else return (Obj.magic X86_RTL.coq_RTL_monad) ())
                   (fun x2 ->
                   match ins with
                   | CMPS w ->
                     bind (Obj.magic X86_RTL.coq_RTL_monad)
                       (Obj.magic
                         (X86_RTL.get_loc size1 (X86_MACHINE.Coq_flag_loc
                           X86_MACHINE.ZF))) (fun zf ->
                       if Word.eq size1 zf (Word.zero size1)
                       then X86_RTL.set_loc size32 X86_MACHINE.Coq_pc_loc
                              default_new_pc
                       else return (Obj.magic X86_RTL.coq_RTL_monad) ())
                   | _ -> return (Obj.magic X86_RTL.coq_RTL_monad) ()))))))

(** val step : unit X86_RTL.coq_RTL **)

let step =
bind 
(Obj.magic X86_RTL.coq_RTL_monad)
(Obj.magic (X86_RTL.get_loc size32 X86_MACHINE.Coq_pc_loc ))
(fun pc -> 
bind 
(Obj.magic X86_RTL.coq_RTL_monad) 
(Obj.magic (in_seg_bounds CS pc))
(fun pc_in_bounds -> 
  if pc_in_bounds
      then  bind (Obj.magic X86_RTL.coq_RTL_monad)
             (Obj.magic (fetch_instruction pc)) (fun v ->
             let (pi0, length1) = v in
             let (pre, instr0) = pi0 in
             let default_new_pc =
               Word.add size32 pc (Word.repr size32 length1)
             in
             (match pre.lock_rep with
              | Some l ->
                (match l with
                 | Rep -> run_rep pre instr0 default_new_pc
                 | _ -> X86_RTL.coq_Fail)
              | None ->
                bind (Obj.magic X86_RTL.coq_RTL_monad)
                  (X86_RTL.set_loc size32 X86_MACHINE.Coq_pc_loc
                    default_new_pc) (fun x ->
                  rTL_step_list (X86_Compile.instr_to_rtl pre instr0))))
      else (Printf.printf "pc10:  %s\n" (string_of_big_int  pc); X86_RTL.coq_Trap))) 


