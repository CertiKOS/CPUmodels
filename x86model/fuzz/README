(* NOTE - the extracted code for Decode.ml is very slow to start up
   because it is constructing all of the environments for the derivative
   based parsing. However... we don't need that just to generate some
   code! Therefore I usually just comment out the bottom of the extracted
   file. I need to come up with a better method for this *)


To get started, you must do:

  make extraction (run make extract-nob if you want to extract without first attempting
                   to build the Coq files in the x86model directory)
  make

This directory contains a fuzzer for x86 byte code. The extracted code,
Fuzz.ml,takes parsers, as defined in Decode.v or elsewhere, and generates
byte code that is in the language recognized by these parsers.

The file fuzzgen.ml is a driver script for this. It emits the ascii
for the hex code corresponding to the generated byte code. 

The script ./fuzzer.sh glues everything together. Here's what it does
- Calls fuzzgen.ml and dumps the result in fuzz.ascii
- Calls xxd -r -p on fuzz.ascii to produce fuzz.hex (xxd -r -p takes
  ascii values for hex and converts it into the corresponding binary)
- Then runs ld on fuzz.hex to produce fuzz.obj - the result is an elf
  file that defines symbols called _binary_fuzz_hex_start/end/size. 
- Runs gcc on test.c, linking it with this fuzz.obj file, to produce
  test.out

test.c is a little C program that has a declared external function pointer
_binary_fuzz_hex_start. All it does in main() is just call this function
pointer. Which, after linking with fuzz.obj, will be the generated
code we want to run!

One problem is that the fuzz.obj file defines the _binary_fuzz_hex symbols
as data, so that objdump -d test.out will not disassemble them. You need
to instead run objdump -D test.out (note the capital D) to get it to
disassemble this stuff.
